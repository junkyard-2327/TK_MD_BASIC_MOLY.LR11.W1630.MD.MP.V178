/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

 /*******************************************************************************
 * Filename:
 * ---------
 *   em_struct.h
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Engineer mode public structures.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 * 				HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/


#ifndef _EM_PUBLIC_STRUCT_H
#define _EM_PUBLIC_STRUCT_H

#include "ps_public_struct.h"
#include "kal_general_types.h"
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"
#include "ps_em_enum.h"
#include "ps_public_enum.h"
#include "global_type.h"
#include "l4c_common_enum_public.h"

typedef kal_uint32 request_info_type;

#define EM_MOD_NIL          0xFFFFFFFF
#define EM_MOD_TOTAL        10
#define EM_MARK_MOD_GEMINI      0x80000000
#define EM_UNMARK_MOD_GEMINI    0x7FFFFFFF

#define MMRR_MAX_NUM_PRIORITY_PLMNS  20
#define MMRR_MAX_NUM_AVAILABLE_PLMNS 20

#define MMRR_PLMN_INFO_LOW_QUALITY_PLMN    1
#define MMRR_PLMN_INFO_HIGH_QUALITY_PLMN   0
#define MMRR_PLMN_INFO_QUALITY_PLMN_OFFSET 7

#define MMRR_PLMN_INFO_RAT_LTE             2
#define MMRR_PLMN_INFO_RAT_UMTS            1
#define MMRR_PLMN_INFO_RAT_GSM             0
#define MMRR_PLMN_INFO_RAT_OFFSET          3

#define MMRR_PLMN_INFO_OTHER_PLMN          4
#define MMRR_PLMN_INFO_OPLMN               3
#define MMRR_PLMN_INFO_UPLMN               2
#define MMRR_PLMN_INFO_PLMNSEL             1
#define MMRR_PLMN_INFO_HPLMN               0

#define MMRR_MAX_NUM_HPLMN_RAT_DATA          16
#define MMRR_MAX_NUM_OPLMN_RAT_DATA          200
#define MMRR_MAX_NUM_STATIC_APPLMN_RAT_DATA  384
#define MMRR_MAX_NUM_DYNAMIC_APPLMM_RAT_DATA 96

#define ERRC_EUTRA_RRC_MESSAGE_HDR_SIZE 40
#define ERRC_MAX_EUTRA_RRC_MESSAGE_S_DATA_LEN (256 - ERRC_EUTRA_RRC_MESSAGE_HDR_SIZE)
#define ERRC_MAX_EUTRA_RRC_MESSAGE_M_DATA_LEN (512 - ERRC_EUTRA_RRC_MESSAGE_HDR_SIZE)
#define ERRC_MAX_EUTRA_RRC_MESSAGE_L_DATA_LEN (4096 - ERRC_EUTRA_RRC_MESSAGE_HDR_SIZE)

typedef enum
{
   /* RR */
    /* Begin of RR EM INFO Request enum */
   RR_EM_CELL_SELECT_PARA_INFO = 0, RR_EM_INFO_BEGIN = RR_EM_CELL_SELECT_PARA_INFO,
   RR_EM_CHANNEL_DESCR_INFO = 1,
   RR_EM_CTRL_CHANNEL_DESCR_INFO = 2,
   RR_EM_RACH_CTRL_PARA_INFO = 3,
   RR_EM_LAI_INFO = 4,
   RR_EM_RADIO_LINK_COUNTER_INFO = 5,
   RR_EM_MEASUREMENT_REPORT_INFO = 6,
   /* ZY : Temp solution : Cell allocation list*/
   RR_EM_CA_LIST_INFO = 7,
   /* RR new structure */
   RR_EM_CONTROL_MSG_INFO = 8,
   RR_EM_SI2Q_INFO_STRUCT_INFO = 9,
   RR_EM_MI_INFO_STRUCT_INFO = 10,
   RR_EM_BLK_INFO = 11,
   RR_EM_TBF_INFO = 12,
   RR_EM_GPRS_GENERAL_INFO = 13,
   /* GAS MM EM INFO */
   RRM_EM_FDD_IR_PARAMETER_STATUS_IND_STRUCT_INFO = 14,
   RRM_EM_IR_RESELECT_STATUS_IND_STRUCT_INFO = 15,
   RRM_EM_IR_3G_NEIGHBOR_MEAS_STATUS_IND_STRUCT_INFO = 16,
   RRM_EM_IR_3G_NEIGHBOR_MEAS_INFO_IND_STRUCT_INFO = 17,
   RRM_EM_IR_4G_NEIGHBOR_MEAS_STATUS_IND_STRUCT_INFO = 18,
   RRM_EM_IR_4G_NEIGHBOR_MEAS_INFO_IND_STRUCT_INFO = 19,
   RRM_EM_SERV_CELL_POWER_STATUS_IND_STRUCT_INFO = 20,
   RRM_EM_IR_3G_NEIGHBOR_CELL_STATUS_IND_STRUCT_INFO = 21,
   RRM_EM_IR_4G_NEIGHBOR_CELL_STATUS_IND_STRUCT_INFO = 22,
   RRM_EM_TDD_IR_PARAMETER_STATUS_IND_STRUCT_INFO = 23,
   RRM_EM_SUCCESS_RATE_KPI_INFO = 24,
   RRM_EM_MT_T3126_TIMEOUT_INFO = 25,
   RRM_EM_CS_RLF_INFO = 26,
   RR_EM_INFO_END = RR_EM_INFO_BEGIN + 49,

   /*End of RR EM INFO Request enum*/

   /* CC */
   CC_EM_CHANNEL_INFO = 50,
   CC_EM_CALL_INFO = 51,

   /* SS */
   SS_EM_INFO = 52,

   /* MM */
   MM_EM_INFO = 53,
   /*EM ehancement for RR new structure*/
   MMRR_EM_PLMN_INFO_STRUCT_INFO = 54,

   /* UEM */
   UEM_EM_BATTERY_INFO = 55,

   /* gprs em begins */
   GMM_EM_INFO = 56,
//   TCM_EM_EXT_PDP_INFO,
//   TCM_EM_INT_PDP_INFO,
//   TCM_EM_CONTEXT_INFO, //new
//   SNDCP_EM_INFO,
   LLC_EM_INFO = 57,
   /* PPP , removed because of no use*/
   //PPP_EM_INFO,
   SM_EM_INFO = 58,
   EM_TCM_INFO_IND = 59,

   MMRR_EM_PLMN_LIST_REQ_STRUCT_INFO = 60,
   MMRR_EM_PLMN_LIST_CNF_STRUCT_INFO = 61,
   MMRR_EM_PLMN_SEARCH_REQ_STRUCT_INFO = 62,
   MMRR_EM_PLMN_SEARCH_CNF_STRUCT_INFO = 63,
   MMRR_EM_HPLMN_LIST_INFO = 64,
   MMRR_EM_OPLMN_LIST_INFO = 65,
   MMRR_EM_STATIC_APPLMN_LIST_INFO = 66,
   MMRR_EM_DYNAMIC_APPLMN_LIST_INFO = 67,

//#ifdef __VIDEO_CALL_SUPPORT__
    /* VT EM Display, 2007/11/30 */
    /* VT owner comments VT EM enum is not needed in WR8 */
    //VT_EM_CALL_STATE_INFO = 50, VT_EM_BEGIN = VT_EM_CALL_STATE_INFO,/* vt_em_call_state_choice */
    //VT_EM_MASTER_SLAVE_STATUS_INFO,     /* vt_em_master_slave_status_choice */
    //VT_EM_RETRANSMISSION_PROTOCOL_INFO, /* vt_em_retransmission_protocol_choice */
    //VT_EM_INCOMING_AUDIO_CHANNEL_INFO,  /* vt_em_audio_channel_info_struct */
    //VT_EM_OUTGOING_AUDIO_CHANNEL_INFO,  /* vt_em_audio_channel_info_struct */
    //VT_EM_INCOMING_VIDEO_CHANNEL_INFO,  /* vt_em_video_channel_info_struct */
    //VT_EM_OUTGOING_VIDEO_CHANNEL_INFO,  /* vt_em_video_channel_info_struct */
    //VT_EM_ADM_MEM_MAX_USED_INFO,        /* kal_uint32 */
    //VT_EM_STATISTIC_INFO,               /* vt_em_statistic_info_struct */
    //VT_EM_ROUND_TRIP_DELAY_INFO,        /* kal_uint32 */
    //VT_EM_INCOMING_XSRP_INFO,           /* vt_em_incoming_xSRP */
    //VT_EM_OUTGOING_XSRP_INFO,           /* vt_em_outgoing_xSRP */
	//VT_EM_END = VT_EM_OUTGOING_XSRP_INFO,
//#endif

//#ifdef __UMTS_RAT__          //For MAUI, MONZA2G exclude 3G
   /**
    * Gibran 20061228
    * UAS MEME/CSCE measuremnt and cell status structure
    */
   MMRR_EM_PLMN_LOSS_INFO_STRUCT_INFO,
   MMRR_EM_PLMN_SEARCH_CNF_INFO_STRUCT_INFO,
   /* URR common Range 1, from enum 70 to 169.
      it's used for both FDD and TDD */
   FDD_EM_URR_3G_GENERAL_STATUS_IND = 70, URR_EM_INFO_BEGIN = FDD_EM_URR_3G_GENERAL_STATUS_IND,
   /* Put 1st XXX_STATUS_IND_STRUCT_INFO in front of XXX_EM_INFO_BEGIN
      in order to show enum_name in XXX_STATUS_IND_STRUCT_INFO not in XXX_EM_INFO_BEGIN. */

   EM_SIBE_3G_SIB_IND_STRUCT_INFO = 71,
   TDD_EM_URR_3G_GENERAL_STATUS_IND = 72,
   FDD_EM_CSCE_SERV_CELL_IND_STRUCT_INFO = 75,
   FDD_EM_CSCE_NEIGH_CELL_IND_STRUCT_INFO = 76,
   FDD_EM_CSCE_R_STATUS_IND_STRUCT_INFO = 77,
   FDD_EM_CSCE_H_STATUS_IND_STRUCT_INFO = 78,
   FDD_EM_CSCE_APBCR_STATUS_IND_STRUCT_INFO = 79,
   FDD_EM_CSCE_MEAS_RULE_STATUS_IND_STRUCT_INFO = 80,
   FDD_EM_CSCE_MULTIPLE_PLMN_IND_STRUCT_INFO = 81,
   TDD_EM_CSCE_SERV_CELL_IND_STRUCT_INFO = 82,
   TDD_EM_CSCE_NEIGH_CELL_IND_STRUCT_INFO = 83,
   TDD_EM_CSCE_R_STATUS_IND_STRUCT_INFO = 84,
   TDD_EM_CSCE_H_STATUS_IND_STRUCT_INFO = 85,
   TDD_EM_CSCE_APBCR_STATUS_IND_STRUCT_INFO = 86,
   TDD_EM_CSCE_MEAS_RULE_STATUS_IND_STRUCT_INFO = 87,
   TDD_EM_CSCE_MULTIPLE_PLMN_IND_STRUCT_INFO = 88,

    /*SIM*/
   EM_SIM_MONITOR_EVENT_INFO = 89,

   EM_TDD_MEME_INFO_DCH_UMTS_CELL_INFO = 90, TDD_MEME_EM_INFO_BEGIN = EM_TDD_MEME_INFO_DCH_UMTS_CELL_INFO,
   EM_TDD_MEME_INFO_DCH_GSM_CELL_INFO = 91,
   EM_TDD_MEME_INFO_DCH_LTE_CELL_INFO = 92,
   EM_TDD_MEME_INFO_EVENT_TYPE_1_PARAMETER_STRUCT_INFO = 93,
   EM_TDD_MEME_INFO_EVENT_TYPE_2_PARAMETER_STRUCT_INFO = 94,
   EM_TDD_MEME_INFO_EVENT_TYPE_3_PARAMETER_STRUCT_INFO =95,
//   EM_MEME_INFO_EVENT_TYPE_4_PARAMETER_STRUCT_INFO,
//   EM_MEME_INFO_EVENT_TYPE_5_PARAMETER_STRUCT_INFO,
//   EM_MEME_INFO_EVENT_TYPE_6_PARAMETER_STRUCT_INFO,
//   EM_MEME_INFO_DCH_H_SERVING_CELL_INFO,
//   EM_TDD_MEME_INFO_DCH_3G_BLER_INFO = 96, 
   EM_TDD_MEME_INFO_GSM_CELL_INFO =97, //for CMCC FT Tool
   EM_TDD_MEME_INFO_LTE_CELL_INFO =98, //for CMCC FT Tool
//   EM_MEME_INFO_FACH_LTE_CELL_INFO = 100, 
   EM_TDD_MEME_INFO_REPORT_INFO = 99,
   TDD_MEME_EM_INFO_END = TDD_MEME_EM_INFO_BEGIN + 15,

   /* Call Information */
   EM_CALL_INFO_IND = 106,

   /* SIP Information */
   EM_IMC_SIP_INFO_IND = 107,
   
   MMRF_EM_MIPI_HW_INFO = 108,

   EM_RRCE_TGPS_STATUS_IND= 110,
   EM_SLCE_SRNCID_STATUS_IND= 111,
//#ifdef __UMTS_TDD128_MODE__
   EM_UAS_3G_TDD128_HANDOVER_SEQUENCE_IND = 130,
//#endif
   EM_RRCE_3G4_REDIR_EVENT = 131,
   EM_RRCE_KPI_STATUS_IND = 132,
   TDD_EM_RRCE_CONN_STATUS_IND = 133,

   EM_SLCE_PS_DATA_RATE_STATUS_IND = 140,
   EM_RRCE_DCH_STATE_CONFIGURATION_STATUS_IND = 155,
   EM_RRCE_FACH_STATE_CONFIGURATION_STATUS_IND = 156,
   EM_RRCE_CS_OVER_HSPA_STATUS_IND = 157,
   EM_RRCE_3G_SECURITY_CONFIGURATION_INFO_IND = 158,
   EM_RRCE_FD_CONFIGURATION_STATUS_IND = 159,
   EM_RRCE_HSPA_CONFIG_IND = 160,   /* MOLY00100048, Jack Chu,  EM_RRCE_HSPA_CONFIG_IND == 160 */
   EM_RRCE_RLF_IND = 161,  /* __ALPS02506878_SUPPORT__ */
   URR_EM_INFO_END = EM_RRCE_RLF_IND,
//#endif /* __UMTS_RAT__ */
//#ifdef __UMTS_R8__
   /* __UL1_EM_MODE__ */
   UL1_EM_HS_DSCH_CONFIGURATION_INFO = 170, UL1_EM_INFO_BEGIN = UL1_EM_HS_DSCH_CONFIGURATION_INFO,
   UL1_EM_EDCH_CONFIGURATION_INFO = 171,
   UL1_EM_CPC_CONFIGURATION_INFO = 172,
   UL1_EM_SECONDARY_HS_CONFIGURATION_STATUS_INFO = 173,
   UL1_EM_PRIMARY_HS_DSCH_BLER_INFO = 174,
   UL1_EM_SECONDARY_HS_DSCH_BLER_INFO = 175,
   UL1_EM_EDCH_ACK_RATE_INFO = 176,   UL1_EM_INFO_END = UL1_EM_EDCH_ACK_RATE_INFO,  /* for backward compatibility */
   UL1_EM_PRX_DRX_MEASUREMENT_INFO = 177,
   /* HSDSCH info group  */
   UL1_EM_HSPA_INFO_GROUP = 178,
   UL1_EM_TAS_INFO = 179,
   UL1_EM_RADIO_LINK_SYNC_STATUS = 180,
//#endif
//#if defined(__UMTS_RAT__) && defined(__UMTS_TDD128_MODE__)
   /* __UL2_EM_MODE__ */
   UL2_EM_ADM_POOL_STATUS_IND_STRUCT_INFO = 185, UL2_EM_INFO_BEGIN = UL2_EM_ADM_POOL_STATUS_IND_STRUCT_INFO,
   UL2_EM_PS_DATA_RATE_STATUS_IND_STRUCT_INFO = 186,
   UL2_EM_HSDSCH_RECONFIG_STATUS_IND_STRUCT_INFO = 187,
   UL2_EM_URLC_EVENT_STATUS_IND_STRUCT_INFO = 188,
   UL2_EM_3G_BLER_IND_STRUCT_INFO = 189,
   UL2_EM_WCDMA_RLC_STATS_STRUCT_INFO = 190,
   UL2_EM_URLC_LAYER_TPUT_INFO = 191,
   /* UMAC new EM Arch */
   /***HSUPA SI***/
   UL2_EM_HSUPA_SI_IND_STRUCT_INFO = 192,
   /***HSUPA SI***/

   /* UMAC EM 2015 */
   UL2_EM_UMAC_DCH_INFO = 193,
   UL2_EM_UMAC_EDCH_INFO = 194,
   UL2_EM_UMAC_HSDSCH_INFO = 195,
   UL2_EM_URLC_ATT_RLC_STATISTICS_INFO = 196,
   UL2_EM_URLC_ATT_RLC_RESET_INFO = 197,
   UL2_EM_UMAC_PCH_CRC_ERR_INFO = 198,
   UL2_EM_UMAC_PCH_INFO = 199,
   UL2_EM_INFO_END = UL2_EM_UMAC_PCH_INFO,
//#endif

   /*ERRC_EM_MODE, here is the start of errc em info definition*/
   ERRC_EM_MOB_MEAS_INTRARAT_INFO = 210, ERRC_EM_INFO_BEGIN = ERRC_EM_MOB_MEAS_INTRARAT_INFO,
   ERRC_EM_MOB_MEAS_INTERRAT_UTRAN_INFO = 211,
   ERRC_EM_MOB_MEAS_INTERRAT_GERAN_INFO = 212,
   ERRC_EM_AUTOS_CSG_INFO = 213,
   ERRC_EM_CARRS_EVENT_IND = 214,
   ERRC_EM_SIB_EVENT_IND = 215,
   ERRC_EM_MOB_EVENT_IND = 216,
   ERRC_EM_SEC_PARAM = 217,
   ERRC_EM_REEST_INFO = 218,
   ERRC_EM_RECONF_INFO = 219,
   ERRC_EM_RCM_SIM_STS_INFO = 220,
   ERRC_EM_SYS_SIB_RX_STS_INFO = 221,
   ERRC_EM_ERRC_STATE_IND = 222,
   ERRC_EM_OVER_PROC_DELAY_WARNING = 223,
   ERRC_EM_LTE_SUPPORTED_BAND_INFO = 224,
   ERRC_EM_ERRC_KPI_INFO = 225,
   ERRC_EM_ERRC_CONFIG_INFO = 226,
//#ifdef __LTE_R11__
   ERRC_EM_CONN_INFO = 227,
//#endif
   ERRC_EM_INFO_END = ERRC_EM_CONN_INFO,

   /* __ESM_EM_MODE__ */
   ESM_ESM_INFO = 228,
   ESM_L4C_ESM_INFO = 229,

   /* __EMM_EM_MODE__ Range 1 */
   EMM_EM_SEC_INFO = 230, EMM_EM_INFO_BEGIN = EMM_EM_SEC_INFO,
   EMM_EM_PLMNSEL_INFO = 231,
   EMM_EM_CONN_INFO = 232,
   EMM_EM_NASMSG_INFO = 233,
   EMM_EM_CALL_INFO = 234,
   EMM_EM_REG_ATTACH_INFO = 235,
   EMM_EM_REG_DETACH_INFO = 236,
   EMM_EM_REG_TAU_INFO = 237,
   EMM_EM_REG_COMMON_INFO = 238,
   EMM_EM_SV_INFO = 239,
   EMM_EM_RATBAND_INFO = 240,
   EMM_EM_TIMERSRV_INFO = 241,
   EMM_EM_USIMSRV_INFO = 242,
   EMM_EM_NVMSRV_INFO = 243,
   EMM_EM_INFO_END = EMM_EM_NVMSRV_INFO,

   EMM_L4C_EMM_INFO = 244,

   EM_EL2_OV_STATUS = 245,
   EM_EL1_OV_STATUS = 246,
   EM_QBM_STATUS = 247,
   EM_UPCM_STATUS = 248,

   /* EL1 */
   EM_EL1_INFO = 249,

   EM_CSR_STATUS_IND = 250,

   RAC_EM_INFO = 251,

   /* EL2 public status */
   EM_EL2_PUB_STATUS = 252,

   EMM_L4C_LAI_CHANGE_INFO = 253,

   /*RATCM*/
   RATCM_EM_23G_RAT_CHANGE_IND = 254, RATCM_EM_INFO_BEGIN = RATCM_EM_23G_RAT_CHANGE_IND,

   EM_EL1_B3B39_INFO = 255,
   
   RATCM_EM_INFO_END = RATCM_EM_INFO_BEGIN + 20,

   /* L4C */
   EM_L4C_RAT_CHANGE_IND = 275,
   EM_L4C_MDMI_RAT_INFO_IND = 282,

   /* EMAC RACH */
   EM_EMAC_RACH_TRIGGER = 276,
   EM_EMAC_RACH_FINISH = 277,
   EM_EMAC_MSG2_REPORT = 278,
   EM_EMAC_MSG4_REPORT = 279,

   /* EMAC 500MS */
   EM_EMAC_OV_STATUS_500 = 280,

   /* EMAC TIMER_EXPIRE */
   EM_EMAC_TIMER_EXPIRE = 281,
   /* EM CONFIG REPORT */
   EM_EMAC_CONFIG_REPORT = 283,

  /*EMAC RACH for Innowireless EM*/
   EM_EMAC_RACH_SUCCESS = 285,
   EM_EMAC_RACH_FAILURE = 286,

    /* EMAC EMBMS */
   EM_EMAC_EMBMS_REPORT = 287,

   /* EMAC DL TBS REPORT */
   EM_EMAC_DL_TBS_REPORT = 288,

   /* EL1 CIQ for ATT*/
   EM_EL1_CIQ_RLF_STATUS_INFO        = 290, EM_EL1_CIQ_INFO_BEGIN = EM_EL1_CIQ_RLF_STATUS_INFO,
   EM_EL1_CIQ_PUSCH_INFO             = 291,
   EM_EL1_CIQ_INFO_END               = EM_EL1_CIQ_INFO_BEGIN + 10,

   /* IPCORE */
   IPC_EM_UL_THROTTLE_STATUS = 326,

   /*ERRC_EM_MODE, here is the start of errc em info definition of Range 2*/
   ERRC_EM_SERV_IR_NEIGHBOR_INFO = 327, ERRC_EM_INFO_BEGIN_R2 = ERRC_EM_SERV_IR_NEIGHBOR_INFO,
   ERRC_EM_IR_REDIR_EVENT = 328,
   ERRC_EM_IRAT_MEAS_CFG = 329,
   ERRC_EM_MOB_MEAS_CONFIG_INFO_IND = 330,
   ERRC_EM_MOB_MEAS_REPORT_INFO_IND = 331,
   ERRC_EM_MOB_MEAS_INTERRAT_C2K_INFO = 332,
   ERRC_EM_LTE_RRC_STATE_IND = 333,
   ERRC_EM_SERVING_INFO = 334,
   ERRC_EM_PAGING_FAIL = 335,
   ERRC_EM_RLF_EVENT = 336,
   ERRC_EM_TIMER_EXPIRY_EVENT = 337,
   ERRC_EM_HO_EVENT = 338,
   ERRC_EM_ERRC_SYS_MIB_SIB_READEVENT_INFO = 339,
   ERRC_EM_SRVCC_BSIC_INFO = 340,
   ERRC_EM_MFROM_INFO = 341,
   ERRC_EM_FEATURE_DETECTION = 342,
   ERRC_EM_CA_INFO = 344,
   ERRC_EM_EUTRA_RRC_MESSAGE_S = 345,
   ERRC_EM_EUTRA_RRC_MESSAGE_M = 346,
   ERRC_EM_EUTRA_RRC_MESSAGE_L = 347,
   ERRC_EM_SRVCC_CELL_INFO = 351, 
   ERRC_EM_SRVCC_HO_FAIL_EVENT =352,
   ERRC_EM_INFO_END_R2 = ERRC_EM_SRVCC_HO_FAIL_EVENT,
   ERRC_EM_INFO_END_RESERVED = ERRC_EM_INFO_BEGIN_R2 + 30,

   /* UPCM */
   EM_UPCM_PS_TPUT_INFO = 358,

   MM_EM_MTC_TIMER_INFO = 359,
   MM_EM_LU_INFO = 360,
   MM_EM_RAU_INFO = 361,

   /* USIME capability */
   USIME_EM_INFO_CAPABILITY = 362, USIME_EM_INFO_BEGIN = USIME_EM_INFO_CAPABILITY,
   USIME_EM_INFO_END = USIME_EM_INFO_BEGIN + 30,

   MM_EM_MT_CSFB_INFO = 393,
   MM_EM_CSFB_STATUS = 394,

   /* FDD URR common Range 2, the range should be 400 ~ 599 */
   /* FDD CSCE Range 2 */
   FDD_CSCE_EM_INFO_BEGIN_R2 = 400, FDD_URR_EM_INFO_BEGIN_R2 = FDD_CSCE_EM_INFO_BEGIN_R2,
   FDD_CSCE_EM_INFO_END_R2 = 449,
   /* FDD RRCE Range 2 */
   FDD_RRCE_EM_INFO_BEGIN_R2 = 450,
   FDD_RRCE_EM_INFO_END_R2 = 499,   
   /* FDD MEME Range 2 */
   EM_FDD_MEME_INFO_DCH_UMTS_CELL_INFO = 500, FDD_MEME_EM_INFO_BEGIN_R2 = EM_FDD_MEME_INFO_DCH_UMTS_CELL_INFO,
   EM_FDD_MEME_INFO_DCH_GSM_CELL_INFO = 501,
   EM_FDD_MEME_INFO_DCH_LTE_CELL_INFO = 502,
   EM_FDD_MEME_INFO_DCH_H_SERVING_CELL_INFO = 503,
   EM_FDD_MEME_INFO_DCH_3G_BLER_INFO = 504,
   EM_FDD_MEME_INFO_FACH_LTE_CELL_INFO = 505,
   EM_FDD_MEME_INFO_EVENT_TYPE_3_PARAMETER_INFO = 506,        // For NVIOT EM MeasCtrl E3x
   EM_FDD_MEME_INFO_REPORT_INFO = 507,                        // For NVIOT EM MEasRpt E3x
   FDD_MEME_EM_INFO_END_R2 = 549,
   
   /* FDD SLCE Range 2 */
   FDD_SLCE_EM_INFO_BEGIN_R2 = 550,
   FDD_SLCE_EM_INFO_END_R2 = 559,

   /* FDD SIBE Range 2 */
   FDD_SIBE_EM_INFO_BEGIN_R2 = 560,
   FDD_SIBE_EM_INFO_END_R2 = 569,

   /* for other FDD URR modules, 569 ~ 599 */

   FDD_URR_EM_INFO_END_R2 = 599,


   /* VDM */
   EM_VDM_CALL_INFO_IND = 601,

   /* IMC */
   IMC_EM_IPSEC_INFO_IND = 602, IMC_EM_INFO_BEGIN = IMC_EM_IPSEC_INFO_IND,
   IMC_EM_IMC_INFO_IND = 603,
   IMC_EM_BEARER_INFO_IND = 604,
   IMC_EM_REG_INFO_IND = 605,
   IMC_EM_SMS_INFO_IND = 606,
   IMC_EM_CALL_INFO_IND = 607,
   IMC_EM_CONF_INFO_IND = 608,
   IMC_EM_SRVCC_INFO_IND = 609,
   IMC_EM_PCSCF_INFO_IND = 610,
   IMC_EM_MEDIA_INFO_IND = 611,
   IMC_EM_INFO_END = IMC_EM_INFO_BEGIN + 20,

   /* __EMM_EM_MODE__ Range 2, the range should be 625 ~ 629*/
   EMM_EM_REG_EVENT_INFO = 625, EMM_EM_INFO_RANGE_2_BEGIN = EMM_EM_REG_EVENT_INFO,  
   EMM_EM_INFO_RANGE_2_END = EMM_EM_INFO_RANGE_2_BEGIN+4,      
   

   EM_SPEECH_INFO_BEGIN = 630,  EM_SPEECH_INFO_SPH_CODEC = EM_SPEECH_INFO_BEGIN,
   EM_SPEECH_INFO_END = 649, 
   
   /* NWSEL */
   NWSEL_EM_TIMER_INFO = 650,
   NWSEL_EM_INFO_BEGIN = NWSEL_EM_TIMER_INFO,
   NWSEL_EM_PLMN_LIST_REQ_INFO = 651,
   NWSEL_EM_PLMN_LIST_CNF_INFO = 652,
   NWSEL_EM_PLMN_SEARCH_REQ_INFO = 653,
   NWSEL_EM_HPLMN_INFO_INFO = 654,
   NWSEL_EM_OPLMN_INFO_INFO = 655,
   NWSEL_EM_STATIC_APPLMN_INFO = 656,
   NWSEL_EM_DYNAMIC_APPLMN_INFO = 657,
   NWSEL_EM_INFO_END = NWSEL_EM_INFO_BEGIN+30,

   /* Abnormal event for smart logging phase2 */
   /* Naming format: EM_ABNORMAL_EVENT_(MOD)_(NAME) */
   EM_ABNORMAL_EVENT_RAC_NO_SERVICE = 681,

   /* LTECSR */
   LTECSR_EM_RTP_CODEC = 682,
   LTECSR_EM_RTP_PACKET_LOSS = 683,
   LTECSR_EM_RTP_ONE_WAY_DELAY = 684,
   LTECSR_EM_RTP_JITTER = 685,
   LTECSR_EM_RTP_JITTER_BUFFER_DELAY = 686,
   LTECSR_EM_RTP_OTA_MSG = 687,
   LTECSR_EM_SESSION_STAT = 688,
   LTECSR_EM_XMIT_PKT = 689,
   LTECSR_EM_RECV_PKT = 690,
   LTECSR_EM_XMIT_STAT = 691,
   LTECSR_EM_RECV_STAT = 692,
   LTECSR_EM_RTP_INFO = 693,
   LTECSR_EM_RTCP_INFO = 694,
      
   /* TDD URR common Range 2, the range should be 700 ~ 899
      before put TDD URR EM enum below, please make sure relative function already consider the enum range,
      e.g. TDD_RRC_HandleEmUpdateReq() should cover enum 700 ~ 899. */
   TDD_URR_EM_INFO_BEGIN_R2 = 700,
   TDD_URR_EM_INFO_END_R2 = 899,

   /* GMSS: 900 ~ 919 */
   GMSS_EM_INFO_BEGIN = 900,
   GMSS_EM_WORLD_PHONE_INFO = GMSS_EM_INFO_BEGIN,
   GMSS_EM_INFO_END = GMSS_EM_WORLD_PHONE_INFO+19,    

   /* EL1 MDMI for VzW*/
   EM_EL1_STATUS_CSR_RPT_INFO        = 921, EM_EL1_MDMI_INFO_BEGIN = EM_EL1_STATUS_CSR_RPT_INFO,
   EM_EL1_STATUS_SRV_MEAS_RPT_INFO   = 922,
   EM_EL1_STATUS_PBCH_RPT_INFO       = 923,
   EM_EL1_STATUS_PCFICH_RPT_INFO     = 924,
   EM_EL1_STATUS_PDCCH_RPT_INFO      = 925,
   EM_EL1_STATUS_PDSCH_RPT_INFO      = 926,
   EM_EL1_STATUS_PHICH_RPT_INFO      = 927,
   EM_EL1_STATUS_PMCH_RPT_INFO       = 928,
   EM_EL1_STATUS_DCI_RPT_INFO        = 929,
   EM_EL1_STATUS_PUCCH_RPT_INFO      = 930,
   EM_EL1_STATUS_PUCCH_CSI_RPT_INFO  = 931,
   EM_EL1_STATUS_PUSCH_RPT_INFO      = 932,
   EM_EL1_STATUS_PUSCH_CSI_RPT_INFO  = 933,
   EM_EL1_STATUS_SRS_RPT_INFO        = 934,
   EM_EL1_STATUS_CELLTIME_RPT_INFO   = 935,
   EM_EL1_STATUS_SR_CFG_INFO         = 936,
   EM_EL1_STATUS_PRACH_INFO          = 937,
   EM_EL1_STATUS_RACH_INFO           = 938,
   EM_EL1_STATUS_PCH_INFO            = 939,
   EM_EL1_STATUS_TA_INFO             = 940,
   EM_EL1_STATUS_PHR_INFO            = 941,   
   EM_EL1_STATUS_DL_TPUT_INFO        = 942,
   EM_EL1_STATUS_UL_TPUT_INFO        = 943,
   EM_EL1_MDMI_INFO_END              = EM_EL1_MDMI_INFO_BEGIN + 25,

   /* GL1: 950 ~ 959 */
   GL1_EM_TAS_INFO = 950,

   /* TDD L1 */
   TDD_EM_L1_TAS_INFO = 960, TDD_EM_L1_INFO_BEGIN = TDD_EM_L1_TAS_INFO,
   TDD_EM_L1_INFO_END = TDD_EM_L1_TAS_INFO + 4,
   
   
   
   NUM_OF_EM_INFO,
   INVALID_EM_INFO = 0x7fffffff //end tag force this enum 4 bytes, for alignment purpose. Don't remove
} em_info_enum;

/**************************************************************************
  * common structure/enumeration
  **************************************************************************/

typedef enum
{
    SIM_EVENT_CARD_LOSS,
	SIM_EVENT_ATR_ERROR,
	SIM_EVENT_PLUG_OUT,
	SIM_EVENT_PLUG_IN,
	SIM_EVENT_CARD_COMMUNICATE_ERROR,
	SIM_EVENT_CARD_REFRESH
} sim_monitor_type;

typedef struct
{
    LOCAL_PARA_HDR
	em_info_enum em_info;
	sim_monitor_type event_type;
	kal_uint32 count;
} em_sim_monitor_event_info_ind_struct;

typedef struct
{
    kal_uint8 mcc1;
    kal_uint8 mcc2;
    kal_uint8 mcc3;
    kal_uint8 mnc1;
    kal_uint8 mnc2;
    kal_uint8 mnc3;
} plmn_struct;

typedef enum {
    EM_CELL_TYPE_SUITABLE       = 0,
    EM_CELL_TYPE_ACCEPTABLE     = 1,
    EM_CELL_TYPE_CAMPED_NOT_ALLOWED = 2,
    EM_CELL_TYPE_NOT_APPLICABLE = 3
} em_as_cell_type_enum;

typedef struct
{
    kal_uint8 mcc1;
    kal_uint8 mcc2;
    kal_uint8 mcc3;
    kal_uint8 mnc1;
    kal_uint8 mnc2;
    kal_uint8 mnc3;
    em_as_cell_type_enum cell_type;
} em_multi_plmn_struct;

typedef enum {
    ACCESS_CLASS_NOT_BARRED      = 0,
    ACCESS_CLASS_EMERGENCY_ONLY  = 1,
    ACCESS_CLASS_ALL_BARRED      = 2,
    ACCESS_CLASS_NOT_AVAILABLE   = 3
} access_class_level_enum;

typedef enum {
    PPAC_FOR_NONE_DOMAIN = 0,
    PPAC_FOR_CS_DOMAIN = 1,
    PPAC_FOR_PS_DOMAIN = 2,
    PPAC_FOR_CS_PS_DOMAIN = 3,
    PPAC_NOT_AVAILABLE = 4
} ppac_domain_enum;

typedef enum {
    EM_KPI_STATUS_BEGIN,
    EM_KPI_STATUS_SUCCESS,
    EM_KPI_STATUS_FAILURE,

    EM_KPI_STATUS_NUM
} em_kpi_status_enum;

typedef enum {
    EM_KPI_FAILURE_TYPE_INVALID,
    EM_KPI_FAILURE_TYPE_S_FAILURE,
    EM_KPI_FAILURE_TYPE_SIB_READ_FAILURE,
    EM_KPI_FAILURE_TYPE_DL_WEAK_IND,
    EM_KPI_FAILURE_TYPE_CELL_BARRED,
    EM_KPI_FAILURE_TYPE_NON_EQ_PLMN,
    EM_KPI_FAILURE_TYPE_FORBIDDEN_TA,
    EM_KPI_FAILURE_TYPE_ABORTED,
    EM_KPI_FAILURE_TYPE_FORBIDDEN_CSG_ID,
    EM_KPI_FAILURE_TYPE_IRAT_RESEL_FAILURE,
    EM_KPI_FAILURE_TYPE_FREQ_BARRED,
    EM_KPI_FAILURE_TYPE_OTHERS
} em_kpi_failure_type_enum;


//mtk01616_080622: for L4A code gen (Do NOT remove)
#define EM_INFO_REQ_NUM NUM_OF_EM_INFO

/* local parameter structures */

/* To identify the status of info_request */
typedef enum
{
    EM_OFF = 0,
    EM_ON  = 1,
    EM_NC  = 2 /* No change */
} em_info_status_enum;

typedef enum
{
    ANTENNA_CONFIG_NORMAL_DUAL		=	0x1,	// normal dual receiver operation (default UE behavior)
    ANTENNA_CONFIG_SINGLE_PRIMARY	=	0x2,	// Single receiver operation ' enable primary receiver only (disable secondary/MIMO receiver)
    ANTENNA_CONFIG_SINGLE_SECONDARY	=	0x3	// Single receiver operation ' enable secondary/MIMO receiver only (disable primary receiver)
} l4cel1_antenna_config_enum;

typedef enum
{
    ANTENNA_STATUS_NORMAL_DUAL		=	0x1,	// normal dual receiver operation (default UE behavior)
    ANTENNA_STATUS_SINGLE_PRIMARY	=	0x2,	// Single receiver operation ' enable primary receiver only (disable secondary/MIMO receiver)
    ANTENNA_STATUS_SINGLE_SECONDARY	=	0x3	// Single receiver operation ' enable secondary/MIMO receiver only (disable primary receiver)
} l4cel1_antenna_status_enum;



/* For DHLL4C_EM_UPDATE_REQ */
typedef struct
{
   LOCAL_PARA_HDR
   em_info_status_enum  info_request[NUM_OF_EM_INFO];
} dhll4c_em_update_req_struct;

/* EL1 */
#define RPT_LTE_RX_CC_MAX   2
#define RPT_LTE_TX_CC_MAX   1
/* EL1 MDMI */
#define LTE_MAX_DATA_BUF   30
#define EL1_INVALID_8       0x7F
#define EL1_INVALID_16      0x7FFF
#define EL1_INVALID_32      0x7FFFFFFF
#define EL1_INVALID_U8      0xFF
#define EL1_INVALID_U16     0xFFFF
#define EL1_INVALID_U32     0xFFFFFFFF

typedef struct
{
    /* PWR info */
    kal_int16  prach_tx_power_ave;
    kal_int16  pucch_tx_power_ave;
    kal_int16  pusch_tx_power_ave;
    kal_int16  srs_tx_power_ave;

    /* Tx report */
    kal_int16  tm;
    kal_int16  phr;
    kal_int16  ta;

    /* UL info */
    kal_uint32 UL_Tput;
    kal_int16  UL_Imcs;
    kal_int16  UL_rb;
    kal_int16  UL_block;
    kal_int16  UL_bler;

   /* TAS info */
   kal_int16   tx_ant;

   /* UL info */
   kal_int8    UL_Mod;

   /*RJIL requirement*/
   kal_uint8   srs_bw_ave;
   kal_int16   pucch_tx_power_ave_fmt[9]; //0:FMT1 1:FMT1A 2:FMT1B 3:FMT2 4:FMT2_extCP 5:FMT2A 6:FMT2B 7:FMT3 8:FMT1B CS
   kal_int16   pusch_adj;
   kal_int16   pucch_adj;

   /*CMCC HPUE requirement*/
   kal_uint16  UL_retx_rate;
   kal_int16   total_tx_power_ave;
   kal_int16   pcmax;
} em_el1_ul_status_struct;

typedef struct
{
    /* DL Qual indicator */
    kal_int16  dl_rssi[2]; // -255: disable, -140 ~ 18 (dBm)
    kal_int16  dl_rsrp[2]; // -255: disable, -140 ~ 18 (dBm)
    kal_int16  dl_rsrq[2]; //
    kal_int16  dl_sinr[2];
    kal_int16  rsrp;
    kal_int16  rsrq;
    kal_int16  rssi;
    kal_int16  sinr;
    kal_int16  rsSNR;

    /* Rx report */
    kal_int16  tm;
    kal_int16  cqi_cw0;
    kal_int16  cqi_cw1;
    kal_int16  ri;

    /* DL info */
    kal_uint32 DL_Tput;
    kal_uint32 DL_Tput_cw0;
    kal_uint32 DL_Tput_cw1;
    kal_int16  DL_Imcs;
    kal_int16  DL_rb;
    kal_int16  DL_block;
    kal_int16  DL_bler;
    kal_int8   DL_Mod0;
    kal_int8   DL_Mod1;


    /* MCH info */
    kal_uint32 MCH_Tput;
    kal_int16  MCH_block;
    kal_int16  MCH_bler;

    kal_int16  DL_bler_harq[15];
    kal_int16  MCH_sf_skip_cnt;
    kal_int8   DL_TB;

} em_el1_dl_status_struct;

typedef struct
{
    /* cell info */
    kal_uint8  band;
    kal_uint8  ant_port;
    kal_uint8  dl_bw;       // 100kHz
    kal_uint8  ul_bw;       // 100kHz
    kal_uint8  tdd_cfg;     // TDD: 0~6, FDD: 0xFF
    kal_uint8  sp_cfg;      // TDD: 0~9, FDD: 0xFF
    kal_uint8  tm;          // 0,1~9
    kal_int8   ul_cc_idx;   //-1,0~(ul_cc_max-1)
    kal_int16  pci;         // 0~503
    EARFCN     earfcn;
    kal_uint16 dlFreq;      // 100kHz
    kal_uint16 ulFreq;      // 100kHz
    kal_uint8  sr_period;   //ms
	kal_uint8  ue_category;
	kal_uint8  enable_64qam;

} em_el1_cell_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum            em_info;

    em_el1_cell_info_struct cell_info[RPT_LTE_RX_CC_MAX];
    em_el1_dl_status_struct dl_info[RPT_LTE_RX_CC_MAX];  
    em_el1_ul_status_struct ul_info[RPT_LTE_TX_CC_MAX];

} em_el1_status_ind_struct;

typedef enum
{
    EM_DL_QPSK                  = 0,
    EM_DL_QAM16                 = 1,
    EM_DL_QAM64                 = 2,
    EM_DL_QAM256                = 3,
    EM_DL_INVALID               = 255
} em_dl_mod_enum;

typedef enum
{
    EM_CRC_FAIL                 = 0,
    EM_CRC_PASS                 = 1
} em_dl_crc_enum;

typedef enum
{
    EM_RNTI_NONE                = 0,
    EM_C_RNTI                   = 1,
    EM_SPSC_RNTI                = 2,
    EM_P_RNTI                   = 3,
    EM_RA_RNTI                  = 4,
    EM_TC_RNTI                  = 5,
    EM_SI_RNTI                  = 6,
    EM_TPC_PUSCH_RNTI           = 7,
    EM_TPC_PUCCH_RNTI           = 8,
    EM_M_RNTI                   = 9,
    EM_RNTI_INVALID             = 255
} em_dl_rnti_enum;

typedef enum
{
    EM_cRNTI                    = 0,
    EM_spscRNTI                 = 1,
    EM_pRNTI                    = 2,
    EM_raRNTI                   = 3,
    EM_tcRNTI                   = 4,
    EM_siRNTI                   = 5,
    EM_tpcPuschRNTI             = 6,
    EM_tpcPucchRNTI             = 7,
    EM_mbmsRNTI                 = 8,
    EM_invalidRNTI              = 255
} em_emac_rnti_enum;

typedef enum
{
    EM_FDD                      = 0,
    EM_TDD                      = 1
} em_duplex_enum;

typedef enum
{
    EM_COMMON_SPACE             = 0,
    EM_UE_SPECIFIC_SPACE        = 1
} em_dci_srch_space;

typedef enum
{
    EM_PCC                      = 0,
    EM_SCC1                     = 1,
    EM_SCC2                     = 2
} em_carrier_idx_enum;

typedef enum
{
    EM_Bandwidth_1_4            = 1,
    EM_Bandwidth_3              = 2,
    EM_Bandwidth_5              = 3,
    EM_Bandwidth_10             = 4,
    EM_Bandwidth_15             = 5,
    EM_Bandwidth_20             = 6
} em_BandWidth_enum;

typedef enum
{
    EM_CCE_AGG_LV1              = 0,
    EM_CCE_AGG_LV2              = 1,
    EM_CCE_AGG_LV4              = 2,
    EM_CCE_AGG_LV8              = 3
} em_cce_agg_lv_enum;

typedef enum
{
    EM_PDCCH_FMT0               = 0,
    EM_PDCCH_FMT1               = 1,
    EM_PDCCH_FMT1A              = 2,
    EM_PDCCH_FMT1B              = 3,
    EM_PDCCH_FMT1C              = 4,
    EM_PDCCH_FMT1D              = 5,
    EM_PDCCH_FMT2               = 6,
    EM_PDCCH_FMT2A              = 7,
    EM_PDCCH_FMT2B              = 8,
    EM_PDCCH_FMT2C              = 9,
    EM_PDCCH_FMT2D              = 10,
    EM_PDCCH_FMT3               = 11,
    EM_PDCCH_FMT3A              = 12,
    EM_PDCCH_FMT4               = 13,
    EM_PDCCH_INVALID            = 255
} em_pdcch_fmt_enum;

typedef enum
{
    EM_PHICH_NACK               = 0,
    EM_PHICH_ACK                = 1
} em_phich_val_enum;

typedef enum
{
    EM_PUCCH_FMT1               = 0,
    EM_PUCCH_FMT1A              = 1,
    EM_PUCCH_FMT1B              = 2,
    EM_PUCCH_FMT2               = 3,
    EM_PUCCH_FMT2A              = 4,
    EM_PUCCH_FMT2B              = 5
} em_pucch_fmt_enum;

typedef enum
{
    EM_DL_TM_MODE_DISABLED      = 0,
    EM_DL_TM_MODE_1             = 1,
    EM_DL_TM_MODE_2             = 2,
    EM_DL_TM_MODE_3             = 3,
    EM_DL_TM_MODE_4             = 4,
    EM_DL_TM_MODE_5             = 5,
    EM_DL_TM_MODE_6             = 6,
    EM_DL_TM_MODE_7             = 7,
    EM_DL_TM_MODE_8             = 8,
    EM_DL_TM_MODE_9             = 9,
    EM_DL_TM_MODE_10            = 10,
    EM_DL_TM_MODE_INVALID       = 255
} em_dl_tm_mode_enum;

typedef enum
{
    EM_mode10                   = 0,
    EM_mode11                   = 1,
    EM_mode20                   = 2,
    EM_mode21                   = 3
} em_pucch_rpt_mode_enum;

typedef enum
{
    EM_subBandCqiFeedback       = 0,
    EM_wideBandCqiPmiFeedback   = 1,
    EM_riFeedback               = 2,
    EM_widebandCqiFeedback      = 3
} em_pucch_rpt_type_enum;

typedef enum
{
    EM_UL_BPSK                  = 0,
    EM_UL_QPSK                  = 1,
    EM_UL_QAM16                 = 2,
    EM_UL_QAM64                 = 3
} em_pusch_mcs_enum;

typedef enum
{
    EM_FREQ_HOP_DISABLED        = 0,
    EM_FREQ_HOP_INTER_SF        = 1,
    EM_FREQ_HOP_INTRA_INTER_SF  = 2,
    EM_FREQ_HOP_INVALID         = 255
} em_pusch_freq_hop_enum;

typedef enum
{
    EM_semiPersistent           = 0,
    EM_dynamic                  = 1,
    EM_rachMsg3                 = 2
} em_pusch_type_enum;

typedef enum
{
    EM_modeAperiodicRm12        = 0,
    EM_modeAperiodicRm20        = 1,
    EM_modeAperiodicRm22        = 2,
    EM_modeAperiodicRm30        = 3,
    EM_modeAperiodicRm31        = 4
} em_pusch_rpt_mode_enum;

typedef enum
{
    EM_NoSrs                    = 0,
    EM_UpPtsSymbol0             = 1,
    EM_UpPtsSymbol1             = 2,
    EM_BothUpPtsSymbols         = 3
} em_srs_uppts_enum;

typedef enum
{
    EM_SRS_Type0                = 0,
    EM_SRS_Type1Dci0            = 1,
    EM_SRS_Type1Dci1A2B2C       = 2,
    EM_SRS_Type1Dci4            = 3
} em_srs_trig_enum;

typedef enum
{
    EM_CYCLE_320                = 0,
    EM_CYCLE_640                = 1,
    EM_CYCLE_1280               = 2,
    EM_CYCLE_2560               = 3
} em_paging_cyc_enum;

typedef enum
{
    EM_fourT                    = 0,
    EM_twoT                     = 1,
    EM_oneT                     = 2,
    EM_one2T                    = 3,
    EM_one4T                    = 4,
    EM_one8T                    = 5,
    EM_one16T                   = 6,
    EM_one32T                   = 7
} em_drx_nb_enum;

typedef enum
{
    EM_T310_STOP                = 0,
    EM_T310_START               = 1,
    EM_T310_EXPIRE              = 2,
    EM_T310_INVALID             = 255
} em_t310_status_enum;

typedef enum
{
    EM_CSFB_NONE    = 0,
    EM_CSFB_START   = 1,
    EM_CSFB_SUCCESS = 2,
    EM_CSFB_FAIL    = 3
} em_csfb_status_enum;

typedef struct
{
    kal_bool                        tbEn;
    kal_uint8                       Imcs;
    em_dl_mod_enum                  mcs;
    kal_uint8                       rv;
    kal_uint8                       ndi;
    kal_uint8                       tbIndex;
    kal_uint32                      tbsize;
    kal_uint8                       dupPacket;
    kal_bool                        harqComb;
    //pdsch 3
    em_dl_crc_enum                  tbCrc;
    kal_uint16                      cbCrc;
    kal_uint8                       cw_idx;
    kal_uint8                       reRxNum;                        // 1~8
    kal_uint16                      cbSizePlus;                     // 0~6168
    kal_uint8                       numCbPlus;                      // 0~13
    kal_uint8                       turboDecMaxIterNum;
    kal_uint8                       turboDecIterNum;
    kal_bool                        earlyEndAlgm;
} em_PdschTb_struct;

typedef struct
{
    kal_uint8                       numRBs;//pdsch 1,2
    kal_uint8                       numLayers;//pdsch 2
    kal_uint8                       numTBs;//pdsch 2
    kal_uint8                       harqId;//pdsch 1,3
    em_dl_rnti_enum                 rntiType;
    kal_uint16                      rntiValue;
    em_PdschTb_struct               PdschTb[2];
} em_PdschRlt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;

    kal_uint8                       cc_idx;//pdsch 3
    kal_uint8                       ueCat;//pdsch 3
    kal_uint8                       tranMode;//pdsch 3
    
    kal_uint8                       mimoRi;                     // num of tb
    kal_uint8                       pmchId;                     // 0~255
    kal_uint8                       areaId;                     // 0~255    
    em_PdschRlt_struct              PdschRlt[5];
} el1_em_PdschRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    kal_uint8                       cc_idx;
    kal_uint8                       ulDlCfg;                        // 0~6:TDD
    //ltePhyPdcch 1
    em_dl_rnti_enum                 rntiType[9];
    em_cce_agg_lv_enum              cceAggLv[9];
    kal_bool                        newDl[9];
    em_dci_srch_space               srchSpace[9];                   // 0: common, 1: ue-specific
    kal_uint16                      payloadSize[9];                 // pi/si/ra/c,tc,sps
    kal_uint8                       spsType;                        // 1:rel, 2:acv, 3:cfg, 4:retx
    //ltePhyPdcch 2
    kal_uint8                       numDlTbs[9];                    // 0~3, number of DL TBs
    //ltePhyPdcch 3
    em_pdcch_fmt_enum               dciFormat[9];
    kal_uint8                       strtCce[9];                        // 0~86
    kal_bool                        dciStatus[9];
} el1_em_PdcchRpt_struct;

typedef struct
{
    //ltePhyPhich 1, 3
    kal_bool                        phichEn;
    em_phich_val_enum               phichRlt;
    //ltePhyPhich 3
    kal_uint8                       spreadCode;                     // 0~7
    kal_uint8                       groupNum;                       // 0~31
} em_PhichRlt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    em_carrier_idx_enum             cc_idx;
    kal_uint8                       ulDlCfg;                        //0~6:TDD
    em_PhichRlt_struct              phichRlt0;
    em_PhichRlt_struct              phichRlt1;
} el1_em_PhichRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    em_pdcch_fmt_enum               dciFormat[9];
    em_pucch_fmt_enum               txFormat;
    kal_uint8                       numAck;                         //0~2, number of Harq bits    
    kal_bool                        csiEn[RPT_LTE_RX_CC_MAX];
    kal_uint8                       numCqi[RPT_LTE_RX_CC_MAX];
    kal_int8                        pucchTpc[9];
    kal_int16                       gi;
    kal_uint8                       digitalGain;                    //0~255, PUCCH digital amplitude gain in dB
    kal_int8                        txPower;
    kal_int8                        ActualTxPower;
    kal_uint8                       pathLoss;
    kal_uint8                       startRbSlot0;                   //0~110
    kal_uint8                       startRbSlot1;                   //0~110
    kal_uint8                       dmrsSeqSlot0;                   //0~29
    kal_uint8                       dmrsSeqSlot1;                   //0~29
} em_el1_PucchRpt_struct;

typedef struct
{
    kal_bool                        csiEn;
    kal_uint8                       cc_idx;
    em_dl_tm_mode_enum              csiTxMode;
    em_pucch_rpt_mode_enum          csiRptMode;
    em_pucch_rpt_type_enum          csiRptType;
    kal_uint8                       bpSize;                         //0~4
    kal_uint8                       bpIndex;                        //0~4
    kal_uint8                       sbNum;
    kal_uint8                       ri;
    kal_uint8                       cqiCw0;
    kal_uint8                       cqiCw1;
    kal_uint8                       wbPmi;
} em_pucchCsiRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;

    em_pucchCsiRpt_struct           csiRpt[RPT_LTE_RX_CC_MAX];
} em_el1_PucchCsiRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    em_pdcch_fmt_enum               dciFormat;                      // DCI format of the decoded PDCCH
    kal_int8                        puschTpc;
    em_pusch_type_enum              puschType;
    kal_int16                       fi;
    kal_uint8                       digitalGain;                    //0~255, PUSCH digital amplitude gain in dB
    kal_int8                        txPower;
    kal_int8                        ActualTxPower;
    kal_uint8                       pathLoss;
    kal_uint8                       rbNum;
    em_pusch_mcs_enum               ModOrd;
    kal_uint8                       harqId;
    kal_uint16                      tbSize;
    kal_uint8                       retxIndex;                      //1~8, HARQ retransmission number 
    em_pusch_freq_hop_enum          freqHop;
    kal_uint8                       numAck;                         //0~7, length of ACK NACK bit
    kal_bool                        csiEn[RPT_LTE_RX_CC_MAX];
    kal_uint8                       numCqi[RPT_LTE_RX_CC_MAX];      //0~66, length of CQI bit
    kal_uint8                       numRi[RPT_LTE_RX_CC_MAX];       //0~3, length of RI bit
    kal_uint8                       startRbSlot0;                   //0~110
    kal_uint8                       startRbSlot1;                   //0~110
    kal_uint8                       dmrsSeqSlot0;                   //0~29
    kal_uint8                       dmrsSeqSlot1;                   //0~29
} em_el1_PuschRpt_struct;

typedef struct
{
    kal_bool                        csiEn;
    kal_uint8                       cc_idx;
    em_dl_tm_mode_enum              csiTxMode;
    em_pusch_rpt_mode_enum          csiRptMode;
    kal_uint8                       sbNum;
    kal_uint8                       ri;
    kal_uint8                       wbCqiCw0;
    kal_uint8                       wbCqiCw1;
    kal_uint8                       sizeM;
    kal_uint8                       snglWbPmi;
    kal_uint8                       snglMbPmi;
    kal_uint8                       sbCqiCw0[13];
    kal_uint8                       sbCqiCw1[13];
    kal_uint8                       mSbCqiCw0;
    kal_uint8                       mSbCqiCw1;
    kal_uint8                       sbSize;
} em_puschCsiRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;

    em_puschCsiRpt_struct           csiRpt[RPT_LTE_RX_CC_MAX];
} em_el1_PuschCsiRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    em_carrier_idx_enum             cc_idx;
    kal_uint8                       cfi;
} em_el1_PcfichRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    em_carrier_idx_enum             cc_idx;
    kal_uint8                       pmchId;
    kal_uint8                       areaId;
    kal_uint8                       numRBs;
    kal_uint8                       numLayers;
    kal_uint8                       harqId;
    kal_uint8                       rv;
    kal_uint8                       ndi;
    em_dl_crc_enum                  crcRlt;
    em_dl_rnti_enum                 rntiType;
    kal_uint8                       tbIndex;
    kal_uint16                      tbSize;                         // bytes
    kal_uint8                       Imcs;                           // 0~31
} em_el1_PmchRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    kal_int16                       rsrp;                           // -180~-30
    kal_int16                       rsrp0;
    kal_int16                       rsrp1;
    kal_int16                       rsrq;                           //  -30~ 10
    kal_int16                       rsrq0;
    kal_int16                       rsrq1;
    kal_int16                       rssi;                           // -110~-10
    kal_int16                       rssi0;
    kal_int16                       rssi1;
    kal_int16                       sinr;                           //  -20~ 30
    kal_int16                       sinr0;
    kal_int16                       sinr1;
    kal_uint32                      earfcn;
    kal_uint8                       priority;                       // 0~7, The priority of the layer that the cell resides on
    kal_bool                        isIdleMode;
    em_BandWidth_enum               Bandwidth;
    em_carrier_idx_enum             CarrierType;
} em_el1_SrvMeasRpt_struct;

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

typedef struct
{
    kal_bool                        ueSrsEn;
    kal_bool                        cellSrsEn;
    kal_uint8                       strtRb;
    kal_uint8                       numRb;
    kal_uint16                      zcRoot;                         // 1~1151
    em_srs_uppts_enum               upPtsType;
    //em_srs_trig_enum                srsTrigType;
} em_srsTxParam_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    em_carrier_idx_enum             carrierType;
    em_duplex_enum                  duplexMode[RPT_LTE_RX_CC_MAX];
    //ltePhyMeasurements 15
    kal_int8                        srsTxPower;
    kal_int16                       fi;
    kal_uint8                       pathLoss;
    kal_uint8                       srsTxBw;
    kal_int8                        srsActualTxPower;
    //ltePhyMeasurements 16
    em_srs_trig_enum                srsTrigType;
    kal_uint8                       cycShift;
    kal_int8                        srsPwrOffst;                 // 0:p-srs,    1:a-srs
    em_srsTxParam_struct            srsTxParam[2];                  // 0:symbol 1, 1:symbol 2
} em_el1_SrsRpt_struct;

typedef struct
{
    kal_uint8                       mcsIndex;
    kal_uint8                       cqiRequest;
    kal_uint8                       startRB[2];
    kal_uint8                       numRB[2];
    kal_uint8                       tbSizeIndex;
    kal_uint8                       modType;
    kal_bool                        freqHop;                        // 0: disable, 1: enable
    kal_uint8                       ndi;
    kal_uint8                       rv;
    kal_int8                        tpcCmd;
    kal_uint8                       dmrsCycShift;
    kal_uint8                       timeToTx;
} ul_grant_struct;

typedef struct
{
    kal_uint16                      pci;
    em_pdcch_fmt_enum               dlAssgnFmt[7];
    kal_uint8                       numAck[7];                      // 0~2
    kal_int8                        tpcCmd[7];
} dl_assgn_struct;

typedef struct
{
    em_duplex_enum                  duplexMode[RPT_LTE_RX_CC_MAX];

    kal_uint16                      SFN;
    kal_uint8                       subframe;
    
    kal_bool                        pdcchOrderVld;

    kal_bool                        ulGrantVld;
    ul_grant_struct                 ulGrantInfo;

    kal_bool                        tpcVld;
    em_pdcch_fmt_enum               tpcFmt[2];                      // 0: tpc-pucch, 1: tpc-pusch

    kal_bool                        dlAssgnVld[2];                  // 2 cc
    dl_assgn_struct                 dlAssgnInfo[2];                 // c/tc/spsc -rnti
} em_el1_DciRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    //PSS result
    kal_uint16                      pssQualLev;
    kal_uint16                      pssPeakPos;                     // 0~10000
    kal_uint8                       pssIndex;                       // 0~2
    //SSS result
    kal_uint16                      pci;
    kal_uint16                      sssQualLev;
    kal_uint16                      sssFrameBoundary;
    kal_uint16                      sssCp;
} em_el1_CsrRpt_struct;

typedef struct
{
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint16                      pci;
    kal_uint32                      earfcn;
    kal_uint8                       dlBw;
    kal_uint16                      payloadSize;
    kal_uint16                      decSFN;
    em_dl_crc_enum                  crcRlt;
    kal_uint8                       numAnt;
    kal_uint8                       txAntCfg;
    kal_uint16                      sfnOffst;
    kal_uint16                      freqOffst;                      // TBD
    kal_uint16                      tx0Rx0Cir;                      // TBD
} em_el1_PbchRpt_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //lteMacKpis 7
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint8                       srPeriod;
} em_el1_status_sr_cfg_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPrach 1
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_int16                       rachTxPwr;
    kal_uint16                      zadOffSeq;                      //0~837, ZadOFF Sequence Number
    kal_uint8                       prachCfg;
    kal_uint8                       preambleFmt;
    em_duplex_enum                  duplexType;
    kal_uint8                       maxTxMsg3;
    kal_uint8                       rarWinSize;
    kal_bool                        rachRlt;
} em_el1_status_prach_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyMeasurements 5
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint32                      dlTputVal;
    kal_uint32                      dlTputCw0;
    kal_uint32                      dlTputCw1;
} em_el1_status_dl_tput_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyMeasurements 6
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint32                      ulTputVal;
} em_el1_status_ul_tput_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    el1_em_PdcchRpt_struct          PdcchRpt[LTE_MAX_DATA_BUF];
    kal_uint16                      PdcchRpt_num;
    kal_uint16                      Pdcch_num;
} em_el1_status_pdcch_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPdsch 1
    el1_em_PdschRpt_struct          PdschRpt[LTE_MAX_DATA_BUF];
    kal_uint16                      PdschRpt_num;
    kal_uint16                      Pdsch_num;
} em_el1_status_pdsch_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPhich 1,3
    el1_em_PhichRpt_struct          PhichRpt[LTE_MAX_DATA_BUF];
    kal_uint16                      PhichRpt_num;
} em_el1_status_phich_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyMeasurements 10, 11
    em_el1_CsrRpt_struct            CsrRlt[LTE_MAX_DATA_BUF];
    kal_uint8                       CsrRlt_num;
} em_el1_status_csr_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyMeasurements 1
    em_el1_SrvMeasRpt_struct        SrvMeasRpt[LTE_MAX_DATA_BUF];
    kal_int8                        SrvMeasRpt_num;
} em_el1_status_srv_meas_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPucch 1,3
    em_el1_PucchRpt_struct          PucchRpt[LTE_MAX_DATA_BUF];
    kal_uint8                       PucchRpt_num;
} em_el1_status_pucch_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPucch 4
    em_el1_PucchCsiRpt_struct       PucchCsiRpt[LTE_MAX_DATA_BUF];
    kal_uint8                       PucchCsiRpt_num;
} em_el1_status_pucch_csi_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPusch 1,3
    em_el1_PuschRpt_struct          PuschRpt[LTE_MAX_DATA_BUF];
    kal_uint8                       PuschRpt_num;
} em_el1_status_pusch_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPusch 4
    em_el1_PuschCsiRpt_struct       PuschCsiRpt[LTE_MAX_DATA_BUF];
    kal_uint8                       PuschCsiRpt_num;
} em_el1_status_pusch_csi_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyMeasurements 17
    em_el1_DciRpt_struct            DciRpt[LTE_MAX_DATA_BUF];
    kal_uint8                       DciRpt_num;
} em_el1_status_dci_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPmch 3
    em_el1_PmchRpt_struct           PmchRpt[LTE_MAX_DATA_BUF];
    kal_uint8                       PmchRpt_num;
} em_el1_status_pmch_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyMeasurements 15, 16
    em_el1_SrsRpt_struct            SrsRpt[LTE_MAX_DATA_BUF];
	kal_uint8                       SrsRpt_num;
} em_el1_status_srs_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyDebug 1
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_uint32                      strtDlFrmeTimeOffst;            // 0~307200, Ts units
    kal_uint32                      strtUlFrameTimeOffst;           // 0~307200, Ts units
    kal_uint32                      strtUlTimeAdv;                  // 0~307200, Ts units
    kal_int16                       dlFrameTimeChng;                // -512~511
    kal_int16                       ulFrameTimeChng;                //  -16~15
    kal_int8                        timeAdvChng;                    // -128~127
} em_el1_status_celltime_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyPcfich 3
    em_el1_PcfichRpt_struct         PcfichRpt[LTE_MAX_DATA_BUF];
    kal_uint8                       PcfichRpt_num;
} em_el1_status_pcfich_rpt_ind_struct;

typedef struct
{
    kal_uint8                       sequence;                       //    0~63, Preamble sequence index
    kal_int8                        prachTxPower;                   // -112~23, PRACH tx power
    kal_uint8                       duplexMode;
} el1_em_msg1_rpt_struct;

typedef struct
{
    kal_uint8                       mcs;
    kal_uint8                       modType;
    kal_uint8                       startRb;
    kal_uint8                       numRb;
    kal_uint8                       tbSizeIndex;
} el1_em_msg3_rpt_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    kal_uint16                      SFN;
    kal_uint8                       subframe;

    kal_bool                        msg1_valid;
    el1_em_msg1_rpt_struct          msg1_rpt;
    kal_bool                        msg3_valid;
    el1_em_msg3_rpt_struct          msg3_rpt;
} em_el1_status_rach_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    em_el1_PbchRpt_struct           PbchRpt[LTE_MAX_DATA_BUF];
    kal_uint8                       PbchRpt_num;
} em_el1_status_pbch_rpt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    kal_uint32                      earfcn;
    kal_uint16                      pci;
    em_paging_cyc_enum              pagCyc;
    em_drx_nb_enum                  nb;
    kal_uint16                      ueId;                           // IMSI mod 1024
    kal_uint8                       drxFrameNumOffst;
    kal_uint8                       drxSubframeNum;
} em_el1_status_pch_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyMeasurements 7
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_int16                       ta_value;
} em_el1_status_ta_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    mdmi_info;

    //ltePhyMeasurements 8
    kal_uint16                      SFN;
    kal_uint8                       subframe;
    kal_int8                        phr_value;                      // -23~40
} em_el1_status_phr_ind_struct;

// CIQ
typedef struct
{
    kal_bool                        wb_rpt_valid;
    kal_uint8                       sb_rpt_num;
    kal_uint16                      wb_cqi_dist[16];
    kal_uint16                      sb_cqi_dist[4][16];
    kal_uint16                      ri_dist[5];
    kal_uint16                      pmi_dist[16];
} el1_em_csi_rpt_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    ciq_info;
    kal_uint32                      trig_time;
    //LT13 - E-UTRA Radio Link Sync Status
    //RLF info
    em_t310_status_enum             t310_status;
} em_el1_ciq_rlf_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                    ciq_info;
    kal_uint32                      trig_time;
    //LT12 - E-UTRA PUSCH Transmission Status
    //PUSCH Power info
    kal_int16                       total_pwr;
    kal_int16                       perRB_pwr;
    kal_uint16                      count_pwr;
    //CSI info
    el1_em_csi_rpt_struct           csi_rpt;
} em_el1_ciq_pusch_ind_struct;

/* EL2 public EM info */
typedef struct
{
    kal_uint8 srb_num;
    kal_uint8 drb_num;
} em_el2_pub_info_t;

#define EMAC_NUM_SYNC_AREA      2
#define EMAC_MAX_MTCH_LCID_NB   29
#define EMAC_NUM_REPORT_EM      20

typedef struct mtch_info_t
{
    kal_uint32  mtch_rx_bytes;   // received MTCH data size
    kal_uint32  TMGI[6];         // TMGI info. to identify MBMS session
    kal_uint8   lcid;            //MTCH-ID
}em_mtch_info_t;

typedef struct
{
    kal_uint8   mbsfn_area_id;
    kal_uint8   pmch_id;
    kal_uint8   crc_total_count; // used to calculate BLER
    kal_uint8   crc_fail_count;  // used to calculate BLER
    kal_uint8   num_of_mtch;        //the number of mtch info. per report
    em_mtch_info_t  mtch_info[EMAC_MAX_MTCH_LCID_NB];  // 29 means MTCH max. size (NOTE: If you modifiy this macro, need to modify emac_strcut.h file's macro)
}em_pmch_info_t;


typedef struct
{
    kal_uint16  system_fn;
    kal_uint8   sub_fn;
    em_pmch_info_t pmch_info[EMAC_NUM_SYNC_AREA];    // NOTE: If you modifiy this macro, need to modify emac_strcut.h file's macro
}em_pmchs_info_t;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 report_num;           // total report size
    em_pmchs_info_t pmchs[EMAC_NUM_REPORT_EM];   // the array size 20 means max. report size (NOTE: If you modifiy this macro, need to modify emac_strcut.h file's macro)
}em_emac_embms_report_ind_struct;

extern em_emac_embms_report_ind_struct embms_status_20_records_g;

typedef struct
{
    kal_uint32 emac_tx_bits;
    kal_uint32 emac_rx_bits;
} em_emac_pub_tput_info_struct;

typedef enum
{
    ERLC_RLC_MODE_TM    = 0,
    ERLC_RLC_MODE_UM    = 1,
    ERLC_RLC_MODE_AM    = 2
} erlc_rlc_mode_enum;

/* ERLC-DL RB cfg, refresh per RB life cycle */
typedef struct
{
    kal_bool    valid;    
    /* Configurations */
    kal_uint8   rb_id;      // 1...32
    kal_uint8   epsb_id;    // 0,5...15
    kal_uint8   lgch_id;    // 3...10
    kal_uint8   cfg_idx;    // (0...34)0~31:DRB1~DRB32, 32:SRB0, 33:SRB1, 34:SRB2
    erlc_rlc_mode_enum  rlc_mode;   // 0: TM, 1: UM, 2: AM
    
    /* RB control */
    kal_uint32  est_cntr;       // establish
    kal_uint32  rel_cntr;       // release
    kal_uint32  reest_wo_recfg_cntr;  // re-establish w/o reconfig
    kal_uint32  reest_wi_recfg_cntr;  // re-establish w/ reconfig
    kal_uint32  recfg_cntr;         // reconfig
    
} erlcdl_rb_pub_stats_cfg;

/* ERLC-DL MCCH,MRB cfg, refresh per RB life cycle */
typedef struct
{
    kal_bool    valid;
    /* Configuration */    
    kal_uint8   mbsfn_area_id;
    kal_uint8   pmch_id;
    kal_uint8   lgch_id;    // 3...10
    kal_uint16  session_id;

} erlcdl_mrb_pub_stats_cfg;
 
/* ERLC-DL RB statistics since the last RLC re-establishment */
typedef struct
{
    kal_uint32  rx_data_pdu_cntr_rst;   // Total number of RLC Data PDUs received since the last RLC re-establishment
    kal_uint32  rx_data_pdu_bytes_rst;   // Total number of RLC Data PDU received in bytes since the last RLC re-establishment
    kal_uint32  rx_stus_pdu_cntr_rst;   // Total number of RLC Control PDUs received since the last RLC re-establishment
    kal_uint32  rx_stus_pdu_bytes_rst;   // Total number of RLC Control PDU received in bytes since the last RLC re-establishment
    kal_uint32  rx_valid_stus_cntr_rst;   // Total number of RLC status PDU received and forwarded to uplink since the last RLC re-establishment
    kal_uint32  rx_valid_stus_bytes_rst;   // Total number of RLC status PDU received and forwarded to uplink in bytes since the last RLC re-establishment
    kal_uint32  invalid_pdu_cntr_rst;   // Total number of RLC PDUs invalid since the last RLC re-establishment
    kal_uint32  invalid_pdu_bytes_rst;   // Total number of RLC PDUs invalid in bytes since the last RLC re-establishment
    kal_uint32  dropped_pdu_cntr_rst;   // Total number of PDUs dropped excluding duplicated since the last RLC re-establishment
    kal_uint32  dropped_pdu_bytes_rst;   // Total number of PDUs dropped in bytes excluding duplicated since the last RLC re-establishment
    kal_uint32  rx_retx_cntr_rst;   // Total number of RLC PDUs retransmitted from receiver perspective since the last RLC re-establishment
    kal_uint32  rx_retx_bytes_rst;   // Total number of RLC PDUs retransmitted in bytes from receiver perspective since the last RLC re-establishment
    kal_uint32  dup_pdu_cntr_rst;   // Total number of RLC PDUs duplicated since the last RLC re-establishment
    kal_uint32  dup_pdu_bytes_rst;   // Total number of RLC PDUs duplicated in bytes since the last RLC re-establishment
    kal_uint32  missed_um_pdu_cntr_rst;   // Total number of UM PDUs missing on DL since the last RLC re-establishment
    kal_uint32  reest_ooo_sdu_cntr_rst;   // Total number of out of order SDUs forwarded to PDCP during RLC reestablishment since the last RLC re-establishment
    kal_uint32  dropped_pdu_flc_cntr_rst;  // Total number of PDUs dropped because of flow control since the last RLC re-establishment(in eRLC current design value will always be zero)
    kal_uint32  dropped_pdu_flc_bytes_rst;  // Total number of PDUs dropped in bytes because of flow control since the last RLC re-establishment(in eRLC current design value will always be zero)
    kal_uint32  reasm_sdu_cntr_rst;
    kal_uint32  reasm_sdu_bytes_rst;
    kal_uint32  reorder_tmr_expry_cntr_rst;
    kal_uint32  reorder_tmr_start_cntr_rst;
    kal_uint32  rx_stus_nack_pdu_cntr_rst;   // Total number of Complete RLC PDU NACKs received since last RLC re-establishemnet
    kal_uint32  rx_stus_nack_seg_cntr_rst;   // Total number of NACKs for RLC Segments received since last RLC re-establishemnet

} erlcdl_rb_pub_stats_rst;

/* ERLC-DL RB statistics, refresh per statistic cycle */
typedef struct
{  
    /* PDU */
    kal_uint32  rcv_blks;        // total rcv. pdu and segment 
    kal_uint32  rx_pdu_cntr;    // total received PDU
    kal_uint32  rx_data_pdu_cntr;   // Total number of RLC Data PDUs received
    kal_uint32  rx_stus_pdu_cntr;   // Total number of RLC Control PDUs received
    kal_uint32  rx_stus_nack_pdu_cntr;   // Total number of Complete RLC PDU NACKs received
    kal_uint32  rx_stus_nack_seg_cntr;   // Total number of NACKs for RLC Segments received
    kal_uint32  rx_valid_stus_cntr;   // Total number of RLC status PDU received and forwarded to uplink
    kal_uint32  dup_pdu_cntr;   // duplicated PDU and segment
    kal_uint32  invalid_pdu_cntr;   // invalid PDU and segment
    kal_uint32  dropped_pdu_cntr;   // Total number of PDUs dropped excluding duplicated
    kal_uint32  rx_retx_cntr;   // Total number of RLC PDUs retransmitted from receiver perspective (vr_r < sn <= vr_ms)
    kal_uint32  oow_pdu_cntr;   // out-of-window PDU and segment
    kal_uint32  rx_seg_cntr;    // total received segment
    kal_uint32  missed_um_pdu_cntr;   // Total number of UM PDUs missing on DL
    kal_uint32  reest_ooo_sdu_cntr;    // Total number of out of order SDUs forwarded to PDCP during RLC reestablishment
    kal_uint32  dropped_pdu_flc_cntr;    // Total number of PDUs dropped because of flow control (in eRLC current design value will always be zero)
    kal_uint32  rcv_bits;       // total bits of blks

    kal_uint32  rx_data_pdu_bytes;  //Total number of Data PDU received in bytes
    kal_uint32  rx_stus_pdu_bytes;  //Total number of Control PDU received in bytes
    kal_uint32  rx_valid_stus_bytes;// Total number of RLC status PDU received and forwarded to uplink in bytes
    kal_uint32  invalid_pdu_bytes;  //Total number of PDUs invalid in bytes
    kal_uint32  dropped_pdu_bytes;  // Total number of PDUs dropped in bytes excluding duplicated
    kal_uint32  rx_retx_bytes;      // Total number of PDUs retransmitted in bytes from receiver perspective (vr_r < sn <= vr_ms)
    kal_uint32  dup_pdu_bytes;      //Total number of PDUs duplicated in bytes
    kal_uint32  oow_pdu_bytes;      //Total number of PDUs OOW in bytes
    kal_uint32  dropped_pdu_flc_bytes;    // Total number of PDUs dropped in bytes because of flow control (in eRLC current design value will always be zero)
        
    /* state variable */
    kal_uint16  max_pdu_num_in_win;   // max. vr_h - vr_r (vr_uh - vr_ur) when t-reordering expry
    kal_uint16  sum_pdu_num_in_win;   // for avg. vr_h - vr_r (vr_uh - vr_ur) calculation when t-reordering expry
       
    /* timeout */
    kal_uint32  reorder_tmr_expry_cntr;     // num. of t-reordering expry
    kal_uint32  reorder_tmr_start_cntr;
       
    /* reassemble */
    kal_uint32  reasm_sdu_cntr;     // num. of reassemble SDU
    kal_uint32  reasm_sdu_bytes;    // bytes of reassemble

    erlcdl_rb_pub_stats_rst  rb_stat_rst;   // ERLC-DL RB statistics since the last RLC re-establishment

} erlcdl_rb_pub_stats;

/* ERLC-UL RB cfg, refresh per RB life cycle */
typedef struct
{
    kal_bool    valid;
    /* Configuration */
    kal_uint8   rb_id;      // 1...32
    kal_uint8   epsb_id;    // 0,5...15
    kal_uint8   lgch_id;    // 3...10
    kal_uint8   cfg_idx;    // (0...34)0~31:DRB1~DRB32, 32:SRB0, 33:SRB1, 34:SRB2
    erlc_rlc_mode_enum  rlc_mode;   // 0: TM, 1: UM, 2: AM
    
    /* RB control */
    kal_uint8  est_cntr;       // establish
    kal_uint8  rel_cntr;       // release
    kal_uint8  reest_wo_recfg_cntr;  // re-establish w/o reconfig
    kal_uint8  reest_wi_recfg_cntr;  // re-establish w/ reconfig
    kal_uint8  recfg_cntr;         // reconfig
     
} erlcul_rb_pub_stats_cfg;
  
/* ERLC-UL RB statistics since the last RLC re-establishment */
typedef struct
{
    kal_uint32  newtx_pdu_cntr_rst;   // Total number of New Data PDU transmitted since last RLC re-establishemnet
    kal_uint32  newtx_pdu_bytes_rst;   // Total number of New Data PDU transmitted in bytes including RLC headers since last RLC re-establishemnet
    kal_uint32  sdu_cntr_rst;   // Total number of RLC SDUs transmitted since last RLC re-establishemnet
    kal_uint32  sdu_bytes_rst;   // Total number of RLC SDU in bytes transmitted since last RLC re-establishemnet
    kal_uint32  stus_pdu_cntr_rst;   // Total number of RLC control PDU transmitted since last RLC re-establishemnet
    kal_uint32  stus_pdu_bytes_rst;   // Total number of RLC Control PDU transmitted in bytes since last RLC re-establishemnet
    kal_uint32  retx_pdu_cntr_rst;   // Total number of RLC PDUs retransmitted since last RLC re-establishemnet
    kal_uint32  retx_bits_rst;   // Total number of RLC PDUs retransmitted in bytes since last RLC re-establishemnet
    kal_uint32  stus_tx_nack_pdu_cntr_rst;   // Total number of complete RLC PDU NACKs sent since the last RLC re-establishment
    kal_uint32  stus_tx_nack_seg_cntr_rst;   // Total number of RLC segments NACk sent since the last RLC re-establishment
    kal_uint32  poll_cntr_rst;
    kal_uint32  poll_retx_cntr_rst;
    
} erlcul_rb_pub_stats_rst;

/* ERLC-UL RB statistics, refresh per statistic cycle */
typedef struct
{   
    /* SDU statistics */
    kal_uint32  sdu_cntr;           // num. of transmitted SDU
    
    /* PDU statistics */
    kal_uint32  newtx_pdu_cntr;     // Total number of New Data PDU transmitted
    kal_uint32  retx_pdu_cntr;      // reTX AMD PDU
    kal_uint32  retx_seg_cntr;      // reTX AMD PDU segment
    kal_uint32  tx_bits;            // total tx bits
    kal_uint32  retx_bits;          // total retx bits

    kal_uint32  newtx_pdu_bytes;    //Total number of New Data PDU transmitted in bytes including RLC headers
    kal_uint32  stus_pdu_bytes;     //Total number of RLC Control PDU transmitted in bytes
    kal_uint32  sdu_bytes;          // Total number of RLC SDU in bytes transmitted
    
    /* ARQ */
    kal_uint32  max_retx_pdu_cntr;  // in AM mode and maximum number of retransmissions for a particular RLC PDU has reached
    kal_uint16  poll_cntr;          // poll number
    kal_uint16  stus_pdu_cntr;      // tx status pdu
    kal_uint32  stus_tx_nack_pdu_cntr; //Total number of complete RLC PDU NACKs sent
    kal_uint32  stus_tx_nack_seg_cntr; //Total number of RLC segments NACk sent
    kal_uint16  req_retx_pdu_cntr;  // num. of RLC PDUs requested for retransmission
    kal_uint8   max_pdu_retx_cntr;  // max. retx number of a pdu
    kal_uint32  nack_pdu_seg_cntr;  // for avg. nacked pdu + seg number per status pdu
        
    /* state variable */
    kal_uint16  max_unack_num;   // max. vt_s - vt_a when rcv. a status pdu
    kal_uint16  sum_unack_num;   // for avg. vt_s - vt_a calcuated when rcv. a status pdu
    
    /* timeout */
    kal_uint16  poll_retx_cntr;     // timeout of poll retx 
 
    erlcul_rb_pub_stats_rst  rb_stats_rst;   // ERLC-UL RB statistics since the last RLC re-establishment

} erlcul_rb_pub_stats;

/* ERLC-UL statistics, refresh per statistic cycle */
typedef struct
{ 
    kal_uint32  grant_cntr;    // ther num. of UL grant count (notified by EMAC)
    kal_uint32  padding_cntr;  // ther num. of padding count after scheduling
    kal_uint32  grant_bits;    // total UL grant bits (notified by EMAC)
    kal_uint32  padding_bits;  // total padding bits after shceduling
} erlcul_comp_pub_stats;

/* ERLC-DL statistics, refresh per statistic cycle */
typedef struct
{
    kal_uint32  rcv_bad_blks;   // total received CRC failed, no RB mapping blocks   
    kal_uint32  rcv_bad_mbms_blks;   // total received CRC failed, no RB mapping blocks   
} erlcdl_comp_pub_stats;

#define EM_MAX_RLC_HDR_CP_LEN   (16)
#define EM_MAX_RLC_PDU_LOG_LEN  (256)
#define EM_RLC_PDU_DATA         (0)    //value defined by VzW
#define EM_RLC_UM_DATA_PDU_LOG  (0x40) //value defined by VzW, Bit 0 is LSB, Bit:6(RLCUL UM data PDU log)


/*VzW EM ERLC OTA-message, ERLC header print*/
typedef struct
{
    kal_uint8  layout_ver:4;
    kal_uint8  type:3;  //MAC:1, RLC Header:2, PDCP:3, RLC UM PDU:4
    kal_uint8  truncate:1; //if header is truncated, this bit will set to 1
    	
    kal_uint8  dir:1;  //ul:0, dl:1  
    kal_uint8  msg_type:1;  //data:0, control:1  	
    kal_uint8  rlc_mode:1;  //AM:0, UM:1
    kal_uint8  sn_len:1;  //5bits:0, 10bits:1
    kal_uint8  li:1;  //w/o li:0, w/ li:1
    kal_uint8  resv0:3;
    	
    kal_uint8  rlc_hd_len:5;  //range 1 ~ 16 bytes
    kal_uint8  resv1:1;
    kal_uint8  resv2:1;
    kal_uint8  resv3:1;

    kal_uint8  rlc_header[EM_MAX_RLC_HDR_CP_LEN];  //rlc header raw data
} erlc_ota_stats_struct;


/* VzW EM ERLC UmDataPdu, ERLC UM data PDU print */
#pragma pack(1)
typedef struct
{	
    kal_uint8  layout_ver:4;
    kal_uint8  type:3;  //MAC:1, RLC Header:2, PDCP:3, RLC UM PDU:4
    kal_uint8  truncate:1; //don't care

    kal_uint8  rlc_mode:1; //AM:0, UM:1
    kal_uint8  sn_len:1;  //5bits:0, 10bits:1
    kal_uint8  dir:1;  //ul:0, dl:1
    kal_uint8  e_bit:1; //not exist:0, exist:1
    kal_uint8  li:4;  //11bits LI or 15 bits LI (value is 11 or 15)
    	
    kal_uint8  cfg_idx:6;    
    kal_uint8  fi:2;

    kal_uint8  pdu_status:3;
    kal_uint8  resv1:5;

    kal_uint16  logMask;
    kal_uint16  pdu_size;  //pdu size in bytes
    kal_uint16  num_logged;  //num bytes logged
    kal_uint8   rlc_data[EM_MAX_RLC_PDU_LOG_LEN];
} erlc_pdu_raw_struct;
#pragma pack()

/* this define number should be the same as defined in EL2 (in LTE domain) */
#define EM_PUB_MAX_RLC_RB (10)
#define EM_PUB_EMBMS_FREQ_SUPPORT (2)
#define EM_PUB_EMBMS_MCCH_SUPPORT (8)
#define EM_PUB_EMBMS_MRB_SUPPORT (8)

typedef struct
{
    erlcul_comp_pub_stats   ul;
    erlcdl_comp_pub_stats   dl;

    erlcul_rb_pub_stats_cfg ul_rb_cfg[EM_PUB_MAX_RLC_RB];
    erlcul_rb_pub_stats     ul_rb[EM_PUB_MAX_RLC_RB];
    erlcdl_rb_pub_stats_cfg dl_rb_cfg[EM_PUB_MAX_RLC_RB];
    erlcdl_rb_pub_stats     dl_rb[EM_PUB_MAX_RLC_RB];
    
    erlcdl_mrb_pub_stats_cfg dl_mcch_cfg[EM_PUB_EMBMS_FREQ_SUPPORT][EM_PUB_EMBMS_MCCH_SUPPORT];
    erlcdl_rb_pub_stats     dl_mcch[EM_PUB_EMBMS_FREQ_SUPPORT][EM_PUB_EMBMS_MCCH_SUPPORT];
    erlcdl_mrb_pub_stats_cfg dl_mrb_cfg[EM_PUB_EMBMS_FREQ_SUPPORT][EM_PUB_EMBMS_MRB_SUPPORT];
    erlcdl_rb_pub_stats     dl_mrb[EM_PUB_EMBMS_FREQ_SUPPORT][EM_PUB_EMBMS_MRB_SUPPORT];
} em_erlc_pub_stats_struct;


#define EM_PUB_EPDCP_MAX_DRB_NUM (8)
typedef struct
{
    kal_uint8 ebi;
    kal_uint8 rb_id;
    kal_uint8 flag_rlc_um; // AM: 0, UM: 1
    kal_uint8 flag_um_long_sn; // 7-bit: 0, 12-bit: 1 (UM only)
    kal_uint8 flag_am_long_sn; // 12-bit: 0, 15-bit: 1 (AM only)
    kal_uint8 rohc_enabled;
} epdcp_pub_drb_cfg_t;

typedef struct
{
    kal_uint32 ul_disc_cnt;
    kal_uint32 ul_min_pkt_byte;
    kal_uint32 ul_max_pkt_byte;

    kal_uint32 dl_lost_cnt;
    kal_uint32 dl_min_pkt_byte;
    kal_uint32 dl_max_pkt_byte;
    kal_uint32 next_sbmt_ltm_count;
} epdcp_pub_drb_stat_t;

typedef struct
{
    kal_uint32 ul_pdu_bits;
    kal_uint32 ul_tput_bps; // calculate from ul_pdu_bits when send to EM
    kal_uint32 dl_pdu_bits;
    kal_uint32 dl_tput_bps; // calculate from dl_pdu_bits when send to EM
    epdcp_pub_drb_cfg_t drb_cfg[EM_PUB_EPDCP_MAX_DRB_NUM];
    epdcp_pub_drb_stat_t drb_stat[EM_PUB_EPDCP_MAX_DRB_NUM];
} em_epdcp_pub_stats_struct;

#define EPDCP_LWA_PUB_STATS_RB_NUM (10)

typedef struct
{
    kal_uint32 lte_dl_pdu_byte;     
    kal_uint32 lte_dl_pdu_num;      
    kal_uint32 lte_dl_oow_pdu_num;  
    kal_uint32 wifi_dl_pdu_byte;    
    kal_uint32 wifi_dl_pdu_num;     
    kal_uint32 wifi_dl_oow_pdu_num; 
    kal_uint32 lwa_dl_dlvr_byte;    
    kal_uint32 lwa_dl_dlvr_pdu_num;
} em_epdcp_lwa_dl_rb_stats_struct;

typedef struct
{
    em_epdcp_lwa_dl_rb_stats_struct lwa_dl_stats[EPDCP_LWA_PUB_STATS_RB_NUM];
    kal_uint32 lte_dl_accumulate_byte;
    kal_uint32 wifi_dl_accumulate_byte;
    kal_uint32 lwa_dl_accumulate_byte;
    kal_uint32 lte_dl_tput_kbps;
    kal_uint32 wifi_dl_tput_kbps;
    kal_uint32 lwa_dl_tput_kbps;
	kal_uint32 lte_oow_rate;
	kal_uint32 wifi_oow_rate;
} em_epdcp_lwa_pub_stats_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum        em_info;

    em_el2_pub_info_t   el2_info;
    em_erlc_pub_stats_struct erlc_stats;
    em_emac_pub_tput_info_struct emac_tput_info;
    em_epdcp_pub_stats_struct epdcp_stats;
    em_epdcp_lwa_pub_stats_struct epdcp_lwa_stats;
} em_el2_pub_status_ind_struct;

extern em_el2_pub_status_ind_struct el2_pubstatus_g;


typedef enum
{
    EMAC_RA_REASON_CHANNEL_REQUEST,
    EMAC_RA_REASON_RADIO_LINK_TIMEOUT,
    EMAC_RA_REASON_ULDATA,
    EMAC_RA_REASON_NOPUCCH,
    EMAC_RA_REASON_MAXSR,
    EMAC_RA_REASON_HO,
    EMAC_RA_REASON_DLDATA,
    EMAC_RA_REASON_RSIM
} emac_ra_reason_enum;

typedef enum
{
    EMAC_RA_RESULT_SUCCEEDED,
    EMAC_RA_RESULT_ABORTED,
    EMAC_RA_RESULT_FAILED_RAR,
    EMAC_RA_RESULT_FAILED_CR_EXPIRE,
    EMAC_RA_RESULT_FAILED_CR_FAIL
} emac_ra_result_enum;

typedef struct
{
  LOCAL_PARA_HDR
  em_info_enum          em_info;
  emac_ra_reason_enum ra_reason;

  kal_uint8             group_a_size;
  kal_uint8             msg_sz_group_a;
  kal_uint8             pow_ramping;
  kal_uint8             preamble_tx_max;
  kal_uint8             rar_wnd_sz;
  kal_uint8             cr_timer;
  kal_uint8             msg3_tx_max;
  kal_uint8             group_b_size;
  kal_uint8             msg_pow_offset_group_b;
  kal_int8              preamble_init_pow;
  kal_int8              pmax;
  kal_int8              delta_preamble_msg3;
    
  kal_uint64            ueid;
  kal_bool              contention;
  kal_uint8             prach_mask_index;
  kal_uint32            msg3_potential_size;
  kal_uint8             preamble_group;
  kal_uint32            c_rnti;    
}em_emac_rach_trigger_ind_struct;

typedef struct
{
  LOCAL_PARA_HDR
  em_info_enum          em_info;
  
  kal_uint8             group_a_size;
  kal_uint8             msg_sz_group_a;
  kal_uint8             pow_ramping;
  kal_uint8             preamble_tx_max;
  kal_uint8             rar_wnd_sz;
  kal_uint8             cr_timer;
  kal_uint8             msg3_tx_max;
  kal_uint8             group_b_size;
  kal_uint8             msg_pow_offset_group_b;
  kal_int8              preamble_init_pow;
  kal_int8              pmax;
  kal_int8              delta_preamble_msg3;
} em_emac_config_report_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum          em_info;
    kal_uint32 num_of_rach_try;
}em_emac_rach_success_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum          em_info;
    kal_uint32 num_of_rach_try;
}em_emac_rach_failure_ind_struct;

#define EM_EMAC_MAX_MSG3_DATA_LEN 10
typedef struct
{
    LOCAL_PARA_HDR

    em_info_enum em_info;
    emac_ra_result_enum ra_result;

    kal_uint8           preamble_cnt;
    kal_uint32          rar_ul_grant;
    kal_uint16          rar_tc_rnti;
    kal_uint16          rar_ta_value;
    kal_bool            contention;
    kal_uint8           rach_message;
    kal_uint8           preamble_index;
    kal_uint8           preamble_power_offset;
    kal_uint16          backoff_time;
    kal_int8            harq_id;
    kal_uint8           msg3_mac_pdu_data[EM_EMAC_MAX_MSG3_DATA_LEN];
    kal_uint8           msg3_mac_pdu_len;

    kal_uint16          earfcn;
    kal_uint16          phys_cell_id;
    kal_uint16          ra_rnti;
    kal_uint8           ra_preamble_last_TXpower;
    kal_uint8           rar_successed;
} em_emac_rach_finish_ind_struct;

#define EM_EMAC_MAX_HEADER_LEN 11
typedef struct
{
    kal_uint8           subframe_nb;
    kal_uint16          frame_nb;
    em_emac_rnti_enum   rnti_type;
    kal_uint8           harq_id;
    kal_uint32          num_rlc_pdus;
    kal_uint32          num_padding_bytes;
    kal_uint8           mac_header_data[EM_EMAC_MAX_HEADER_LEN];
    kal_uint8           mac_header_len;
    kal_uint32          tb;
} em_emac_dl_tb;

// report interval 100ms, maximum number of reported TBs is
// 2TB * 2CC * 100ms = 400TBs in Gen91
#define EM_EMAC_MAX_TBS_REPORT_NUM 400
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32          num_tbs;
    em_emac_dl_tb       tbs[EM_EMAC_MAX_TBS_REPORT_NUM];
} em_emac_dl_tbs_report_ind_struct;

/* EL1 RX PATH set command*/
typedef enum {
    BOTH_RX_PATH = 0,
    RX_PATH_0    = 1,
    RX_PATH_1    = 2,
    PATH_INVALID = 3
} rx_path_setting_enum;

typedef enum {
    SET_RX_PATH  = 0,
    READ_RX_PATH = 1
} rx_path_cmd_type;

#define UL1_RX_PATH_BASE 10

typedef enum {
    UL1_RX_MAIN_ONLY = 0,
    UL1_RX_RXD_ONLY  = 1,
    UL1_RX_BOTH      = 2,
    UL1_RX_OFF       = 3   // Resume default
} ul1_rx_path_set_enum;

typedef struct
{
    kal_bool             nvram_write;  //This flag is used to indicate whether EL1 need to write Rx path setting to NVRAM when receiving set Rx path command
    rx_path_cmd_type     cmd_type;
    rx_path_setting_enum rx_path;
    kal_bool             req_valid;
}rx_path_req_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_uint8               src_id;
    rx_path_req_info_struct rx_path_req [RPT_LTE_RX_CC_MAX];
}l4cel1_set_rx_path_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    rx_path_cmd_type cmd_type;
    kal_bool rx_path_set_result; //only used for Rx path command set
                                                  //1:success, 0:failed
    rx_path_setting_enum rx_path; //only used for Rx path command read
}l4cel1_set_rx_path_cnf_struct;


typedef struct
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    ul1_rx_path_set_enum rx_path;
    kal_bool nvram_write;  // This flag is used to indicate whether need to save the setting in NVRAM or not
    rx_path_cmd_type cmd_type;
}l4cul1_set_rx_path_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    kal_bool  result;
    rx_path_cmd_type cmd_type;
    ul1_rx_path_set_enum  rx_path;
}l4cul1_set_rx_path_cnf_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_uint8 band;
    kal_uint16 dl_earfcn;
}l4cel1_rx_rssi_verify_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_int32 rssi0_edBm;
    kal_int32 rssi1_edBm;
}l4cel1_rx_rssi_verify_ind_struct;

/* EL1 RF TEMPURATURE */
typedef struct
{
    LOCAL_PARA_HDR
}l4cel1_get_rf_temperature_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_int16 rf_temperature; /* range : -40 ~ 140, 0x8000 means invalid value */
}l4cel1_get_rf_temperature_cnf_struct;

/* EL1 MONITOR RF TEMPERATURE */
typedef struct
{
    LOCAL_PARA_HDR

    kal_bool on;                    /* KAL_TRUE :  Turn on monitor rf temperature*/
                                    /* KAL_FALSE : Turn off monitor rf temperature*/
    kal_int16 threshold ;           /* Range : -40 ~ 140 */
    kal_int16 monitor_period;       /*unit : 1ms*/
}l4cel1_monitor_rf_temperature_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
}l4cel1_monitor_rf_temperature_cnf_struct;

typedef struct
{
    LOCAL_PARA_HDR

    kal_int16 curr_temperature;  /* current temperature when it is over threshold*/
    kal_int16 threshold ;        /* Range : -40 ~ 140 */
}l4cel1_monitor_rf_temperature_ind_struct;

/* EL1 TX POWER */
typedef struct
{
    LOCAL_PARA_HDR
}l4cel1_get_tx_power_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_int8 tx_power; /* tx power : -50, -127 : invalid */
}l4cel1_get_tx_power_cnf_struct;

typedef struct 
{
	LOCAL_PARA_HDR
	kal_uint8 src_id;
	kal_bool pri_receiver;
	kal_bool sec_receiver;
} l4cel1_antenna_information_req_struct;

typedef struct 
{
	LOCAL_PARA_HDR 
	kal_uint8 src_id;
	kal_bool result; //KAL_TRUE if success; otherwise KAL_FALSE
	kal_bool is_pri_receiver_valid;
	kal_uint16 pri_rssi;
	kal_bool is_sec_receiver_valid;
	kal_uint16 sec_rssi;
	kal_bool is_relative_phase_valid;
	kal_uint16 relative_phase;
} l4cel1_antenna_information_cnf_struct;

typedef struct 
{
	LOCAL_PARA_HDR 
	kal_uint8 src_id;
	l4cel1_antenna_config_enum configuration;
} l4cel1_antenna_config_req_struct;

typedef struct 
{
	LOCAL_PARA_HDR   
	kal_uint8 src_id;
	kal_bool result; //KAL_TRUE if success; otherwise KAL_FALSE
} l4cel1_antenna_config_cnf_struct;

typedef struct 
{
	LOCAL_PARA_HDR  
	kal_uint8 src_id;
} l4cel1_antenna_config_status_req_struct;


typedef struct 
{
	LOCAL_PARA_HDR  
	kal_uint8 src_id;
    kal_bool result; //antenna status result
	l4cel1_antenna_status_enum ue_behavior;
} l4cel1_antenna_config_status_cnf_struct;



/* For TSTL4C_EM_START_REQ, TSTL4C_EM_STOP_REQ */
typedef struct
{
   LOCAL_PARA_HDR
   module_type mod_id;
   request_info_type	info_request;
} tstl4c_em_start_req_struct;

typedef tstl4c_em_start_req_struct tstl4c_em_stop_req_struct;


/* RR structure */
typedef struct
{
	kal_uint8	crh;   //CELL-RESELECT-HYSTERESIS
	kal_uint8	ms_txpwr;   // 	maximum TX power level an MS may use when accessing on a CCH
	kal_uint8	rxlev_access_min;   //	minimum received signal level at the MS for which it is permitted to access the system
} rr_em_cell_select_para_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_cell_select_para_info_struct rr_em_cell_select_para_info;
} em_rrm_cell_select_para_info_ind_struct;

typedef struct
{
	kal_uint8	channel_type;   //	channel type
	kal_uint8	tn;   //	timeslot number
	kal_uint8	tsc;   //	training sequence code
	kal_uint8	hopping_flag;   //	hopping or not
	kal_uint8	maio;   //	MAIO value
	kal_uint8	hsn;   //	HSN value
	kal_uint8	num_of_carriers;   //	number of carriers in the BA list(in the non-hopping case, this shall be set to 1)
	kal_uint16	arfcn[64];   //	ARFCN value in the MA
	kal_bool     is_BCCH_arfcn_valid; /*the BCCH_arfcn is only valid
	                              when receives H.O cmd in DEDI-state*/
	kal_uint16 BCCH_arfcn;   //	Target_BCCH carrier

	/*ZY:2006-08-15 add cipher algo for EM */
	kal_uint8	cipher_algo;  // ciphering value, OFF/A51/A52
	kal_uint8 imeisv_digit[16]; /* To show IMEISV if sent in ciphering mode setting procedure */

    kal_uint8 channel_mode;

	/* brwang, 051024, [AMR engineering mode info.] */
       #ifdef __AMR_SUPPORT__
       kal_bool amr_valid; /* the AMR(TRUE) or not(FALSE) */
       kal_uint8 mr_ver;   /* MultiRate speech VERsion : 001-amr verion 1*/
       kal_bool nscb;      /* Noise Supression Control Bit : 0-noise supression is used */
       kal_bool icmi;       /* Initial Codec Mode Indicator : 0-is defined bythe implicit rule */
       kal_uint8 start_codec_mode; /* Start Codec Mode */
       kal_uint8 acs;       /* AMR Codec Activate Set */
       kal_uint8 threshold[3]; /* Threshold1/Threshold2/Threshold3 */
       kal_uint8 hysteresis[3]; /* Hysteresis1/Hysteresis2/Hysteresis3 */
       #endif
} rr_em_channel_descr_info_struct;	//This shall be used in IDLE and DEDI state

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_channel_descr_info_struct rr_em_channel_descr_info;
} em_rrm_channel_descr_info_ind_struct;

typedef struct
{
	kal_uint8	mscr;   //	MSC release
	kal_uint8	att;   //	att flag
	kal_uint8	bs_ag_blks_res;   //	BS-AG-BLKS-RES
	kal_uint8	ccch_conf;   //	CCCH-CONF
	kal_uint8	cbq2;   //	Cell Bar Qualify 2
	kal_uint8	bs_pa_mfrms;   //	BS-PA-MFRMS
	kal_uint8	t3212;   //	T3212 timeout value
} rr_em_ctrl_channel_descr_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_ctrl_channel_descr_info_struct rr_em_ctrl_channel_descr_info;
} em_rrm_ctrl_channel_descr_info_ind_struct;

typedef struct
{
	kal_uint8	max_retrans;   //	MAX Retrans value
	kal_uint8	tx_integer;   //	TX integer
	kal_uint8	cba;   //	cell bar for access
	kal_uint8	re;   //	call reestablishment allowed
	kal_uint8	acc_class[2];   //	acces control class
	kal_bool	CB_supported;	// cell broadcast is supported
} rr_em_rach_ctrl_para_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_rach_ctrl_para_info_struct rr_em_rach_ctrl_para_info;
} em_rrm_rach_ctrl_para_info_ind_struct;

typedef enum
{
    EM_MT_CALL_TYPE_MO    = 0,
    EM_MT_CALL_TYPE_MT,
    EM_MT_CALL_TYPE_EMERGENCY,
    EM_MT_CALL_TYPE_INVALID
} em_mt_call_type_enum;
typedef struct
{
	kal_uint16	max_value;   //	timeout value for the DSF or RLF
	kal_int16	current_value;   //	current value in the DSF or RLF calculation
	kal_uint8	dtx_ind;	//DTX indicator
	kal_uint8	dtx_used;	//DTX used or not
	kal_bool	is_dsf;		//timeout value for the DSF or RLF
	kal_uint16  serv_cell_arfcn;    // serving cell arfcn
	em_mt_call_type_enum  call_type;    // MO/MT
} rr_em_radio_link_counter_info_struct;  //This shall be used in IDLE and DEDI state

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_radio_link_counter_info_struct rr_em_radio_link_counter_info;
} em_rrm_radio_link_counter_info_ind_struct;

typedef struct
{
    kal_bool    is_valid;
    kal_uint8   cs_report_type;
    kal_bool    is_invalid_bsic_rp;
    kal_uint8   cs_serv_band_rp;
    kal_uint8   cs_multi_band_rp;
    /* When cs_rp_threshold_850 is eqaul to 0xFF, it means never */
    kal_uint8   cs_rp_threshold_850;
    kal_uint8   cs_rp_offset_850;
    /* When cs_rp_threshold_900 is eqaul to 0xFF, it means never */
    kal_uint8   cs_rp_threshold_900;
    kal_uint8   cs_rp_offset_900;
    /* When cs_rp_threshold_1800 is eqaul to 0xFF, it means never */
    kal_uint8   cs_rp_threshold_1800;
    kal_uint8   cs_rp_offset_1800;
    /* When cs_rp_threshold_1900 is eqaul to 0xFF, it means never */
    kal_uint8   cs_rp_threshold_1900;
    kal_uint8   cs_rp_offset_1900;
} rr_em_cs_meas_param_struct;

typedef struct
{
    kal_bool    is_valid;
    kal_uint8   ps_report_type;
    kal_bool    is_invalid_bsic_rp;
    kal_uint8   ps_serv_band_rp;
    kal_uint8   ps_multi_band_rp;
    /* When ps_rp_threshold_850 is eqaul to 0xFF, it means never */
    kal_uint8   ps_rp_threshold_850;
    kal_uint8   ps_rp_offset_850;
    /* When ps_rp_threshold_900 is eqaul to 0xFF, it means never */
    kal_uint8   ps_rp_threshold_900;
    kal_uint8   ps_rp_offset_900;
    /* When ps_rp_threshold_1800 is eqaul to 0xFF, it means never */
    kal_uint8   ps_rp_threshold_1800;
    kal_uint8   ps_rp_offset_1800;
    /* When ps_rp_threshold_1900 is eqaul to 0xFF, it means never */
    kal_uint8   ps_rp_threshold_1900;
    kal_uint8   ps_rp_offset_1900;
} rr_em_ps_meas_param_struct;

typedef struct
{

    kal_uint8            rr_state;                    /* NULL: 0, INACTIVE: 1, SELECTION: 2
                                                       * IDLE: 3, ACCESS: 4. PKT_TRANSFER: 6
                                                       * DEDICATED:6, RESELCTION: 7 */
    kal_uint8            meas_mode;                   /* GSM: 0, GPRS_CCCH: 1, GPRS_PMO_CCCH: 2
                                                       * GPRS_PCCCH = 3 */
    kal_uint16           serving_arfcn;               /* serving cell ARFCN */
    kal_uint8            serving_bsic;                /* serving cell BSIC */
    kal_uint8            serving_current_band;
    kal_uint8            serv_gprs_supported;         /* serving cell support GPRS or not */
    kal_int16            serv_rla_in_quarter_dbm;     /* RSSI level for serving cell
                                                       * 1. BCCH in IDLE-state
                                                       * 2. TCH in DEDI-state
                                                       * 3. PDTCH in TRANSFER-state */
    kal_uint8            serv_rla_reported_value;     /* Reported value of RSSI level for serving cell */
    kal_bool             is_serv_BCCH_rla_valid;      /* To indicate if the serv_BCCH RSSI is valid*/
    kal_int16            serv_BCCH_rla_in_dedi_state; /*RSSI level for serving cell (BCCH) in DEDI-State */
    kal_uint8            quality;                     /* serving cell -TCH measured quality */
    kal_bool             gprs_pbcch_present;          /* To indicate if the current cell supports GPRS
                                                       * PBCCH is present */
    kal_bool             gprs_c31_c32_enable;         /* To indicate if the current mode is GPRS_PMO_MODE
                                                       * or GPRS_PCCCH_MODE.
                                                       */
    kal_int16            c1_serv_cell;                /* C1 value for the serving cell */
    kal_int16            c2_serv_cell;                /* if gprs_c31_c32_enable is false, this field is shown
                                                       * as c2_value for serv_cell.
                                                       * if gprs_c31_c32_enable is true, this field is shown
                                                       * as c32_value for serv_cell */
    kal_int16            c31_serv_cell;               /* if gprs_c31_c32_enable is false, this field is ignore
                                                       * if gprs_c31_c32_enable is true, this field shall be
                                                       * shown in based on report c31_value */
    kal_uint8            num_of_carriers;             /* number of carriers in the BA list */
    kal_uint16           nc_arfcn[32];                /* ARFCN value in the BA list (The list will be sorted
                                                       * by the RSSI level */
    kal_int16            rla_in_quarter_dbm[32];      /* rssi level for each carrier */
    kal_uint8            rla_in_reported_value[32];   /* Reported value of RSSI level for each carrier. */
    kal_uint8            nc_info_status[32];          /* Bit0 = 0: "nc_bsic","frame_offset","ebit_offset" is invalid
                                                       * Bit0 = 1: "nc_bsic","frame_offset","ebit_offset" is valid
                                                       * Bit1 = 0: "c1","c2" is invalid
                                                       * Bit1 = 1: "c1","c2" is valid
                                                       * Bit2 = 0: "gprs_status" is invalid
                                                       * Bit2 = 1: "gprs_status" is valid */
    kal_uint8            nc_bsic[32];                 /* neighbor cell BSIC */
    kal_int32            frame_offset[32];            /* frame offset for each carrier */
    kal_int32            ebit_offset[32];             /* ebit offset for each carrier */
    kal_int16            c1[32];                      /* C1 value for the neighbor cell */
    kal_int16            c2[32];                      /* if gprs_c31_c32_enable is false, this field is shown as
                                                       * c2_value for nbr_cell
                                                       * if gprs_c31_c32_enable is true, this field is shown as
                                                       * c32_value for nbr_cell */
    kal_int16            c31[32];                     /* C31 value for the neighbor cell */
    kal_uint8            multiband_report;            /* MULTIBAND_REPORT value */
    kal_uint8            timing_advance;              /* Timing advance, range is 0 - 63 */
    kal_int16            tx_power_level;
    kal_int16            serv_rla_full_value_in_quater_dbm;
    kal_uint8            nco;
    kal_uint8            rxqual_sub;                  /* rx quality (sub), range is 0 - 7 */
    kal_uint8            rxqual_full;                 /* RX quality (full), range is 0 - 7 */
    kal_int16            using_tx_power_in_dbm;       /* DL_DTX_AND_TX_POWER */
#ifdef __AMR_SUPPORT__
    kal_bool             amr_info_valid;
    kal_uint8            cmr_cmc_cmiu_cmid;
    kal_uint8            c_i;
    kal_uint16           icm;
    kal_uint16           acs;
    kal_bool             dl_dtx_used;                 /* DL_DTX_AND_TX_POWER */
    em_amr_mode_enum cmr;
    em_amr_mode_enum cmc;
    em_amr_mode_enum amr_ul_mode;
    em_amr_mode_enum amr_dl_mode;
#endif /* __AMR_SUPPORT__ */
#ifdef __FWP_NC_LAI_INFO__
    kal_uint8            num_of_nc_lai;               /* how many valid LAI info in nc_lai[] array */
    rr_em_lai_info_struct nc_lai[6];                  /* store LAI and CID for at most 6 strongest neighbor cells */
#endif /* __FWP_NC_LAI_INFO__ */
    rr_em_cs_meas_param_struct cs_meas_param;
    rr_em_ps_meas_param_struct ps_meas_param;
    /*Shin, Amazon EM, nbr cell band, cellid, barred status report*/
    kal_uint8       nc_band[32];
    kal_uint16      nc_cellid[32];
    kal_bool        nc_barred[32]; 
    kal_bool        band_ind;
} rr_em_measurement_report_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_measurement_report_info_struct rr_em_measurement_report_info;
} em_rrm_measurement_report_info_ind_struct;

/*ZY : 2007/07/25 : Add for Cell allocation list*/
typedef struct
{
        kal_uint8   valid;
        kal_uint8   number_of_channels;
        kal_uint16 arfcn_list[64];
} rr_em_ca_list_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_ca_list_info_struct rr_em_ca_list_info;
} em_rrm_ca_list_info_ind_struct;

typedef struct
{
	kal_uint8	msg_type;	/*receives msg type from network in Dedi-State
	                          0: Assignment Command
	                          1: Channel Release
	                          2: Additional Assignment
	                          3: Classmark Enquiry
	                          4: Ciphering Mode Command
	                          5: Configure Change Command
	                          6: Handover Command
	                          7: Frequency Redefinition
	                          8: Channel Mode Modify
	                          9: Cell Selection Indicator*/


   kal_uint8 rr_cause;

} rr_em_control_msg_info_struct;

/* Katie 2013027: em revise */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_control_msg_info_struct rr_em_control_msg_info;

} em_mac_control_msg_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_control_msg_info_struct rr_em_control_msg_info;
} em_rrm_control_msg_info_ind_struct;

/*Byron: 2006/08/06: Add for SI2q information*/
typedef struct
{
	kal_bool 	present;
	kal_uint8 no_of_instance;
	kal_bool 	emr_report;
       kal_bool 	pemr_report;
	kal_bool 	umts_parameter_exist;
} rr_em_si2q_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_si2q_info_struct rr_em_si2q_info;
} em_rrm_si2q_info_ind_struct;

/*Byron: 2006/08/06: Add for measurement information*/
typedef struct
{
	kal_bool 	present;
	kal_uint8 no_of_instance;
	kal_bool 	emr_report;
	kal_bool 	umts_parameter_exist;
} rr_em_mi_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_mi_info_struct rr_em_mi_info;
} em_rrm_mi_info_ind_struct;

/* James 2012/8/15: move up gprs info for EM UT */
typedef struct
{
	kal_uint32 t3192;         // in msec
	kal_uint32 t3168;         // in msec
	kal_uint8  rp;            // radio priority
	kal_uint8  gprs_support;  // GPRS channel request support(0 not support, 1 support, 2 support but not decode)
	kal_uint8  egprs_support; // EGPRS channel request support(0 not support, 1 support)
	kal_uint8  sgsn_r;		  // PS domain is R99 or R98(0 R98, 1 R99)
	kal_uint8  pfc_support;   // packet flow context support(0 not support, 1 support)
	kal_uint8  epcr_support;  // EGPRS channel request support(0 not support, 1 support)
	kal_uint8  bep_period;	  // BEP period
}rr_em_gprs_general_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_gprs_general_info_struct rr_em_gprs_general_info;
} em_rrm_gprs_general_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_lai_info_struct rr_em_lai_info;
} em_rrm_lai_info_ind_struct;
typedef struct
{
	kal_bool 	is_greater_than_85db;	/*serving cell power is greater than 85dbm lasts for 5s*/
}rr_em_serv_cell_power_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_serv_cell_power_struct rr_em_serv_cell_power_status;
}em_rrm_serv_cell_power_status_ind_struct;

typedef struct
{
	kal_bool with_4g_neighbor;	/*SI contains 4g neigbor cell or not*/
}rr_em_4g_neigbor_cell_status_sturct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
	rr_em_4g_neigbor_cell_status_sturct rr_em_4g_neighbor_status;
}em_rrm_ir_4g_neighbor_cell_status_ind_struct;

typedef struct
{
	kal_bool with_3g_neighbor;	/*SI contains 3g neigbor cell or not*/
}rr_em_3g_neigbor_cell_status_sturct;

typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum em_info;
	rr_em_3g_neigbor_cell_status_sturct rr_em_3g_neighbor_status;
}em_rrm_ir_3g_neighbor_cell_status_ind_struct;

typedef enum
{
    EM_RRM_SUCCESS_RATE_KPI_IRAT_2G3_CR,
    EM_RRM_SUCCESS_RATE_KPI_IRAT_2G3_CCO,        
    EM_RRM_SUCCESS_RATE_KPI_IRAT_2G3_HO,
    EM_RRM_SUCCESS_RATE_KPI_IRAT_2G3_REDIR,

    EM_RRM_SUCCESS_RATE_KPI_NUM
}em_rrm_success_rate_kpi_proc_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_rrm_success_rate_kpi_proc_enum proc_id;
    em_kpi_status_enum status;
    kal_uint32  attempt;
    kal_uint32  success;
}em_rrm_success_rate_kpi_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_bool   is_t3126_exp;
    kal_uint16 serv_cell_arfcn;    // serving cell arfcn
}em_rrm_mt_t3126_timeout_ind_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
}em_rrm_cs_rlf_info_ind_struct;


typedef enum {
    EPDCP_MAJOR_VERSION = 11
} EPDCP_MAJOR_VERSION_INFO;

typedef enum {
    EPDCP_MINOR_VERSION = 4
} EPDCP_MINOR_VERSION_INFO;

typedef enum {
    EPDCP_RELEASE_VERSION = 0
} EPDCP_RELEASE_VERSION_INFO;

typedef enum {
    EMAC_MAJOR_VERSION = 11
}EMAC_MAJOR_VERSION_INFO;

typedef enum {
    EMAC_MINOR_VERSION = 6 
}EMAC_MINOR_VERSION_INFO;

typedef enum {
    EMAC_RELEASE_VERSION = 0 
}EMAC_RELEASE_VERSION_INFO;

typedef enum {
    ERLC_MAJOR_VERSION = 11
}ERLC_MAJOR_VERSION_INFO;

typedef enum {
    ERLC_MINOR_VERSION = 0
}ERLC_MINOR_VERSION_INFO;

typedef enum {
    ERLC_RELEASE_VERSION = 0
}ERLC_RELEASE_VERSION_INFO;

/**************************************************************************
  * GSM MM - Engineer Mode
  *
  * Notes: Following structures are maintained by RR task
  **************************************************************************/
/***************************** Beging of RR MM EM Config  **************************/
#define MAX_NR_RR_EM_IR_RESEL_STATUS 6
#define MAX_NR_RR_EM_3G_MEAS_STATUS  6
#define MAX_NR_RR_EM_4G_MEAS_STATUS  6
#define MAX_NR_RR_EM_3G_MEAS_INFO    9
#define MAX_NR_RR_EM_4G_MEAS_INFO    9

#define INVALID_GSM_PRIORITY         0x2B
#define THR_PRIO_SEARCH_ALWAYS       0x7F
#define THR_GSM_LOW_ALWAYS           0xFF
#define GSM_REPORT_THR_NEVER         0xFF

#define INVALID_UMTS_QSRCH_C         0xFF
#define INVALID_UMTS_MULTI_REPORT    0xFF
#define INVALID_UMTS_FDD_QMIN_OFF    0xFF
#define INVALID_UMTS_FDD_RSCPMIN     0x7F
#define INVALID_UMTS_FDD_REP_THR_2   0xFF
#define INVALID_UMTS_PRIORITY        0x2B
#define INVALID_UMTS_THR_HIGH        0xFF
#define INVALID_UMTS_THR_LOW         0xFF
#define INVALID_UMTS_QRX_LEVMIN      0x7F
#define UMTS_REPORT_THR_NEVER        0xFF
#define UMTS_FDD_QOFFSET_ALWYAS      0x7F

#define INVALID_LTE_QSRCH_C          0xFF
#define INVALID_LTE_QSRCH_C_INIT     0xFF
#define INVALID_LTE_MULTI_REPORT     0xFF
#define INVALID_LTE_PRIORITY         0x2B
#define INVALID_LTE_THR_HIGH         0xFF
#define INVALID_LTE_THR_LOW          0xFF
#define INVALID_LTE_QRX_LEVMIN       0x7FFF
#define INVALID_LTE_THR_HIGH_Q       0x7F
#define INVALID_LTE_THR_LOW_Q        0x7F
#define INVALID_LTE_QMIN             0x7F
#define INVALID_LTE_QQUALMIN         0x7F
#define INVALID_LTE_RSRPMIN          0x7FFF
#define LTE_REPORT_THR_NEVER         0xFF

typedef enum {
    RRM_EM_IR_MEAS_STOPPED                = 0x00,
    RRM_EM_IR_FIXED_MEAS_START            = 0x01,
    RRM_EM_IR_70S_PRIO_MEAS_START         = 0x02,
    RRM_EM_IR_70S_PRIO_N_FIXED_MEAS_STRAT = 0x03,
    RRM_EM_IR_25S_PRIO_MEAS_START         = 0x04,
    RRM_EM_IR_25S_PRIO_N_FIXED_MEAS_START = 0x05
} rrm_em_ir_meas_status_enum;

typedef struct
{
    kal_bool          is_valid;
    /* When geran_priority is equal to 0x2B, it means geran_priority is invalid. */
    kal_int8          geran_priority;
    /* When thresh_priority_search is eqaul to 0x7F, it measns always. */
    kal_int8          thresh_priority_search;
    /* When thresh_GSM_low is equal to 0xFF, it means always. */
    kal_uint8         thresh_GSM_low;
    /* When h_prio is equal to 0, it means h_prio is disabled. */
    kal_uint8         h_prio;
    kal_uint8         t_reselection;
}rrm_em_ir_2g_parameter_struct;

typedef struct
{
    kal_bool          is_valid;
    /* The value of ir_source is the enumeration value
     * SRC_INVALID = 0,
     * SRC_SI      = 1,
     * SRC_MI      = 2,
     * SRC_PSI     = 3,
     * SRC_PMO     = 4
     */
    kal_uint8         ir_source;
    kal_uint8         qsearch_i;
    /* When qsearch_c is eqaul to 0xFF, qsearch_c is invalid */
    kal_uint8         qsearch_c;
    kal_uint8         qsearch_c_initial;
    kal_uint8         qsearch_p;
    /* When fdd_qoffset is eqaul to 0x7F, it measns always. */
    kal_int8          fdd_qoffset;
    kal_int8          fdd_qmin;
    /* When fdd_qmin_off is equal to 0xFF, fdd_qmin_off is invalid */
    kal_uint8         fdd_qmin_off;
    /* When fdd_rscpmin is equal to 0x7F, fdd_rscpmin is invalid */
    kal_int8          fdd_rscpmin;
    kal_uint8         fdd_rep_quant;
    /* When fdd_multirat_reporting is eqaul to 0xFF, fdd_multirat_reporting is invalid */
    kal_uint8         fdd_multirat_reporting;
    kal_uint8         fdd_reporting_offset;
    /* When fdd_reporting_threshold is eqaul to 0xFF, it means never */
    kal_uint8         fdd_reporting_threshold;
    /* When fdd__reporting_threshold is equal to 0xFF, fdd_reporting_threshold_2 is invalid */
    kal_uint8         fdd_reporting_threshold_2;
    kal_uint8         fdd_gprs_rep_quant;
    /* When fdd_gprs_multirat_reporting is eqaul to 0xFF, fdd_gprs_multirat_reporting is invalid */
    kal_uint8         fdd_gprs_multirat_reporting;
    kal_uint8         fdd_gprs_reporting_offset;
    /* When fdd_gprs_reporting_threshold is eqaul to 0xFF, it means never */
    kal_uint8         fdd_gprs_reporting_threshold;
    /* When fdd_gprs_reporting_threshold is equal to 0xFF, fdd_gprs_reporting_threshold_2 is invalid */
    kal_uint8         fdd_gprs_reporting_threshold_2;
}FDD_rrm_em_ir_3g_parameter_struct;

typedef struct
{
    kal_bool          is_valid;
    /* The value of ir_source is the enumeration value
     * SRC_INVALID = 0,
     * SRC_SI      = 1,
     * SRC_MI      = 2,
     * SRC_PSI     = 3,
     * SRC_PMO     = 4
     */
    kal_uint8         ir_source;
    kal_uint8         qsearch_i;
    /* When qsearch_c is eqaul to 0xFF, qsearch_c is invalid */
    kal_uint8         qsearch_c;
    kal_uint8         qsearch_c_initial;
    kal_uint8         qsearch_p;
    kal_int8          tdd_qoffset;
    /* When tdd_multirat_reporting is eqaul to 0xFF, tdd_multirat_reporting is invalid */
    kal_uint8         tdd_multirat_reporting;
    kal_uint8         tdd_reporting_offset;
    /* When tdd_reporting_threshold is eqaul to 0xFF, it means never */
    kal_uint8         tdd_reporting_threshold;
    /* When tdd_gprs_multirat_reporting is eqaul to 0xFF, tdd_gprs_multirat_reporting is invalid */
    kal_uint8         tdd_gprs_multirat_reporting;
    kal_uint8         tdd_gprs_reporting_offset;
    /* When tdd_gprs_reporting_threshold is eqaul to 0xFF, it means never */
    kal_uint8         tdd_gprs_reporting_threshold;
}TDD_rrm_em_ir_3g_parameter_struct;


typedef struct
{
    kal_bool          is_valid;
    /* The value of ir_source is the enumeration value
     * LTE_PARA_INVALID = 0,
     * LTE_PARA_FROM_SI2Q = 1,
     * LTE_PARA_FROM_MI = 2,
     * LTE_PARA_FROM_PMO = 3
     */
    kal_uint8         ir_source;
    /* When qsearch_c_eutran_initial is eqaul to 0xFF, qsearch_c_eutran_initial is invalid */
    kal_uint8         qsearch_c_eutran_initial;
    /* When qsearch_c_eutran is eqaul to 0xFF, qsearch_c_eutran is invalid */
    kal_uint8         qsearch_c_eutran;
    kal_uint8         qsearch_p_eutran;
    kal_uint8         eutran_rep_quant;
    /* When eutran_multirat_reporting is eqaul to 0xFF, eutran_multirat_reporting is invalid */
    kal_uint8         eutran_multirat_reporting;
    /* When eutran_6bit_fdd_report_threshold is eqaul to 0xFF, it means never */
    kal_uint8         eutran_6bit_fdd_report_threshold;
    kal_uint8         eutran_6bit_fdd_report_threshold_2;
    kal_uint8         eutran_6bit_fdd_report_offset;
    /* When eutran_6bit_tdd_report_threshold is eqaul to 0xFF, it means never */
    kal_uint8         eutran_6bit_tdd_report_threshold;
    kal_uint8         eutran_6bit_tdd_report_threshold_2;
    kal_uint8         eutran_6bit_tdd_report_offset;
    kal_int16         eutran_3bit_fdd_meas_report_offset;
    kal_uint8         eutran_3bit_fdd_report_threshold_2;
    kal_uint8         eutran_3bit_fdd_report_offset;
    kal_int16         eutran_3bit_tdd_meas_report_offset;
    kal_uint8         eutran_3bit_tdd_report_threshold_2;
    kal_uint8         eutran_3bit_tdd_report_offset;
    kal_uint8         eutran_3bit_report_granularity;
    kal_uint8         eutran_gprs_rep_quant;
    /* When eutran_gprs_multirat_reporting is eqaul to 0xFF, eutran_gprs_multirat_reporting is invalid */
    kal_uint8         eutran_gprs_multirat_reporting;
    /* When eutran_gprs_6bit_fdd_report_threshold is eqaul to 0xFF, it means never */
    kal_uint8         eutran_gprs_6bit_fdd_report_threshold;
    kal_uint8         eutran_gprs_6bit_fdd_report_threshold_2;
    kal_uint8         eutran_gprs_6bit_fdd_report_offset;
    /* When eutran_gprs_6bit_tdd_report_threshold is eqaul to 0xFF, it means never */
    kal_uint8         eutran_gprs_6bit_tdd_report_threshold;
    kal_uint8         eutran_gprs_6bit_tdd_report_threshold_2;
    kal_uint8         eutran_gprs_6bit_tdd_report_offset;
} rrm_em_ir_4g_parameter_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rrm_em_ir_2g_parameter_struct ir_2g_parameter;
    FDD_rrm_em_ir_3g_parameter_struct ir_3g_parameter;
    rrm_em_ir_4g_parameter_struct ir_4g_parameter;
} fdd_em_rrm_ir_parameter_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rrm_em_ir_2g_parameter_struct ir_2g_parameter;
    TDD_rrm_em_ir_3g_parameter_struct ir_3g_parameter;
    rrm_em_ir_4g_parameter_struct ir_4g_parameter;
} tdd_em_rrm_ir_parameter_status_ind_struct;

typedef struct
{
    kal_bool         is_valid;
    /* The value of rat is the enumeration value
     * UMTS = 0x01,
     * LTE = 0x02
     */
    kal_uint8        rat;
    /* The value of type is the enumeration value
     * NORMAL = 0x00,
     * CSG = 0x01,
     * HYBRID = 0x02
     */
    kal_uint8        type;
	/*freq changed to uint32, instead of EARFCN, since it will be used for (u/e)arfcn*/
    kal_uint32       freq;
    kal_uint16       phy_id;
    kal_int16        strength;
    kal_int16        quality;
    kal_uint32       hit_duration;
    /* The value of hit_criteria is the combination value.
     * IR_RESEL_NO_CRITERIA_HIT = 0x00,
     * IR_RESEL_RANKING_CRITERIA_HIT = 0x01,
     * IR_RESEL_WCDMA_PREFER_HIT = 0x02,
     * IR_RESEL_HIGH_PRIORITY_HIT = 0x10,
     * IR_RESEL_LOW_PRIORITY_HIT  = 0x20,
     * IR_RESEL_ANY_PRIORITY_HIT  = 0x40
     */
    kal_uint8        hit_critiria;
}rrm_em_ir_reselect_status_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rrm_em_ir_reselect_status_struct ir_reselect_status[MAX_NR_RR_EM_IR_RESEL_STATUS];
} em_rrm_ir_reselect_status_ind_struct;

typedef struct
{
    kal_bool          is_valid;
    /* The value of cell_type is the enumeration value
     * NORMAL = 0x00,
     * CSG = 0x01,
     * HYBRID = 0x02
     */
    kal_uint8         cell_type;
    kal_uint16        uarfcn;
    kal_uint16        phy_id;
    kal_int16         strength;
    kal_int16         quailty;
    kal_uint8         rep_value;
    kal_uint8         non_rep_value;
    /* The value of fail_type is the enumeration value:
     * IR_INITIAL_VALUE   = 0x00,
     * NEVER_ALLOWED      = 0x01,
     * PLMN_ID_MISMATCHED = 0x02,
     * LA_NOT_ALLOWED     = 0x03,
     * CELL_BARRED        = 0x04,
     * TEMP_FAILURE       = 0x05,
     * CRITERIA3_NOT_SATISFIED = 0x06,
     * TA_NOT_ALLOWED     = 0x07,
     * CELL_BARRED_FREQ   = 0x08,
     * CELL_BARRED_RESV_OPERATOR = 0x09,
     * CELL_BARRED_RESV_OPERATOR_FREQ = 0x0A,
     * CSG_NOT_ALLOWED = 0x0B
     */
    kal_uint8         fail_type;
}rrm_em_ir_3g_neighbor_meas_status_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                             em_info;
    rrm_em_ir_3g_neighbor_meas_status_struct ir_3g_neighbor_meas_status[MAX_NR_RR_EM_3G_MEAS_STATUS];
} em_rrm_ir_3g_neighbor_meas_status_ind_struct;

typedef struct
{
   kal_bool                     is_valid;
   kal_uint16                   uarfcn;
   kal_bool                     is_meas_ongoing;
   /* When Bit 7 is 1 (i.e., meas_control_utran & 0x80 == 0x80), meas_control_utran
    * is valid. Then Bit 1 is shown whether this UARFCN should be measured.
    */
   kal_uint8                    meas_control_utran;
   /* When priority is equal to 0x2B, it means priority is invalid. */
   kal_int8                     priority;
   /* When thr_high is equal to 0xFF, it means thr_high is invalid. */
   kal_uint8                    thr_high;
   /* When thr_low is equal to 0xFF, it means thr_low is invalid. */
   kal_uint8                    thr_low;
   /* When qrx_lev_min is equal to 0x7F, it means qrx_level_min is invalid. */
   kal_int8                     qrx_lev_min;
} rrm_em_ir_3g_neighbor_meas_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                           em_info;
    kal_uint8                              rrm_state;
    /* The value of ir_resel_mode is the enumeration value
     * IR_RESEL_MODE_RANKING = 0x00,
     * IR_RESEL_MODE_PRIORITY = 0x01,
     */
    kal_uint8                              ir_resel_mode;
    rrm_em_ir_meas_status_enum             rrm_em_ir_meas_status;
    rrm_em_ir_3g_neighbor_meas_info_struct ir_3g_neighbor_meas_info[MAX_NR_RR_EM_3G_MEAS_INFO];
} em_rrm_ir_3g_neighbor_meas_info_ind_struct;

typedef struct
{
    kal_bool          is_valid;
    /* The value of cell_type is the enumeration value
     * NORMAL = 0x00,
     * CSG = 0x01,
     * HYBRID = 0x02
     */
    kal_uint8         cell_type;
    EARFCN            earfcn;
    kal_uint16        pci;
    /* The value of band is the enumeration value
     * INVALID = 0x00,
     * FDD = 0x01,
     * TDD = 0x02
     */
    kal_uint8         band_type;
    kal_int16         rsrp;
    kal_int16         rsrq;
    kal_uint8         rep_value;
    kal_uint8         non_rep_value;
    /* The value of fail_type is the enumeration value:
     * IR_INITIAL_VALUE   = 0x00,
     * NEVER_ALLOWED      = 0x01,
     * PLMN_ID_MISMATCHED = 0x02,
     * LA_NOT_ALLOWED     = 0x03,
     * CELL_BARRED        = 0x04,
     * TEMP_FAILURE       = 0x05,
     * CRITERIA3_NOT_SATISFIED = 0x06,
     * TA_NOT_ALLOWED     = 0x07,
     * CELL_BARRED_FREQ   = 0x08,
     * CELL_BARRED_RESV_OPERATOR = 0x09,
     * CELL_BARRED_RESV_OPERATOR_FREQ = 0x0A,
     * CSG_NOT_ALLOWED = 0x0B
     */
    kal_uint8         fail_type;
}rrm_em_ir_4g_neighbor_meas_status_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rrm_em_ir_4g_neighbor_meas_status_struct ir_4g_neighbor_meas_status[MAX_NR_RR_EM_4G_MEAS_STATUS];
} em_rrm_ir_4g_neighbor_meas_status_ind_struct;

typedef struct
{
   kal_bool                     is_valid;
   EARFCN                       earfcn;
   kal_bool                     is_meas_ongoing;
   /* When Bit 7 is 1 (i.e., meas_control_eutran & 0x80 == 0x80), meas_control_eutran
    * is valid. Then Bit 1 is shown whether this EARFCN should be measured.
    */
   kal_uint8                    meas_control_eutran;
   /* When priority is equal to 0x2B, it means priority is invalid. */
   kal_int8                     priority;
   /* When thr_high is equal to 0xFF, it means thr_high is invalid. */
   kal_uint8                    thr_high;
   /* When thr_low is equal to 0xFF, it means thr_low is invalid. */
   kal_uint8                    thr_low;
   /* When qrx_lev_min is equal to 0x7FFF, it means qrx_level_min is invalid. */
   kal_int16                    qrx_lev_min;
   /* The value of fail_type is the enumeration value:
    * CHECK_INVALID = 0x00, CHECK_RSRQ = 0x01, CHECK_RSRP = 0x02.
    * (1)CHECK_INVALID: qmin, thr_high_q, thr_low_q, qqualmin, and rsrpmin are all invalid.
    * (2)CHECK_RSRQ: qmin is valid,
    *                thr_high_q, thr_low_q, qqualmin, and rsrpmin are all invalid
    * (3)CHECK_RSRP: qmin is invalid,
    *                thr_high_q, thr_low_q, qqualmin, and rsrpmin are all valid
    */
   kal_uint8                    lte_suitability_check;
   /* When qmin is equal to 0x7F, it means qmin is invalid. */
   kal_int8                     qmin;
   /* When thr_high_q is equal to 0xFF, it thr_high_q qmin is invalid. */
   kal_uint8                    thr_high_q;
   /* When thr_low_q is equal to 0xFF, it thr_low_q qmin is invalid. */
   kal_uint8                    thr_low_q;
   /* When qqualmin is equal to 0x7F, it means qqualmin is invalid. */
   kal_int8                     qqualmin;
   /* When rsrpmin is equal to 0x7FFF, it means rsrpmin is invalid. */
   kal_int16                    rsrpmin;
} rrm_em_ir_4g_neighbor_meas_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                           em_info;
    kal_uint8                              rrm_state;
    /* The value of ir_resel_mode is the enumeration value
     * IR_RESEL_MODE_RANKING = 0x00,
     * IR_RESEL_MODE_PRIORITY = 0x01,
     */
    kal_uint8                              ir_resel_mode;
    rrm_em_ir_meas_status_enum             rrm_em_ir_meas_status;
    rrm_em_ir_4g_neighbor_meas_info_struct ir_4g_neighbor_meas_info[MAX_NR_RR_EM_4G_MEAS_INFO];
} em_rrm_ir_4g_neighbor_meas_info_ind_struct;

/***************************** End of RR DM EM Config  ****************************/
/* CC structure */
typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   kal_uint8   cause;	//channel sync cause
   kal_uint8   channel_type;	//channel type
   kal_uint8   channel_mode;	//channel mode
} em_cc_channel_info_ind_struct;

typedef struct
{
  LOCAL_PARA_HDR
  em_info_enum em_info;
	kal_uint8	call_id;	//call id
	kal_uint8	ti;	//transaction identifier
	kal_uint8	state;	//call state
	kal_uint8	aux_state;	//auxiliary state
   	kal_uint8	pi; //progress indicator
	kal_uint16	cause;	//call disconnect cause
	kal_uint8	cause_location;	//cause originating locatioin

    kal_uint8 dir;
    kal_uint8 call_mode;
    l4_addr_bcd_struct call_num;

} em_cc_call_info_ind_struct;

/* CB structure */
typedef struct
{
	kal_uint16	sn;	//serial number
	kal_uint16	mi;	//message identifier
	kal_uint8	dcs;	//data code scheme
	kal_uint8	page;	//current number of this page
	kal_uint8	pages;	//total number of pages
} cb_em_info_struct;

/* SS structure */
typedef struct
{
	kal_uint8	ss_state;	//ciss state
	kal_uint8	ti;	//transaction identifier
	kal_uint8	call_id;	//call id
	kal_uint8	invoke_id;	//invoke id
	kal_uint8	num_invoke;	//number of active invokes
	kal_uint8	op_code;	//operation code
	kal_uint8	ss_code;	//supplementary service code
	kal_uint8	bs_code;	//basic service code
} ss_em_info_struct;

/* MM Enum */

typedef enum
{
    EM_MM_LR_NONE = 0,
    EM_MM_LR_ONGOING,
    EM_MM_LR_SUCCESS,
    EM_MM_LR_SUCCESS_PS_ONLY,
    EM_MM_LR_FAILURE,
    EM_MM_LR_END
}em_mm_lr_status_enum;

typedef enum
{
    EM_MM_NONE = 0,
    EM_MM_REJECTED_BY_NW, //getting rejected by NW
    EM_MM_TIMER_TIME_OUT, //Guard timer timeout
    EM_MM_LOW_LAYER_FAILURE,//low layer failure
    EM_MM_ABORT,//procedure is abort
    EM_MM_AUTH_FAILURE,
    EM_MM_AUTH_REJECTED_BY_NW,
    EM_MM_END
}em_lr_failure_cause_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_bool is_mt_csfb_lu_needed;
    kal_bool is_t3240_exp;
}em_mm_mt_csfb_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_csfb_status_enum csfb_status;
}em_mm_csfb_status_ind_struct;


/* UEM structure */
typedef struct
{
	kal_int32	adc_value;	//battery ADC value
	kal_uint8	battery_level;	//battery level
	kal_uint8	battery_status;	//battery status: battery_status_enum
} uem_em_battery_info;


/* The rr_em_tbf_status_struct is updated whenever TBF is established/reallocated or released. */
typedef struct
{
    kal_uint8   tbf_mode;                // GPRS or EGPRS TBF mode

    /* UL TBF info */
    kal_uint8   ul_tbf_status;           // access/active/inactive
    kal_uint8   ul_rel_cause;            // if applicable
    kal_uint8   ul_ts_allocation;        // timeslot allocation
    kal_uint8   ul_rlc_mode;             // RLC ACK / UNACK mode
    kal_uint8   ul_mac_mode;             // Dynamic allocation / Extended dynamic allocation / Fixed allocation
    /* new created fields */
    kal_uint16  number_rlc_octect;       // RLC requested octect/byte number
    kal_uint8   ul_tfi;
    kal_uint8   ul_granularity;
    kal_uint8   ul_usf;
    kal_uint8   ul_tai;
    kal_uint16  ul_tqi;
    kal_uint16  ul_window_size;          // GPRS: 64, EGPRS 64 ~1024

    /* DL TBF info */
    kal_uint8   dl_tbf_status;           // active/inactive/release pending
    kal_uint8   dl_rel_cause;            // if applicable
    kal_uint8   dl_ts_allocation;        // Ttimeslot allocation
    kal_uint8   dl_rlc_mode;             // RLC ACK / UNACK mode
    kal_uint8   dl_mac_mode;             // Dynamic allocation / Extended dynamic allocation / Fixed allocation
    /* new created fields */
    kal_uint8   dl_tfi;
    kal_uint8   dl_tai;
    kal_uint16  dl_window_size;	         // GPRS: 64, EGPRS 64 ~1024
#ifdef __EGPRS_MODE__
    kal_uint8   dl_out_of_memory;        // EGPRS IR out of memory indication
#endif /* __EGPRS_MODE__ */

    /* Hamann 20140819 : New EM features */
    kal_uint8   mac_mode;                // MAC_IDLE, MAC_PKT_ACCESS, MAC_UL, MAC_DL, MAC_UL_DL, MAC_PS_HO, MAC_NUM_STATES
    kal_uint8   num_dl_ts;               // number of 1s in dl_ts_allocation
    kal_uint8   num_ul_ts;               // number of 1s in ul_ts_allocation

    /*Hamann 20150206 : EM for TBF uplink establishment (TBFULE) */
    kal_uint32 ul_tbf_establishment_count;
    kal_uint8  ul_tbf_establishment_cause;  // be assigned one of value in enum mac_em_ul_tbf_establishment_cause, range from 1 to 54
    kal_uint8  ul_tbf_establishment_type;   // be assigned one of value in enum mac_em_ul_tbf_establishment_type, range from 1 to 5
    kal_uint8  ul_tbf_establishment_status; // be assigned one of value in enum mac_em_ul_tbf_establishment_status, range from 1 to 4
}rr_em_tbf_status_struct;

/* Katie 2013027: em revise */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_tbf_status_struct rr_em_tbf_status;

} em_mac_tbf_info_ind_struct;


/* The new rr_em_blk_info_struct is updated every N (configurable?) block period during TBF.
    N should be adjusted to suitable/smooth display rate. */
typedef struct
{
    /* UL TBF info */
    kal_uint8  ul_coding_scheme;
    kal_uint8  ul_cv;
    kal_uint8  ul_tlli;
    kal_uint16 ul_bsn1;
#ifdef __EGPRS_MODE__
    kal_uint16 ul_bsn2;
    kal_uint8  ul_cps;
    kal_uint8  ul_rsb;
    kal_uint8  ul_spb;
#endif /* __EGPRS_MODE__ */

    /* DL TBF info */
    kal_uint8  dl_c_value_in_rx_level;    /* for both GPRS/EGPRS C value (channel quality) */
    kal_uint8  dl_rxqual;                 /* for GPRS RX QUAL (channel quality) */
    kal_uint8  dl_sign_var;               /* for GPRS signal variance (channel quality) */
    kal_uint8  dl_coding_scheme;
    kal_uint8  dl_fbi;
    kal_uint16 dl_bsn1;
#ifdef __EGPRS_MODE__
    kal_uint16 dl_bsn2;
    kal_uint8  dl_cps;
    kal_uint8  dl_gmsk_mean_bep_lev;	  /* for EGPRS GMSK mean BEP level (channel quality). valid: 0 ~ 31. invalid: 255 */
    kal_uint8  dl_8psk_mean_bep_lev;	  /* for EGPRS 8PSK mean BEP level (channel quality) . valid: 0 ~ 31. invalid: 255 */
    kal_uint8  dl_gmsk_cv_bep_lev;        /* for EGPRS GMSK cv BEP level (channel quality). valid: 0 ~ 7. invalid: 255 */
    kal_uint8  dl_8psk_cv_bep_lev;        /* for EGPRS 8PSK cv BEP level (channel quality) . valid: 0 ~ 7. invalid: 255 */
    kal_uint8  dl_tn_mean_bep_lev[8];	  /* for EGPRS Timeslot Number mean BEP level (channel quality). valid: 0 ~ 31. invalid: 255 */
#endif /* __EGPRS_MODE__ */
    kal_uint8 dl_tn_interference_lev[8]; /* for GPRS/EGPRS Timeslot Number interference (channel quality). valid: 0 ~ 15. invalid: 255 */

    /* Hamann 20140819 : New EM features */
    kal_uint32 received_blocks_in_error;         // molecular of em_block_error_rate
    kal_uint32 total_number_of_received_blocks;  // denominator of em_block_error_rate
    kal_uint32 em_bit_error_rate;                // Bit Error Rate
    kal_uint32 em_block_error_rate;              // Block Error Rate
    kal_uint32 rlc_dl_rx;                        // number of total received RLC DL blocks
    kal_uint32 rlc_ul_tx;                        // number of total transmitted RLC UL blocks
    kal_uint32 rlc_ul_retx;                      // number of re-transmitted RLC UL blocks
    kal_uint32 rlc_ul_retx_rate;                 // retransmission rate of RLC UL blocks
    kal_uint32 rlc_instant_ul_throughput;        // instant throughput (bits/s) of UL TBF
    kal_uint32 rlc_instant_dl_throughput;        // instant throughout (bits/s) of DL TBF
    kal_uint32 coding_scheme_hist[13];           // the same as cs_history[] of rlc_em_info_struct
    kal_uint32 num_blks_for_cs_stats;
    kal_uint32 rlc_average_ul_throughput;        // average throughput (bits/s) of UL TBF
    kal_uint32 rlc_average_dl_throughput;        // average throughput (bits/s) of DL TBF
}rr_em_blk_info_struct;

/* Katie 2013027: em revise */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_blk_info_struct rr_em_blk_info;

} em_mac_blk_info_ind_struct;


/* Poying: 20101210. Remove for EM_MODE. */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#if 0 /* TCM EM mode deprecated @ 2013.04 */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

typedef enum{ // mtk01936 SM EM mode
     LOG_EM_MODE_PDP_INACTIVE, // PDP-INACTIVE
     LOG_EM_MODE_PDP_ACTIVE_PENDING, // PDP-ACTIVE-PENDING
     LOG_EM_MODE_PDP_INACTIVE_PENDING, // PDP-INACTIVE-PENDING
     LOG_EM_MODE_PDP_ACTIVE, // PDP-ACTIVE
     LOG_EM_MODE_PDP_MODIFY_PENDING, // PDP-MODIFY-PENDING
     LOG_EM_MODE_PDP_CONTEXT_ENUM_TOTAL
} sm_em_mode_pdp_context_enum;

typedef enum
{
    LOG_EM_MODE_PRIMARY_CONTEXT,
    LOG_EM_MODE_SECONDARY_CONTEXT,
    LOG_EM_MODE_UNKNOWN_CONTEXT
} sm_em_mode_pdp_context_type_enum;

typedef enum
{
    LOG_EM_MODE_MS_INITIATED = 0,
    LOG_EM_MODE_NW_INITIATED = 1
} sm_em_mode_initiated_enum;

typedef enum
{
     LOG_EM_MODE_IPV4_ADDR_TYPE      = 0X21,
     LOG_EM_MODE_IPV6_ADDR_TYPE      = 0X57,
     LOG_EM_MODE_IPV4V6_ADDR_TYPE    = 0X8D,
     LOG_EM_MODE_PPP_ADDR_TYPE       = 0X01,
     LOG_EM_MODE_OSP_IHOSS_ADDR_TYPE = 0X02,
     LOG_EM_MODE_NULL_PDP_ADDR_TYPE  = 0X03  /* This is added incase if no pdpaddrtype is
                                  * specified */
} sm_em_mode_pdp_addr_type_enum;

/* BCM stands for bearer control mode. */
typedef enum
{
    LOG_EM_MODE_SM_BCM_NULL    = 0x00,  /* Not yet selected by NW. */
    LOG_EM_MODE_SM_BCM_MS_ONLY = 0x01,  /* 24.008, Sec. 10.5.6.3 (PCO). */
    LOG_EM_MODE_SM_BCM_MS_NW   = 0x02   /* 24.008, Sec. 10.5.6.3 (PCO). */
} sm_em_mode_selected_bcm_enum ;

/* ETFT stands for extended TFT format. */
typedef enum
{
    LOG_EM_MODE_SM_ETFT_NOT_SUPPORT = 0x00,  /* 24.008, Sec. 10.5.6.3 (PCO). */
    LOG_EM_MODE_SM_ETFT_SUPPORT     = 0x01   /* 24.008, Sec. 10.5.6.3 (PCO). */
} sm_em_mode_selected_etft_enum ;

typedef struct
{
    /* Requested Qos */
    kal_uint8 delay_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 reliability_class; // possible value are Decimal 1, 2, 3, 4, 5
    kal_uint8 peak_throughput; // possible value are Decimal 1~9
    kal_uint8 precedence_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 mean_throughput; // possible value are Decimal 1~18
    kal_uint8 traffic_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 delivery_order; // possible value are Decimal 1, 2
    kal_uint8 delivery_of_err_sdu; // possible value are Decimal 1, 2, 3
    kal_uint8 max_sdu_size; // max SDU size according to 24.008 Table 10.5.156 encoding
    kal_uint8 max_bitrate_up_lnk; // possible value are Decimal 1~254
    kal_uint8 max_bitrate_down_lnk;  // possible value are Decimal 1~254
    kal_uint8 residual_bit_err_rate; // possible value are Decimal 1~9
    kal_uint8 sdu_err_ratio; // possible value are Decimal 1~7
    kal_uint8 transfer_delay; // possible value are Decimal 1~62
    kal_uint8 traffic_hndl_priority; // possible value are Decimal 1, 2, 3
    kal_uint8 guarntd_bit_rate_up_lnk; // possible value are Decimal 1~254
    kal_uint8 guarntd_bit_rate_down_lnk;  // possible value are Decimal 1~254
    kal_uint8 signalling_indication;
    kal_uint8 source_statistics_descriptor;
    kal_uint8 ext_max_bitrate_down_lnk;
    kal_uint8 ext_guarntd_bit_rate_down_lnk;
    kal_uint8 ext_max_bitrate_up_lnk;
    kal_uint8 ext_guarntd_bit_rate_up_lnk;
    kal_uint8 ext2_max_bitrate_down_lnk;
    kal_uint8 ext2_guarntd_bit_rate_down_lnk;
    kal_uint8 ext2_max_bitrate_up_lnk;
    kal_uint8 ext2_guarntd_bit_rate_up_lnk;



    kal_uint8 human_readable_delay_class; // delay_class_enum
    kal_uint8 human_readable_reliability_class; // sm_readable_reliability_class_enum
    kal_uint8 human_readable_peak_throughput; // sm_readable_peak_throughput_class_enum
    kal_uint8 human_readable_precedence_class; // sm_readable_precedence_class_enum
    kal_uint8 human_readable_mean_throughput; // sm_readable_mean_throughput_enum
    kal_uint8 human_readable_traffic_class; // sm_readable_traffic_class_enum
    kal_uint8 human_readable_delivery_order; // sm_readable_delivery_order_enum
    kal_uint8 human_readable_delivery_of_err_sdu; // sm_readable_delivery_of_err_sdu_enum
    kal_uint16 human_readable_max_sdu_size;
    kal_uint32 human_readable_max_bitrate_up_lnk;
    kal_uint32 human_readable_max_bitrate_down_lnk;
    kal_uint8 human_readable_residual_bit_err_rate; // sm_readable_residual_bit_error_rate_enum
    kal_uint8 human_readable_sdu_err_ratio; // sm_readable_sdu_err_ratio_enum
    kal_uint16 human_readable_transfer_delay;
    kal_uint8 human_readable_traffic_hndl_priority; // sm_readable_traffic_hndl_priority_enum
    kal_uint32 human_readable_guarntd_bit_rate_up_lnk;
    kal_uint32 human_readable_guarntd_bit_rate_down_lnk;
    kal_uint8 human_readable_signalling_indication; // sm_readable_signaling_indication_enum
    kal_uint8 human_readable_source_statistics_descriptor; // sm_readable_source_statistics_descriptor_enum
    kal_uint32 human_readable_ext_max_bitrate_down_lnk;
    kal_uint32 human_readable_ext_guarntd_bit_rate_down_lnk;
    kal_uint32 human_readable_ext_max_bitrate_up_lnk;
    kal_uint32 human_readable_ext_guarntd_bit_rate_up_lnk;
    kal_uint32 human_readable_ext2_max_bitrate_down_lnk;
    kal_uint32 human_readable_ext2_guarntd_bit_rate_down_lnk;
    kal_uint32 human_readable_ext2_max_bitrate_up_lnk;
    kal_uint32 human_readable_ext2_guarntd_bit_rate_up_lnk;

} sm_em_qos_struct;


typedef struct
{
   /*
     * MTK Question: what is the index mean? Does it mean the PDP array index?
     * Response: Yes
     */
   kal_uint8   pdp_index;

   kal_uint8   nsapi; // NSAPI
   kal_uint8    ti_value;

   /*
     * MTK Question: How many states do you need to show? Just inactive & active?
     * Response:
     * PDP status is like below
     * PDP-INACTIVE
     * PDP-ACTIVE_-PENDING
     * PDP-INACTIVE-PENDING
     * PDP-ACTIVE
     * PDP-MODIFY-PENDING
     */

   sm_em_mode_pdp_context_enum   pdp_context_status;
   sm_em_mode_pdp_context_type_enum context_type;

   sm_em_mode_initiated_enum   initiated_by;

   sm_em_mode_pdp_addr_type_enum   pdp_addr_type;

   kal_uint8   ip[MAXIMUM_POSSIBLE_ADDR_LEN]; // IPv4 address or IPv6 address(not ready)
   //kal_uint8   dns1[4];
   //kal_uint8   dns2[4];

   kal_uint16 sdu_size; // Max SDU size in Bytes

   kal_uint8   apn[100];

   /*
     * MTK Question: In our current design, we clear the cause value after PDP deactivation, do you need to see the previous deactivation cause?
     * Response:
     * If MS work normal, just see the previos deactivaion cause.
     * If MS send PDP act msg to Network, MS recevie PDP reject msg from Network, then we need to see reject casue.
     */
   kal_uint8   sm_cause;          //  if applicable

   /*
     * MTK Question: Is this the neg QoS? According to 24.008 Table 10.5.156?
     * LG Response: Yes
     */

   sm_em_qos_struct em_requested_qos;
   sm_em_qos_struct em_minimum_qos;
   sm_em_qos_struct em_negotiated_qos;

   kal_uint8    pkt_flow_id;
   kal_uint8    radio_priority;
   kal_uint16   req_n201u;

   #ifdef __REL7__
   sm_em_mode_selected_bcm_enum     selected_bcm ;
   #endif // __REL7__

   sm_em_mode_selected_etft_enum    selected_etft ;

} sm_em_pdp_info_struct;

/* Poying: Need to define enum so Catcher can get from database */
typedef enum{
      SM_EM_MAX_PDP_SUPPORT = 11 // nsapi 5~15
} sm_em_max_pdp_support_enum;


typedef struct{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   kal_uint8    num_of_active_pdp_context;
   sm_em_pdp_info_struct pdp; // nsapi 5~15
} em_sm_info_struct;

typedef em_sm_info_struct em_sm_nsapi5_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi6_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi7_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi8_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi9_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi10_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi11_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi12_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi13_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi14_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi15_status_ind_struct;

/* TCM EM Mode */
typedef enum
{
    LOG_EM_MODE_TCM_PDP_INACTIVE,
    LOG_EM_MODE_TCM_PDP_ACTIVE_PENDING,
    LOG_EM_MODE_TCM_PDP_ACTIVE,
    LOG_EM_MODE_TCM_PDP_INACTIVE_PENDING,
    LOG_EM_MODE_TCM_PDP_CONTEXT_ENUM_TOTAL
} tcm_em_mode_pdp_context_enum;

typedef enum
{
    LOG_EM_MODE_TCM_PRIMARY_CONTEXT,
    LOG_EM_MODE_TCM_SECONDARY_CONTEXT,
    LOG_EM_MODE_TCM_UNKNOWN_CONTEXT
} tcm_em_mode_pdp_context_type_enum;

typedef enum
{
    LOG_EM_MODE_TCM_MS_INITIATED = 0,
    LOG_EM_MODE_TCM_NW_INITIATED = 1
} tcm_em_mode_initiated_enum;

typedef enum
{
    LOG_EM_MODE_TCM_IPV4_ADDR_TYPE      = 0X21,
    LOG_EM_MODE_TCM_IPV6_ADDR_TYPE      = 0X57,
    LOG_EM_MODE_TCM_IPV4V6_ADDR_TYPE    = 0X8D,
    LOG_EM_MODE_TCM_PPP_ADDR_TYPE       = 0X01,
    LOG_EM_MODE_TCM_OSP_IHOSS_ADDR_TYPE = 0X02,
    LOG_EM_MODE_TCM_NULL_PDP_ADDR_TYPE  = 0X03  /* This is added incase if no pdpaddrtype is
                                  * specified */
} tcm_em_mode_pdp_addr_type_enum;

typedef struct
{
    /* Requested Qos */
    kal_uint8 delay_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 reliability_class; // possible value are Decimal 1, 2, 3, 4, 5
    kal_uint8 peak_throughput; // possible value are Decimal 1~9
    kal_uint8 precedence_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 mean_throughput; // possible value are Decimal 1~18
    kal_uint8 traffic_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 delivery_order; // possible value are Decimal 1, 2
    kal_uint8 delivery_of_err_sdu; // possible value are Decimal 1, 2, 3
    kal_uint8 max_sdu_size; // max SDU size according to 24.008 Table 10.5.156 encoding
    kal_uint8 max_bitrate_up_lnk; // possible value are Decimal 1~254
    kal_uint8 max_bitrate_down_lnk;  // possible value are Decimal 1~254
    kal_uint8 residual_bit_err_rate; // possible value are Decimal 1~9
    kal_uint8 sdu_err_ratio; // possible value are Decimal 1~7
    kal_uint8 transfer_delay; // possible value are Decimal 1~62
    kal_uint8 traffic_hndl_priority; // possible value are Decimal 1, 2, 3
    kal_uint8 guarntd_bit_rate_up_lnk; // possible value are Decimal 1~254
    kal_uint8 guarntd_bit_rate_down_lnk;  // possible value are Decimal 1~254
    kal_uint8 signalling_indication;
    kal_uint8 source_statistics_descriptor;
    kal_uint8 ext_max_bitrate_down_lnk;
    kal_uint8 ext_guarntd_bit_rate_down_lnk;
    kal_uint8 ext_max_bitrate_up_lnk;
    kal_uint8 ext_guarntd_bit_rate_up_lnk;
    kal_uint8 ext2_max_bitrate_down_lnk;
    kal_uint8 ext2_guarntd_bit_rate_down_lnk;
    kal_uint8 ext2_max_bitrate_up_lnk;
    kal_uint8 ext2_guarntd_bit_rate_up_lnk;

    kal_uint8 human_readable_delay_class; // delay_class_enum
    kal_uint8 human_readable_reliability_class; // sm_readable_reliability_class_enum
    kal_uint8 human_readable_peak_throughput; // sm_readable_peak_throughput_class_enum
    kal_uint8 human_readable_precedence_class; // sm_readable_precedence_class_enum
    kal_uint8 human_readable_mean_throughput; // sm_readable_mean_throughput_enum
    kal_uint8 human_readable_traffic_class; // sm_readable_traffic_class_enum
    kal_uint8 human_readable_delivery_order; // sm_readable_delivery_order_enum
    kal_uint8 human_readable_delivery_of_err_sdu; // sm_readable_delivery_of_err_sdu_enum
    kal_uint16 human_readable_max_sdu_size;
    kal_uint32 human_readable_max_bitrate_up_lnk;
    kal_uint32 human_readable_max_bitrate_down_lnk;
    kal_uint8 human_readable_residual_bit_err_rate; // sm_readable_residual_bit_error_rate_enum
    kal_uint8 human_readable_sdu_err_ratio; // sm_readable_sdu_err_ratio_enum
    kal_uint16 human_readable_transfer_delay;
    kal_uint8 human_readable_traffic_hndl_priority; // sm_readable_traffic_hndl_priority_enum
    kal_uint32 human_readable_guarntd_bit_rate_up_lnk;
    kal_uint32 human_readable_guarntd_bit_rate_down_lnk;
    kal_uint8 human_readable_signalling_indication; // sm_readable_signaling_indication_enum
    kal_uint8 human_readable_source_statistics_descriptor; // sm_readable_source_statistics_descriptor_enum
    
} tcm_em_qos_struct;

typedef struct
{
    kal_uint8   context_id;
    kal_uint8   qci;
    kal_uint8   max_bitrate_up_lnk;
    kal_uint8   max_bitrate_down_lnk;
    kal_uint8   ext_max_bitrate_up_lnk;
    kal_uint8   ext_max_bitrate_down_lnk;
    kal_uint8   ext2_max_bitrate_up_lnk;
    kal_uint8   ext2_max_bitrate_down_lnk;

    kal_uint8   guarntd_bit_rate_up_lnk;
    kal_uint8   guarntd_bit_rate_down_lnk;
    kal_uint8   ext_guarntd_bit_rate_up_lnk;
    kal_uint8   ext_guarntd_bit_rate_down_lnk;
    kal_uint8   ext2_guarntd_bit_rate_up_lnk;
    kal_uint8   ext2_guarntd_bit_rate_down_lnk;

    kal_uint32  human_readable_max_bitrate_up_lnk;
    kal_uint32  human_readable_max_bitrate_down_lnk;
    kal_uint32  human_readable_guarntd_bit_rate_up_lnk;
    kal_uint32  human_readable_guarntd_bit_rate_down_lnk;
    
} tcm_em_eps_qos_struct;


typedef struct
{

   kal_uint8   cid;
   kal_uint8   nsapi; // NSAPI

   tcm_em_mode_pdp_context_enum   pdp_context_status;
   tcm_em_mode_pdp_context_type_enum context_type;

   tcm_em_mode_initiated_enum   initiated_by;
   tcm_em_mode_initiated_enum   termination_initiated_by;

   tcm_em_mode_pdp_addr_type_enum   user_defined_pdp_type;
   tcm_em_mode_pdp_addr_type_enum   nw_applied_pdp_type;   
     
   kal_uint8 user_defined_pdp_addr[IPV4V6_ADDR_LEN] ;
   kal_uint8 nw_applied_pdp_addr[IPV4V6_ADDR_LEN] ;

   kal_bool dns_present;
   kal_uint8 dns[MAX_PDP_ADDR_LEN];
   kal_bool dns2_present;
   kal_uint8 dns2[MAX_PDP_ADDR_LEN];

   kal_bool ipv6_dns1_present;
   kal_uint8 ipv6_dns1[IPV6_ADDR_LEN];
   kal_bool ipv6_dns2_present;
   kal_uint8 ipv6_dns2[IPV6_ADDR_LEN];
   
   kal_uint8 user_defined_apn_len;
   kal_uint8 user_defined_apn[MAX_APN_LEN];
   
   kal_uint8 nw_applied_apn_len;
   kal_uint8 nw_applied_apn[MAX_APN_LEN];

   kal_uint8 primary_context_id;
   ps_cause_enum cause;

   //kal_uint16 sdu_size; // Max SDU size in Bytes

   //kal_uint8   apn[100];

   tcm_em_qos_struct em_requested_qos;
   tcm_em_qos_struct em_negotiated_qos;

   tcm_em_eps_qos_struct em_eps_req_qos;
   tcm_em_eps_qos_struct em_eps_neg_qos;

   kal_uint32   dl_apn_ambr;
   kal_uint32   ul_apn_ambr;

   kal_uint8    sapi;

} tcm_em_cid_info_struct;

typedef struct{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   tcm_em_cid_info_struct pdp;
} em_tcm_info_ind_struct;



/* Max : 20130415 Remove for EM_MODE. */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

typedef struct
{
	kal_uint32	num_reasm_failure;
} sndcp_em_info_struct;

typedef struct
{
    kal_uint8   sapi_id;
    kal_uint16  n201_ui;
    kal_uint16  n201_i;
    kal_uint16  kU;
    kal_uint16  kD;
    kal_uint32	num_fcs_error;
} llc_sapi_info_struct ;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum        em_info;
    llc_sapi_info_struct  sapi_info[2];
    kal_uint8                cipher_algo;
} em_llc_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 is_higher_pri_plmn_srch; /* indicate that if the higher priority PLMN search is performing */
    kal_uint8 hp_timeout_timer; /* higher priority PLMN search timer (6 mins per unit) */
    kal_uint8 hp_count_down_timer; /* higher priority PLMN search count down timer (6 mins per unit) */
    kal_uint8 rplmn[6]; /* RPLMN */
    kal_uint8 eq_plmn[5][6]; /* 1~5 equivalent PLMNs (6 digits for each PLMN ID) */
    kal_uint8 forbid_plmn[4][6]; /* 1~4 forbidden PLMNs (6 digits for each PLMN ID) */
#if defined(__WISDOM_EM__) || defined(__ADVANCED_EM__)
    kal_uint8 hplmn[6];
    kal_uint8 previous_rplmn[6];
    kal_uint8 requested_plmn[6];
    kal_uint8 plmn_sel_mode;
#endif
    kal_uint8 mnc_length;

    /* Gibran 20090525: Added for Network Sharing multiple PLMN and DSAC */
    /* #define MAX_NUM_MULTI_PLMN    6 */
    kal_uint8 multi_plmn_count;    
    em_multi_plmn_struct multi_plmn_id[6];
} em_nwsel_plmn_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
	em_info_enum em_info;
    kal_uint8 rplmn[6];
    kal_uint8 plmn_sel_mode;
	kal_uint8 loss_rat;
} em_nwsel_plmn_loss_info_ind_struct;  //add for auto test tool

typedef struct
{
    LOCAL_PARA_HDR
	em_info_enum em_info;	
    kal_uint8 result;
    kal_uint8 plmn_sel_mode;
	kal_uint8 search_rat;
} em_nwsel_plmn_search_cnf_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    /* TS 24.301 subclause 4.5
     * As an implementation option, the UE may start a timer for enabling E-UTRA  when the UE's attach attempt 
     * counter or tracking area updating attempt counter reaches 5 and the UE disables E-UTRA capability for cases 
     * described in subclauses 5.5.1.3.4.3, 5.5.1.3.6, 5.5.3.3.4.3 and 5.5.3.3.6. 
     */
    kal_uint32 eutran_disable_timer_value; /* seconds */
    
    /* TS 23.122 subclause 3.1
     * If MS that has disabled its E-UTRA capability re-enables it when PLMN selection is performed, then the MS 
     * should, for duration of timer TD, memorize the PLMNs where E-UTRA capability was disabled as PLMNs where voice
     * service was not possible.
     */
    kal_uint32 eutran_disable_td_timer_value; /* seconds */
    
    /* Clear Codes Data requirement - Telcel (Mexico) 
     * Clear codes 23 & 33: ESM reject cause #29 and #33 happens 3 times, then disable EUTRAN for 2hrs. 
     * After 2 hrs, enable EUTRAN and search 4G.
     */
    kal_uint32 eutran_disable_esm_timer_value; /* seconds */
    
    /* In FT experience, UE will be rejected with cause #15 in 4G if 23G only SIM is used.
     * In the end, even UE can't camp on 4G cell, AS may measure LTE cell frequently 
     * and fail the power consumption test. For power saving purpose, if UE is rejected with #15
     * in HPLMN, disable EUTRAN in HPLMN for 12hr
     *
     * For CHT 3G only SIM card, UE may also be reject with cause #13 in 4G.
     */
    kal_uint32 eutran_disable_for_rej_in_hplmn_timer_value; /* seconds */
    
    /* When UE loss coverage or in limited service state
     * UE will start recovery timer and perform plmn search after timer expiry
     */
    kal_uint32 recovery_timer_value; /* seconds */
    
    /* When UE registers to VPLMN, UE will start high priority plmn search timer.
     * UE will attempt to perform plmn search for higher priority plmn after timer expiry
     */
    kal_uint32 high_prio_search_timer_value; /* seconds */

    /* Reset abnormal LAI list after timer expiry */
    kal_uint32 retry_abnormal_lai_timer_value; /* seconds */

    /* Reset abnormal RAI list after timer expiry */
    kal_uint32 retry_abnormal_rai_timer_value; /* seconds */
} em_nwsel_timer_info_ind_struct;

#ifdef __UMTS_RAT__    //For MAUI, MONZA2G exclude 3G
/**
 * Remus 20080626
 * Added MEME EM info in Catcher
 */

typedef enum
{
    MEME_EM_EVENT_TYPE1_INVALID,
    MEME_EM_EVENT_TYPE1_E1A,
    MEME_EM_EVENT_TYPE1_E1B,
    MEME_EM_EVENT_TYPE1_E1C,
    MEME_EM_EVENT_TYPE1_E1D,
    MEME_EM_EVENT_TYPE1_E1E,
    MEME_EM_EVENT_TYPE1_E1F,

    MEME_EM_EVENT_TYPE1_E1G,
    MEME_EM_EVENT_TYPE1_E1H,
    MEME_EM_EVENT_TYPE1_E1I,

    MEME_EM_EVENT_TYPE1_E1J
} MemeEmInfoEventType1;


typedef enum
{
    MEME_EM_EVENT_TYPE2_INVALID,
    MEME_EM_EVENT_TYPE2_E2A,
    MEME_EM_EVENT_TYPE2_E2B,
    MEME_EM_EVENT_TYPE2_E2C,
    MEME_EM_EVENT_TYPE2_E2D,
    MEME_EM_EVENT_TYPE2_E2E,
    MEME_EM_EVENT_TYPE2_E2F
} MemeEmInfoEventType2;

typedef enum
{
    MEME_EM_EVENT_TYPE3_INVALID,
    MEME_EM_EVENT_TYPE3_E3A,
    MEME_EM_EVENT_TYPE3_E3B,
    MEME_EM_EVENT_TYPE3_E3C,
    MEME_EM_EVENT_TYPE3_E3D
} MemeEmInfoEventType3;

typedef enum
{
    MEME_EM_EVENT_INVALID,
    // E1x: 
    // E2x: 
    // E3x: 
    MEME_EM_EVENT_E3A,
    MEME_EM_EVENT_E3B,
    MEME_EM_EVENT_E3C,
    MEME_EM_EVENT_E3D
} MemeEmInfoEvent;



typedef enum
{
    MEME_EM_MEAS_QTY_INVALID,
    MEME_EM_MEAS_QTY_RSCP,
    MEME_EM_MEAS_QTY_ECN0,
    MEME_EM_MEAS_QTY_PATHLOSS
} MemeEmMeasQty;

typedef enum
{
    MEME_EM_MEAS_QTY_FOR_OTHER_RAT_INVALID,
    MEME_EM_MEAS_QTY_GSM_RSSI,
    MEME_EM_MEAS_QTY_EUTRA_RSRP,
    MEME_EM_MEAS_QTY_EUTRA_RSRQ
} MemeEmMeasQtyForOtherRAT;


typedef struct {
    kal_uint8   MeasId;
    MemeEmInfoEventType1   EventType;   // 1: 1B, 2: 1B, 3: 1C, 4: 1D, 5: 1E, 6: 1F, 10: 1J
    MemeEmMeasQty MeasQty;              //  1: RSCP, 2: EcN0, 3: pathloss
    kal_uint8   fc;
    kal_int16   Threshold;
    kal_int16   W;                      // FDD only
    kal_int16   ReportingRange;         // FDD only
    kal_int16   Hystersis;              //unit: 0.5dB, real_value = Hystersis/2
    kal_uint16  TimeToTrigger;
} event_1_struct;

typedef struct {
    kal_uint8   MeasId;
    MemeEmInfoEventType2   EventType;   // 1: 2A, 2: 2B, 3: 2C, 4: 2D, 5: 2E, 6: 2F
    MemeEmMeasQty MeasQty;              //  1: RSCP, 2: EcN0, 3: pathloss
    kal_uint8   fc;
    kal_int16   UsedT;                  // threshold for used freq
    kal_int16   nonUsedT;               // threshold for non-used freq
    kal_int16   UsedW;                  // FDD only
    kal_int16   nonUsedW;               // FDD only
    kal_int16   Hystersis;              //unit: 0.5dB, real_value = Hystersis/2
    kal_uint16  TimeToTrigger;
} event_2_struct;

typedef struct {
    kal_uint8   MeasId;                 // 0: invalid, range 1~32
    MemeEmInfoEventType3   EventType;   // 0: invalid, 1: 3A, 2: 3B, 3: 3C, 4: 3D
    MemeEmMeasQty MeasQty;              // 0: invalid, 1: RSCP, 2: EcN0, 3: pathloss
    MemeEmMeasQtyForOtherRAT MeasQtyOtherRAT;   // 0: invalid, 1: GSM_RSSI, 2: EUTRA_RSRP, 3: EUTRA_RSRQ
    kal_uint8   fc_OtherSys;                     // 0xFF: invalid, range 0~ 19, Note: for other RAT (GSM or LTE)
    kal_uint8   fc_OwnSys;              // 0xFF: invalid, range 0~ 19, Note: for UMTS RAT
    kal_int16   ThresholdOwnSystem;      // 0xFFFF: invalid, step unit: 0.25 dB, real_value = ThresholdOwnSystem/4
    kal_int16   ThresholdOtherSystem;    // 0xFFFF: invalid, step unit: 0.25 dB, real_value = ThresholdOtherSystem/4

    kal_uint8   W;                      // 0xFF: invalid, FDD only, 0~2 with 0.1 step

    kal_uint8   Hystersis;              // 0xFF: invalid, step unit: 0.5dB, real_value = Hystersis/2, range 0~7.5
    kal_uint16  TimeToTrigger;          // 0xFFFF: invalid, range 0~5000
} event_3_struct;

typedef struct {
    kal_uint8   MeasId;                 // 0: invalid, range 1~32
    MemeEmInfoEvent   EventType;        // 0: invalid, 31: 3A, 32: 3B, 33: 3C, 34: 3D
} report_struct;


typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_1_struct em_event_info[7];
} tdd_em_meme_event_type_1_parameter_info_ind_struct, fdd_em_meme_event_type_1_parameter_info_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_2_struct em_event_info[6];
} tdd_em_meme_event_type_2_parameter_info_ind_struct, fdd_em_meme_event_type_2_parameter_info_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_3_struct em_event_info[4];
} tdd_em_meme_event_type_3_parameter_info_ind_struct, fdd_em_meme_event_type_3_parameter_info_ind_struct;

typedef struct {
    kal_uint8 TrCHId;
    kal_uint32 TotalCRC;
    kal_uint32 BadCRC;
} trch_bler_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_trch;
    trch_bler_struct TrCHBler[8];
} em_meme_periodic_bler_report_ind;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    report_struct em_report_info;
} fdd_em_meme_report_info_ind_struct, tdd_em_meme_report_info_ind_struct;







typedef struct
{
    kal_uint16 UARFCN;
    kal_uint16 CELLPARAID;
    kal_int32 RSCP; /* value = RSCP/4096 */
    kal_int32 ISCP[6]; /* value = ISCP/4096, timeslot 1 - 6 */
    kal_bool isServingCell;/* if it is KAL_TRUE, MMI or Catcher display the cell in Red*/
} TDD_meme_umts_cell_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16 workingFreq;
    kal_uint8 num_cells;
    kal_uint8 supportBand; //bitmap: bit0-A Band, bit1-B Band, bit2-C Band, bit3-D Band, bit4-E Band, bit5-F Band
    kal_uint8 sinr; // 0~254, 0xff means this value is invalid
    TDD_meme_umts_cell_struct umts_cell_list[64];
} tdd_em_meme_dch_umts_cell_info_ind_struct;

typedef struct uas_cell_plmn_id
{
    kal_uint16              mcc;
    kal_uint16              mnc;
} uas_cell_plmn_id;

/* BIT STRING URA-Identity */
typedef struct meme_umts_ura_identity
{
   kal_uint8                numBits;
   kal_uint8                stringData[2];
}
meme_umts_ura_identity;

typedef enum {
    MEME_EM_ACTIVE_SET,
    MEME_EM_INTRA_MONITORED,
    MEME_EM_INTRA_DETECTED,
    MEME_EM_INTER_MONITORED,    
    MEME_EM_INVALID         = 0xff
} meme_em_umts_cell_type;

typedef struct
{
    kal_uint16              UARFCN;
    kal_uint16              PSC;    // FDD only
    kal_int32               RSCP;   /* value = RSCP/4096 */
    kal_int32               ECN0;   /* value = ECN0/4096 */ // FDD only
    meme_em_umts_cell_type  cell_type;
    kal_uint8               Band;
    kal_int32               RSSI;
    kal_uint32              Cell_identity;

    kal_uint8               validity;
#define MEME_UMTS_CELL_INFO_LAC_VALID 0x01
#define MEME_UMTS_CELL_INFO_RAC_VALID 0x02
#define MEME_UMTS_CELL_INFO_CID_VALID 0x04

    /* Extended Cell Info */
    kal_uint8               num_plmn_id;
    uas_cell_plmn_id        plmn_id_list[6];
    kal_uint16              lac;
    kal_uint8               rac;
    kal_uint8               num_ura_id;
    meme_umts_ura_identity  uraIdentity[8];
} FDD_meme_umts_cell_struct;

typedef struct
{
    kal_uint8 frequency_band;
    kal_uint16 arfcn;
    kal_uint8 bsic;
    kal_int16 rssi; /* value = rssi /4 */
    kal_bool verified;
} meme_gsm_cell_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_cells;
    meme_gsm_cell_struct gsm_cell_list[6];
} fdd_em_meme_dch_gsm_cell_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_cells;
    meme_gsm_cell_struct gsm_cell_list[6];
} tdd_em_meme_dch_gsm_cell_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_bool with_2g_neighbor;
    kal_bool is_gsm_ncell_meas_ongoing;
} tdd_em_meme_gsm_ncell_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_bool with_4g_neighbor;
    kal_bool is_lte_ncell_meas_ongoing;
} tdd_em_meme_lte_ncell_info_ind_struct;


/* 20101006
 * H-Serving cell information is added into EM */
typedef struct
{
   kal_uint16 HSDSCH_Serving_UARFCN;     /* uarfcn of HS-DSCH serving cell, 0xFFFF means invalid */
   kal_uint16 HSDSCH_Serving_PSC;        /* psc of HS-DSCH serving cell, 0xFFFF means invalid */
   kal_uint16 EDCH_Serving_UARFCN;       /* uarfcn of E-DCH serving cell, 0xFFFF means invalid */
   kal_uint16 EDCH_Serving_PSC;          /* psc of E-DCH serving cell, 0xFFFF means invalid */
} meme_em_info_h_serving_cell_ind_struct;

/**
 * Gibran 20061228
 * Added Cell Status for EM in Catcher
 * Gibran 20080627
 * Modified CSCE structure for EM in Catcher/MMI.
 */
typedef enum
{
   EM_3G_IN_SERV_ABOVE_S,  /* green button */
   EM_3G_IN_SERV_BELOW_S,  /* yellow button */
   EM_3G_OUT_OF_SERV,      /* orange button */
   EM_3G_NO_SERV,          /* red button */
   EM_3G_NO_CHANGE         /* no change */
} em_3g_service_status_enum;

typedef enum
{
   EM_3G_RRC_IDLE,
   EM_3G_RRC_CELL_FACH,
   EM_3G_RRC_CELL_PCH,
   EM_3G_RRC_URA_PCH,
   EM_3G_RRC_CELL_DCH,
   EM_3G_RRC_INACTIVE,
   EM_3G_RRC_NO_CHANGE,
   // RRCE R7 new states
   EM_3G_RRC_CELL_FACH_HSDPA,
   EM_3G_RRC_CELL_PCH_HSDPA_DATA,
   EM_3G_RRC_CELL_PCH_HSDPA_PAGING,
   EM_3G_RRC_URA_PCH_HSDPA_PAGING,
   // RRCE R8 new states
   EM_3G_RRC_CELL_FACH_HSUPA,
   EM_3G_RRC_CELL_PCH_HSUPA_DATA,
   EM_3G_RRC_CELL_PCH_READYtoHSPA
} em_3g_rrc_state_enum;

typedef enum
{
   EM_3G_PLMNSEARCH_NO_CHANGE,
   EM_3G_PLMNSEARCH_ANY_START,
   EM_3G_PLMNSEARCH_GIVEN_START,
   EM_3G_PLMNSEARCH_ANY_SUCCESS,
   EM_3G_PLMNSEARCH_ANY_NO_CELL,
   EM_3G_PLMNSEARCH_GIVEN_SUCCESS,
   EM_3G_PLMNSEARCH_GIVEN_NO_CELL,
   EM_3G_PLMNSEARCH_ABORT
} em_3g_rrc_plmn_search_status_enum;

typedef struct
{
   em_3g_service_status_enum  service_status;               //MMI
   em_3g_rrc_state_enum      umts_rrc_state;                //MMI
   kal_uint16        uarfcn_DL;                             //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change. */
   kal_uint16        psc;                                   //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change.*/
   
   em_3g_rrc_plmn_search_status_enum plmn_search_status;
} fdd_uas_em_3g_status;

typedef struct
{
   em_3g_service_status_enum  service_status;               //MMI
   em_3g_rrc_state_enum      umts_rrc_state;                //MMI
   kal_uint16        uarfcn_DL;                             //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change. */
   kal_uint16        psc;                                   //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change.*/

   kal_uint16        workingFreq;                           //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change. */
   kal_uint16        uppch_Position;                       //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change.*/

   kal_uint16    repetitionPeriod_dl;
   /* if 0xFFFF means Invalid, set to empty; 0xFFFE means No Change. */
   kal_uint16    repetitionLength_dl;
   /* if 0xFFFF means Invalid, set to empty; 0xFFFE means No Change. */
   kal_uint16    repetitionPeriod_ul;
   /* if 0xFFFF means Invalid, set to empty; 0xFFFE means No Change. */
   kal_uint16    repetitionLength_ul;
   /* if 0xFFFF means Invalid, set to empty; 0xFFFE means No Change. */

} tdd_uas_em_3g_status;


typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   fdd_uas_em_3g_status  uas_3g_general_status;
} fdd_em_urr_3g_general_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

    tdd_uas_em_3g_status  uas_3g_general_status;
} tdd_em_urr_3g_general_status_ind_struct;

#ifdef __UMTS_TDD128_MODE__
typedef enum
{
   INTRA_TR_HHO,
   INTRA_TM_HHO,
   INTER_TR_HHO,
   INTER_TM_HHO,
   INTRA_TR_BHO,
   INTRA_TM_BHO,
   INTER_TR_BHO,
   INTER_TM_BHO,
   HHO_REVERT,
   BHO_REVERT
} em_3g_handover_type_enum; /* the enum name should be shown in MMI */

typedef struct
{
   kal_uint16   primary_uarfcn_DL;
   kal_uint16   working_uarfcn;
   kal_uint16   physicalCellId;

}em_3g_cell_info;

typedef struct
{
   em_3g_handover_type_enum  service_status;
   em_3g_cell_info           old_cell_info;
   em_3g_cell_info           target_cell_info;
} em_uas_handover_status;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   em_uas_handover_status  uas_3g_general_status;
} em_uas_3g_tdd128_handover_sequence_ind_struct;

#endif /*__UMTS_TDD128_MODE__*/


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
} em_rrce_3g4_redir_event_ind_struct;


typedef enum
{
    TDD_RRC_CONN_NULL,
    TDD_RRC_CONN_EST_INIT,/*when nas send est_req*/ 	
    TDD_RRC_CONN_ATMPTING,/*when send rrcConnReq to ADR*/
    TDD_RRC_CONN_EST_FAIL,
    TDD_RRC_CONN_ESTED, /*when send est_cnf(success)to NAS*/    
    TDD_RRC_CONN_REL,    
} tdd_em_rrc_conn_status_enum;

typedef enum
{
    /*casue for est fail*/
	TDD_RRC_CAUSE_EST_FAIL_REJ_CONGESTION = 0,
    TDD_RRC_CAUSE_EST_FAIL_START = TDD_RRC_CAUSE_EST_FAIL_REJ_CONGESTION,
    TDD_RRC_CAUSE_EST_FAIL_REJ_UNSPECIFIED,
    TDD_RRC_CAUSE_EST_FAIL_RA_FAIL, 
    TDD_RRC_CAUSE_EST_FAIL_NO_SETUP,	   
    TDD_RRC_CAUSE_EST_FAIL_AC_BARRED,
    TDD_RRC_CAUSE_EST_FAIL_T312_EXP,
    TDD_RRC_CAUSE_EST_FAIL_ABORTED,
    TDD_RRC_CAUSE_EST_FAIL_GIBI_TAG_MISMATCH,
    TDD_RRC_CAUSE_EST_FAIL_OTHER,
    
    /*cause for conn rel*/
    TDD_RRC_CAUSE_REL_START = 20,
    TDD_RRC_CAUSE_REL_UTRAN_NORMAL_EVENT = TDD_RRC_CAUSE_REL_START,
    TDD_RRC_CAUSE_REL_UTRAN_UNSPECIFIED,
    TDD_RRC_CAUSE_REL_UTRAN_PRE_EMPTIVE_RELEASE,
    TDD_RRC_CAUSE_REL_UTRAN_CONGESTION,
    TDD_RRC_CAUSE_REL_UTRAN_REEST_REJECT,
    TDD_RRC_CAUSE_REL_UTRAN_DIRECTED_SIGNALING_CONN_REEST,
    TDD_RRC_CAUSE_REL_UTRAN_USER_INACTIVITY,
    TDD_RRC_CAUSE_REL_CONN_INACTIVITY,
    TDD_RRC_CAUSE_REL_RLF,
    TDD_RRC_CAUSE_REL_SECURITY_CAP_MISMATCH,
    TDD_RRC_CAUSE_REL_NAS_AUTH_FAIL,
    TDD_RRC_CAUSE_REL_CSCE_REL_CH_REQ,
    TDD_RRC_CAUSE_REL_RATCM_DEACTIBATE,
    
    /*common cause*/
	TDD_RRC_CAUSE_NO_SERVICE = 254,
	TDD_RRC_CAUSE_NULL = 255,
} tdd_em_rrc_cause_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum  em_info;
    
    tdd_em_rrc_conn_status_enum rrc_conn_status;
    kal_uint8 est_cause;//RRC_EstablishmentCause:0-31, 255 means est_cause_NULL.
    tdd_em_rrc_cause_enum rrc_cause;
} tdd_em_rrce_conn_status_ind_struct;


typedef struct
{
   kal_uint16        uarfcn_DL;     //MMI
   kal_uint16        psc;           //MMI
   kal_uint32        Sib_Scheduled; //MMI
   /* MIB      0x0001
      SB1      0x0002
      SB2      0x0004
      SIB1     0x0008
      SIB2     0x0010
      SIB3     0x0020
      SIB4     0x0040
      SIB5     0x0080
      SIB6     0x0100
      SIB7     0x0200
      SIB11    0x0400
      SIB12    0x0800
      SIB18    0x1000
      SIB16    0x4000
      SIB5bis  0x8000
      SIB11bis 0x00010000
      SIB19    0x00020000
      SIB20    0x00040000
      SIB21    0x00080000
      SIB22    0x00100000
      */
   kal_uint32        received_Sib_Type;   //MMI
   kal_bool          is_finished;      //MMI
/*    20110524 YenChih
  *    kal_uint8 deferredSIB11 is only used in UMTS_R7 for catcher to display deferred SIB11 related information
  *                 0x00: status not change,
  *                 0x01: deferred SIB11 is on-going,
  *                 0x02: deferred SIB11 is finished
  */
   kal_uint8        deferredSIB11_ongoing;   //MMI
#ifdef __UMTS_TDD128_MODE__

   kal_uint8        cell_type;             //MMI
                /*0x00 invalid (clear Cell_type)
                  0x01 r4 cell
                  0x03 DPA CELL
                  0X05 UPA CELL
                  0X07 UPA+DPA CELL
                */
#endif /*UMTS_TDD128_MODE*/
} sibe_em_sib_status;

/* Viola 20080627, sibe_em_sib_status as the discussion with Shyla,
Sib_Scheduled brings a bitmask for several SIBs, which indicate the SIBs UE needs to receive. Catcher should gray the other SIBs not contained in the variable. Sib_Scheduled would change 0~2 times during SIB collection, I suggest that Catcher could store the current Sib_Scheduled value and compare it with the latest received one.
received_Sib_Type: This variable may contain one or several SIBs. Catcher shall mark "v" for the SIB(s) contained in this variable, but shall all keep the v of the other SIBs, which is marked by pervious "sibe_em_sib_status" messages.
is_finished: is_finished sets to True, it means that the current SIB Collection finishes. When a new collection starts, Catcher shall clean the "v" mark of all SIBs.
*/

typedef struct
{
   LOCAL_PARA_HDR
   sibe_em_sib_status      sib_status;
} sibe_em_sib_status_ind_struct;

typedef enum
{
   EM_UMTS_SUPPORT,
   EM_HSDPA_SUPPORT,
   EM_HSUPA_SUPPORT,
   EM_HSDPA_UPA_SUPPORT
}csce_em_serv_cell_hspa_status;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        uarfcn_DL;   /* UARFCN */  //MMI
   kal_uint16        psc;                       //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
   /* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_int8          qQualmin;  /* Qualmin */   //MMI
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI
   kal_int32         squal;                     //MMI
   kal_int32         rscp;                      //MMI
   kal_int32         ec_no;                     //MMI
   kal_uint16        cycleLength;               //MMI
/* number as k, value is 2k/100 in sec, float */
   kal_uint8         quality_measure;   /* 0: RSCP, 1: EcN0 */ //MMI
   /**
    * Dennis Weng 20101015
    * add band, rssi, cell_identity
    */
   kal_uint8         band;
   kal_int32         rssi;
   kal_uint32        cell_identity;
#ifdef __UMTS_R8__
/* csg_id: 0xFFFFFFFF means not show this csg_id */
   kal_uint32        csg_id;
/* apbcr_priority: -2 means not show apbcr_priority, Sprio_search1, Sprio_search2, and Threshserv_low */
   kal_int8          apbcr_priority;             //MMI
   kal_uint8         sprio_search1;              //MMI
   kal_uint8         sprio_search2;              //MMI
   kal_uint8         threshserv_low;             //MMI
   kal_uint8         threshserv_low2;            //MMI, 0xFF means invalid
#endif

   /* AT&T EM mode */
   kal_uint8         multi_plmn_count;
   plmn_struct       multi_plmn_id[6];

   kal_bool          lac_valid;
   kal_uint16        lac;

   kal_bool          rac_valid;
   kal_uint8         rac;

   kal_bool          ura_valid;
   kal_uint8         num_ura_id;
   meme_umts_ura_identity uraIdentity[8];

   csce_em_serv_cell_hspa_status hspa_status;

#ifdef __LTE_RAT__
#ifdef __UMTS_R11__
   kal_uint8         sib19CellFachMeasInd;
   kal_uint8         eutraRachReportNumBits;
   kal_uint8         eutraRachReportStringData;
#endif
#endif
} FDD_csce_em_serv_cell_s_status;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        uarfcn_DL;   /* UARFCN */  //MMI
   kal_uint16        psc;                       //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
   /* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_int8          qQualmin;  /* Qualmin */   //MMI
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI
   kal_int32         squal;                     //MMI
   kal_int32         rscp;                      //MMI
   kal_uint16        cycleLength;               //MMI
   /**
    * Dennis Weng 20101015
    * add band, rssi, cell_identity
    */
   kal_uint8         band;
   kal_int32         rssi;
   kal_uint32        cell_identity;
#ifdef __UMTS_R8__
/* csg_id: 0xFFFFFFFF means not show this csg_id */
   kal_uint32        csg_id;
/* apbcr_priority: -2 means not show apbcr_priority, Sprio_search1, Sprio_search2, and Threshserv_low */
   kal_int8          apbcr_priority;             //MMI
   kal_uint8         sprio_search1;              //MMI
   kal_uint8         sprio_search2;              //MMI
   kal_uint8         threshserv_low;             //MMI
   kal_uint8         threshserv_low2;            //MMI, 0xFF means invalid
#endif
} tdd_csce_em_serv_cell_s_status;

typedef struct
{
    kal_uint8 multi_plmn_count;
    plmn_struct multi_plmn_id[6];
} csce_em_info_multiple_plmn_struct;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        uarfcn_DL;                 //MMI
   kal_uint16        psc;                       //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
/* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_int8          qQualmin;  /* Qualmin */   //MMI
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI
   kal_int32         squal;                     //MMI
   kal_int32         rscp;                      //MMI
   kal_int32         ec_no;                     //MMI
#ifdef __UMTS_R8__
/* apbcr_priority: -2 means not show apbcr_priority, Threshx_high, and Threshx_low */
   kal_int8          apbcr_priority;             //MMI
   kal_uint8         threshx_high;               //MMI
   kal_uint8         threshx_low;                //MMI
   kal_uint8         threshx_high2;              //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;               //MMI, 0xFF means invalid
#endif

   /* AT&T EM mode */
   kal_uint32        cell_identity;

   kal_bool          multi_plmn_valid;

   kal_uint8         multi_plmn_count;
   plmn_struct       multi_plmn_id[6];

   kal_bool          lac_valid;
   kal_uint16        lac;

   kal_bool          rac_valid;
   kal_uint8         rac;

   kal_bool          ura_valid;
   kal_uint8         num_ura_id;
   meme_umts_ura_identity uraIdentity[8];
} FDD_csce_em_neigh_cell_s_status;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        uarfcn_DL;                 //MMI
   kal_uint16        psc;                       //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
/* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_int8          qQualmin;  /* Qualmin */   //MMI
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI
   kal_int32         squal;                     //MMI
   kal_int32         rscp;                      //MMI
   kal_int32         ec_no;                     //MMI
#ifdef __UMTS_R8__
/* apbcr_priority: -2 means not show apbcr_priority, Threshx_high, and Threshx_low */
   kal_int8          apbcr_priority;             //MMI
   kal_uint8         threshx_high;               //MMI
   kal_uint8         threshx_low;                //MMI
   kal_uint8         threshx_high2;              //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;               //MMI, 0xFF means invalid
#endif
} tdd_csce_em_neigh_cell_s_status;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        arfcn;                     //MMI
   kal_uint8         bsic;                      //MMI
   kal_bool          is_bsic_verified;          //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
/* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_uint8         freq_band;                 //MMI
   /* 0: 1800Band, 1: 1900Band */
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI
   kal_int32         rssi;                      //MMI
#ifdef __UMTS_R8__
/* apbcr_priority: -2 means not show apbcr_priority, Threshx_high, and Threshx_low */
   kal_int8          apbcr_priority;            //MMI
   kal_uint8         threshx_high;              //MMI
   kal_uint8         threshx_low;               //MMI
   kal_uint8         threshx_high2;             //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;              //MMI, 0xFF means invalid
#endif
} FDD_csce_em_2G_neigh_cell_s_status;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        arfcn;                     //MMI
   kal_uint8         bsic;                      //MMI
   kal_bool          is_bsic_verified;          //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
/* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_uint8         freq_band;                 //MMI
   /* 0: 1800Band, 1: 1900Band */
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI
   kal_int32         rssi;                      //MMI
#ifdef __UMTS_R8__
/* apbcr_priority: -2 means not show apbcr_priority, Threshx_high, and Threshx_low */
   kal_int8          apbcr_priority;            //MMI
   kal_uint8         threshx_high;              //MMI
   kal_uint8         threshx_low;               //MMI
   kal_uint8         threshx_high2;             //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;              //MMI, 0xFF means invalid
#endif
} tdd_csce_em_2G_neigh_cell_s_status;

typedef struct
{
   kal_uint32        earfcn;                    //MMI
   kal_uint16        pci;                       //MMI
   kal_int32         rsrp;                      //MMI
   kal_int32         rsrq;                      //MMI
   kal_int32         Treselection;              //MMI
   kal_int8          apbcr_priority;            //MMI

   kal_int16         qRxlevmin;                 //MMI
   kal_int8          qQualMinEUTRA;             //MMI

   kal_uint8         threshx_high;              //MMI
   kal_uint8         threshx_low;               //MMI
   kal_uint8         threshx_high2;             //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;              //MMI, 0xFF means invalid
} FDD_csce_em_LTE_neigh_cell_s_status;

typedef struct
{
   kal_uint16        earfcn;                    //MMI
   kal_uint16        pci;                       //MMI
   kal_int32         rsrp;                      //MMI
   kal_int32         rsrq;                      //MMI
   kal_int32         Treselection;              //MMI
   kal_int8          apbcr_priority;            //MMI

   kal_int16         qRxlevmin;                 //MMI
   kal_int8          qQualMinEUTRA;             //MMI

   kal_uint8         threshx_high;              //MMI
   kal_uint8         threshx_low;               //MMI
   kal_uint8         threshx_high2;             //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;              //MMI, 0xFF means invalid
} tdd_csce_em_LTE_neigh_cell_s_status;

typedef enum
{
  EM_UMTS_CELL,
  EM_GSM_CELL,
  EM_LTE_CELL
} em_RAT_type_enum;

#ifdef __UMTS_R8__
typedef enum
{
  EM_CLEAN_NEIGH_CELL_INFO,
  EM_UPDATE_RH_NEIGH_CELL_INFO,
  EM_UPDATE_APBCR_NEIGH_CELL_INFO
}em_neigh_cell_operation_enum;
#endif

typedef struct
{
   kal_uint8      cellidx;
   kal_uint8      celltype;               //MMI
   /* 1: ServCell, 2: IntraFreq NeighCell, 3: InterFreq NeighCell, 4: InterRAT NeighCell, 5: Detected NieghCell */
   kal_int32      r_value;                //MMI
   /* the value should be divided by 4096, the result may be float */
   kal_int32      Treselection;           //MMI
   /* if ServCell, it's Tresel_s; others, it's Tresel_acc */
   kal_uint8      chan_fail_type;         //MMI
   /* 0: Normal, 1: BCH failure, 2: Attempt failure, 4: MainCH failure */
} csce_em_cell_r_status;

typedef struct
{
   LOCAL_PARA_HDR
   kal_uint8               cell_count;
   csce_em_cell_r_status   cell_r_status[9];      /* for the element over neigh_cell_count, left blank */
} csce_em_cell_r_status_ind_struct;

typedef struct
{
   kal_uint8      cellidx;
   kal_int32      h_value;       //MMI
   /* the value should be divided by 4096, the result may be float */
   kal_uint8      HCS_PRIO;      //MMI
} csce_em_cell_h_status;

typedef struct
{
   LOCAL_PARA_HDR
   kal_uint8               cell_count;
   csce_em_cell_h_status   cell_h_status[9];      /* for the element over neigh_cell_count, left blank */
} csce_em_cell_h_status_ind_struct;

#ifdef __UMTS_R8__
typedef struct
{
   kal_uint8      cellidx;
   kal_uint8      celltype;               //MMI
   /* 1: ServCell, 2: IntraFreq NeighCell, 3: InterFreq NeighCell, 4: InterRAT NeighCell, 5: Detected NieghCell */
   kal_int32      Treselection;           //MMI
   /* if ServCell, it's Tresel_s; others, it's Tresel_acc */
   kal_uint8      chan_fail_type;         //MMI
   /* 0: Normal, 1: BCH failure, 2: Attempt failure, 4: MainCH failure */
} csce_em_cell_apbcr_status;

typedef struct
{
   LOCAL_PARA_HDR
   kal_uint8               cell_count;
   csce_em_cell_apbcr_status   cell_apbcr_status[16];      /* for the element over neigh_cell_count, left blank */
} csce_em_cell_apbcr_status_ind_struct;
#endif

/*  UL1 Engineering Mode  */
typedef enum
{
  _QPSK=0,
  _16QAM,			/* 1st alphabet can not digit */
  _64QAM
}em_mod_enum;

typedef struct
{
   kal_bool	   dl_64QAM_on;
} ul1_em_hs_dsch_configuration_struct;

typedef struct
{
   kal_bool	   ul_16QAM_on;
   kal_uint8   edch_tti;
} ul1_em_edch_configuration_struct;

typedef struct
{
   kal_bool	   dtx_on;
	kal_bool	   drx_on;
} ul1_em_cpc_configuration_struct;

typedef struct
{
   kal_bool    dc_on;
   kal_uint16  dl_freq;
   kal_uint16  psc;
   kal_bool    dl_64QAM_on;
} ul1_em_secondary_hs_dsch_configuration_status_struct;

typedef struct
{
   kal_uint16  dsch_error_all;
   kal_uint16  dsch_error_new_data;
   kal_uint16  dsch_error_after_retx;
   em_mod_enum dsch_curr_mod;
   kal_uint16  dsch_code_num;
   kal_uint16  dsch_cqi_val;
   kal_uint16  dsch_gap_ratio;
} ul1_em_primary_hs_dsch_bler_struct;

typedef struct
{
   kal_uint16  dsch_error_all;
   kal_uint16  dsch_error_new_data;
   kal_uint16  dsch_error_after_retx;
   em_mod_enum dsch_curr_mod;
   kal_uint16  dsch_code_num;
   kal_uint16  dsch_cqi_val;
   kal_uint16  dsch_gap_ratio;
} ul1_em_secondary_hs_dsch_bler_struct;

typedef struct
{
   kal_uint16  edch_ack_cnt;
	kal_uint16  edch_gap_ratio;
} ul1_em_edch_ack_rate_struct;

/* hs_dsch_configuration */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_hs_dsch_configuration_struct EmHsDschInfo;
}
fdd_em_ul1_hs_dsch_config_ind_struct;

/* edch_configuration */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_edch_configuration_struct EmEdchInfo;
}
fdd_em_ul1_edch_config_ind_struct;

/* secondary_hs_dsch_configuration */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_secondary_hs_dsch_configuration_status_struct EmSecHsDschInfo;
}
fdd_em_ul1_sec_hs_dsch_config_ind_struct;


/* cpc_configuration */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_cpc_configuration_struct EmCpcInfo;
}
fdd_em_ul1_cpc_config_ind_struct;

/* primary_hs_dsch_bler*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_primary_hs_dsch_bler_struct EmPriHsDschBLER;
}
fdd_em_ul1_pri_hs_dsch_bler_ind_struct;

/* secondary_hs_dsch_bler */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_secondary_hs_dsch_bler_struct EmSecHsDschBLER;
}
fdd_em_ul1_sec_hs_dsch_bler_ind_struct;

/* edch_ack_rate */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_edch_ack_rate_struct EmEdchAckRate;
}
fdd_em_ul1_edch_ack_rate_ind_struct;

/* prx_drx_measurement_ind */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

     /* DL Qual indicator */
    kal_int16  dl_rscp[2]; // -255: disable, -120 ~ (dBm)
    kal_int16  dl_rssi[2]; // -255: disable, -120 ~  (dBm)
}
fdd_em_ul1_prx_drx_measurement_ind_struct;

/* ul1_hspa_info_group_ind_struct */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                                         em_info;

    ul1_em_hs_dsch_configuration_struct                  hs_dsch_configuration;
    ul1_em_edch_configuration_struct                     edch_configuration;
    ul1_em_cpc_configuration_struct                      cpc_configuration;
    ul1_em_secondary_hs_dsch_configuration_status_struct secondary_hs_dsch_configuration_status;
    ul1_em_primary_hs_dsch_bler_struct                   primary_hs_dsch_bler;
    ul1_em_secondary_hs_dsch_bler_struct                 secondary_hs_dsch_bler;
    ul1_em_edch_ack_rate_struct                          edch_ack_rate;
}
fdd_em_ul1_hspa_info_group_ind_struct;

typedef struct
{
   kal_uint16 band;
   kal_uint16 uarfcn;
   kal_uint16 serving_psc;
   kal_int16 rscp_max;
   kal_int16 rscp_0;
   kal_int16 rscp_1;
   kal_int16 rscp_diff;
   kal_int16 ecno_max;
   kal_int16 ecno_0;
   kal_int16 ecno_1;
   kal_int16 rssi_max;
   kal_int16 rssi_0;
   kal_int16 rssi_1;
   kal_int8 tx_pwr;
   kal_int8 dpcch_tx_pwr;
   kal_uint8 main_ant_idx;
} fdd_ul1_em_tas_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    fdd_ul1_em_tas_info_struct EmUl1Tas;
}fdd_em_ul1_tas_info_ind_struct;

typedef enum
{
  IQ_T313_STATUS_STOPPED=0,
  IQ_T313_STATUS_RUNNING,
  IQ_T313_STATUS_EXPIRED,
  IQ_T313_STATUS_UNKNOWN
}iq_t313_status_t;
typedef struct
{
   kal_uint8 wScramblingCode;
   kal_uint8 ucTpcCombinationIndex;
   iq_t313_status_t ucT313Status;
}iq_rl_sync_status_t;
typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   kal_uint8                    ucNumRLSyncStatus;    /* Number of radio link sync status structuers: Range 1-6 */
   kal_uint8                    udPad;
   iq_rl_sync_status_t          tRlSyncStatus[6];     
}
em_ul1_radio_link_sync_status_ind_struct;

/* BEGIN {2013} - NEW EM Architecture */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8 multi_plmn_count;
    plmn_struct multi_plmn_id[6];
}
fdd_em_csce_multiple_plmn_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8 multi_plmn_count;
    plmn_struct multi_plmn_id[6];
}
tdd_em_csce_multiple_plmn_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint8               neigh_cell_count;
#ifdef __UMTS_R8__
   em_neigh_cell_operation_enum      operation;
#endif
   em_RAT_type_enum        RAT_type;
   union
   {
      FDD_csce_em_neigh_cell_s_status      neigh_cells[16];
      FDD_csce_em_2G_neigh_cell_s_status   GSM_neigh_cells[16];
      FDD_csce_em_LTE_neigh_cell_s_status  LTE_neigh_cells[16];
   }
   choice;
   /* for the element over neigh_cell_count, left blank */
}
fdd_em_csce_neigh_cell_s_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint8               neigh_cell_count;
#ifdef __UMTS_R8__
   em_neigh_cell_operation_enum      operation;
#endif
   em_RAT_type_enum        RAT_type;
   union
   {
      tdd_csce_em_neigh_cell_s_status      neigh_cells[16];
      tdd_csce_em_2G_neigh_cell_s_status   GSM_neigh_cells[16];
      tdd_csce_em_LTE_neigh_cell_s_status  LTE_neigh_cells[16];
   }
   choice;
   /* for the element over neigh_cell_count, left blank */
}
tdd_em_csce_neigh_cell_s_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
    em_info_enum em_info;

   /* the "sx","s_intra_search_value","s_intra_search_value",
   "s_search_hcs_value", "s_search_rat_value",
   "s_hcs_rat_value", "s_limit_search_rat_value"
   should be divided by 4096, the result may be float */
   kal_int32        sx;                            //MMI
   kal_bool         is_s_intra_search_valid;
   kal_int32        s_intra_search_value;          //MMI
   kal_bool         is_s_inter_search_valid;
   kal_int32        s_inter_search_value;          //MMI
   kal_bool         is_s_search_hcs_valid;
   kal_int32        s_search_hcs_value;            //MMI
   kal_bool         is_s_search_rat_valid;
   kal_int32        s_search_rat_value;            //MMI
   kal_bool         is_s_hcs_rat_valid;
   kal_int32        s_hcs_rat_value;               //MMI
   kal_bool         is_s_limit_search_rat_valid;
   kal_int32        s_limit_search_rat_value;      //MMI
   /* For meas_tgt_cells:
      1st LSB: UMTS Intra-Freq Cells, 2nd LSB: UMTS Inter-Freq Cells, 3rd LSB: GSM Inter-RAT Cells
      "Meas Target Type" in "Measurement Rule Status":
      0: Serv Cell only
      1: Serv with IntraFreq Cell
      2: Serv with InterFreq Cell
      3: Serv with Intra/InterFreq Cell
      4: Serv with InterRAT Cell
      5: Serv with IntraFreq/InterRAT Cell
      6: Serv with InterFreq/InterRAT Cell
      7: Serv with Intra/InterFreq/InterRAT Cell
      If the 1st&2nd LSB are all set to '0', make the "UMTS Satisfied Neighbour Cells Status" be invalid;
      If the 3rd LSB is set to '0', make the "GSM Satisfied Neighbour Cells Status" be invalid. */
   kal_uint32       meas_tgt_cells;               //MMI

#ifdef __UMTS_R8__
/* For apbcr_enabled_type:
      1: MEAS_RULE
      2: MEAS_RULE_AND_APB_H_PRIO
      3: MEAS_RULE_AND_APB_ALL_PRIO
      If apbcr_enabled_type is 1, please do not show apbMeasTargetCells, is_gsm_apbcr_enabled, apbcr_uarfcn .
   */
   kal_uint8        apbcr_enabled_type;               //MMI
   /* For apbMeasTargetCells:
      0: None cell
      1: intraFreq Cell
      2: interFreq Cell
      3: Intra/InterFreq Cell
      4: GSM Cell
      5: intraFreq/GSM Cell
      6: interFreq/GSM Cell
      7: Intra/InterFreq/GSM Cell
      8: LTE Cell
      9: intraFreq/LTE Cell
     10: interFreq/LTE Cell
     11: intraFreq/interFreq/LTE Cell
     12: GSM/LTE Cell
     13: intraFreq/GSM/LTE Cell
     14: interFreq/GSM/LTE Cell
     15: Intra/InterFreq/GSM/LTE Cell
   */
   kal_uint32       apbMeasTargetCells;                 //MMI
   kal_bool         is_gsm_apbcr_enabled;               //MMI
   kal_uint16       apbcr_uarfcn[2];                    //MMI
#endif
}
fdd_em_csce_meas_rule_status_ind_struct;

typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum em_info;

   /* the "sx","s_intra_search_value","s_intra_search_value",
   "s_search_hcs_value", "s_search_rat_value",
   "s_hcs_rat_value", "s_limit_search_rat_value"
   should be divided by 4096, the result may be float */
   kal_int32        sx;                            //MMI
   kal_bool         is_s_intra_search_valid;
   kal_int32        s_intra_search_value;          //MMI
   kal_bool         is_s_inter_search_valid;
   kal_int32        s_inter_search_value;          //MMI
   kal_bool         is_s_search_hcs_valid;
   kal_int32        s_search_hcs_value;            //MMI
   kal_bool         is_s_search_rat_valid;
   kal_int32        s_search_rat_value;            //MMI
   kal_bool         is_s_hcs_rat_valid;
   kal_int32        s_hcs_rat_value;               //MMI
   kal_bool         is_s_limit_search_rat_valid;
   kal_int32        s_limit_search_rat_value;      //MMI
   /* For meas_tgt_cells:
      1st LSB: UMTS Intra-Freq Cells, 2nd LSB: UMTS Inter-Freq Cells, 3rd LSB: GSM Inter-RAT Cells
      "Meas Target Type" in "Measurement Rule Status":
      0: Serv Cell only
      1: Serv with IntraFreq Cell
      2: Serv with InterFreq Cell
      3: Serv with Intra/InterFreq Cell
      4: Serv with InterRAT Cell
      5: Serv with IntraFreq/InterRAT Cell
      6: Serv with InterFreq/InterRAT Cell
      7: Serv with Intra/InterFreq/InterRAT Cell
      If the 1st&2nd LSB are all set to '0', make the "UMTS Satisfied Neighbour Cells Status" be invalid;
      If the 3rd LSB is set to '0', make the "GSM Satisfied Neighbour Cells Status" be invalid. */
   kal_uint32       meas_tgt_cells;               //MMI

#ifdef __UMTS_R8__
/* For apbcr_enabled_type:
      1: MEAS_RULE
      2: MEAS_RULE_AND_APB_H_PRIO
      3: MEAS_RULE_AND_APB_ALL_PRIO
      If apbcr_enabled_type is 1, please do not show apbMeasTargetCells, is_gsm_apbcr_enabled, apbcr_uarfcn .
   */
   kal_uint8        apbcr_enabled_type;               //MMI
   /* For apbMeasTargetCells:
      0: None cell
      1: intraFreq Cell
      2: interFreq Cell
      3: Intra/InterFreq Cell
      4: GSM Cell
      5: intraFreq/GSM Cell
      6: interFreq/GSM Cell
      7: Intra/InterFreq/GSM Cell
      8: LTE Cell
      9: intraFreq/LTE Cell
     10: interFreq/LTE Cell
     11: intraFreq/interFreq/LTE Cell
     12: GSM/LTE Cell
     13: intraFreq/GSM/LTE Cell
     14: interFreq/GSM/LTE Cell
     15: Intra/InterFreq/GSM/LTE Cell
   */
   kal_uint32       apbMeasTargetCells;                 //MMI
   kal_bool         is_gsm_apbcr_enabled;               //MMI
   kal_uint16       apbcr_uarfcn[8];                    //MMI
#endif
}
tdd_em_csce_meas_rule_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8                 cell_count;
    csce_em_cell_apbcr_status cell_apbcr_status[16];	/* for the element over neigh_cell_count, left blank */
}
fdd_em_csce_apbcr_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8                 cell_count;
    csce_em_cell_apbcr_status cell_apbcr_status[16];	/* for the element over neigh_cell_count, left blank */
}
tdd_em_csce_apbcr_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8             cell_count;
    csce_em_cell_r_status cell_r_status[9];   /* for the element over neigh_cell_count, left blank */
}
fdd_em_csce_cell_r_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8             cell_count;
    csce_em_cell_r_status cell_r_status[9];   /* for the element over neigh_cell_count, left blank */
}
tdd_em_csce_cell_r_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8             cell_count;
    csce_em_cell_h_status cell_h_status[9];	   /* for the element over neigh_cell_count, left blank */
}
fdd_em_csce_cell_h_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8             cell_count;
    csce_em_cell_h_status cell_h_status[9];	   /* for the element over neigh_cell_count, left blank */
}
tdd_em_csce_cell_h_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    FDD_csce_em_serv_cell_s_status serv_cell;
} fdd_em_csce_serv_cell_s_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    tdd_csce_em_serv_cell_s_status serv_cell;
} tdd_em_csce_serv_cell_s_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    sibe_em_sib_status sib_status;
} em_sibe_sib_status_ind_struct;

typedef enum {
    ON,
    OFF
} hspa_support;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    hspa_support hsdpa_enable;
    hspa_support hsupa_enable;
} fdd_em_usime_capability_info_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint16 HSDSCH_Serving_UARFCN;     /* uarfcn of HS-DSCH serving cell, 0xFFFF means invalid */
   kal_uint16 HSDSCH_Serving_PSC;        /* psc of HS-DSCH serving cell, 0xFFFF means invalid */
   kal_uint16 EDCH_Serving_UARFCN;       /* uarfcn of E-DCH serving cell, 0xFFFF means invalid */
   kal_uint16 EDCH_Serving_PSC;          /* psc of E-DCH serving cell, 0xFFFF means invalid */
} fdd_em_meme_dch_h_serving_cell_info_ind_struct;

typedef struct {
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint8 num_trch;
   trch_bler_struct TrCHBler[8];
}
fdd_em_meme_dch_bler_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_int8 tx_power; // FDD only
    kal_uint8 num_cells;
    FDD_meme_umts_cell_struct umts_cell_list[32];
} fdd_em_meme_dch_umts_cell_info_ind_struct;

typedef struct
{
    kal_uint32 EARFCN;
    kal_uint16 PCI;
    kal_int16 RSRP;
    kal_int16 RSRQ;
} meme_lte_cell_struct;

#define MAX_REPORT_LTE_CELL_EM (32)

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8 num_cells;
    meme_lte_cell_struct lte_cell_list[32];
} fdd_em_meme_fach_dch_lte_cell_info_ind_struct, fdd_em_meme_dch_lte_cell_info_ind_struct, fdd_em_meme_fach_lte_cell_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8 num_cells;
    meme_lte_cell_struct lte_cell_list[32];
} tdd_em_meme_dch_lte_cell_info_ind_struct;


/* END {2013} - NEW EM Architecture */

typedef enum
{
   EM_TDD_MEASURE,
   EM_FDD_MEASURE,
   EM_GSM_RSSI,
   EM_GSM_BSIC_INIT,
   EM_GSM_BSIC_CNF,
   EM_MULTI_CARRIER,
   EM_E_UTRA
} em_tgps_measure_enum;


typedef struct
{
   kal_bool          existed;
   kal_uint8          tgpsi;  /* 1~6 */
   kal_bool          is_gap_deactive;
   /* is_gap_deactive, 0: gap is ACTIVE, 1: gap is DEACTIVE */
   em_tgps_measure_enum    measure_purpose;
} urr_em_tgps_status;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   urr_em_tgps_status        tgps_status[6];

} em_rrce_tgps_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint16        srnc;

} em_slce_srncid_status_ind_struct;

typedef struct
{
   kal_uint8     RAB_ID;
   kal_int8      RB_ID;
   kal_uint32    DL_rate;   /* the value should be divided by 1000, the result may be float, uint: kbps */
   kal_uint32    UL_rate;   /* the value should be divided by 1000, the result may be float, uint: kbps */

} slce_em_ps_data_status;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint8         ps_number;
   slce_em_ps_data_status        ps_data_status[8];

} em_slce_ps_data_rate_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

	/* UMAC related */
   kal_uint8	dl_mac_hspa_type;  // dl_mac_type display : 0:NA, 1:MAC-hs, 2:MAC-ehs
	kal_uint8	ul_mac_hspa_type;  // ul_mac_type display : 0:NA, 1:MAC-ees, 2:MAC-iis

	/* UL1 PHY related */
	kal_uint8 fdpch[6];           // fdpch slot format display : 0~9: SlotFormat-0 ~ SlotFormat-9, 10:NA(NotConfigured	)

   /* Jack Chu: Amazon EM Modifications: shift ID workaround */
   kal_uint16 num_rbs;           // PS RBs only
   /* HS-DSCH related */
   kal_uint8  cqi_feedback_cycle;
   kal_uint8 num_hs_ops_start; /* HSDPA channel setup */
   kal_uint8 num_hs_ops_reconfig; /* H serving cell change */
   kal_uint8 num_hs_ops_stop; /* HSDPA channel tear down */
   kal_uint16 mac_hs_reset;

} em_rrce_dch_state_configuration_status_ind_struct ;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint8 e_dch_tti; // edch tti display : 255:NA, 0: 2 tti, 1: 10 tti
   kal_uint8 hsdpa_configured;  //display: 0: not configured, 1; configured
   kal_uint8 hsupa_configured;  //display: 0: not configured, 1; configured
   kal_uint8 dc_hsdpa_configured;  //display: 0: not configured, 1; configured
   kal_uint8 dtx_configured;  //display: 0: not configured, 1; configured
   kal_uint8 drx_configured;  //display: 0: not configured, 1; configured
}em_rrce_hspa_config_ind_struct; /* MOLY00100048, Jack Chu,  EM_RRCE_HSPA_CONFIG_IND == 160 */


typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

	/* eDRX related */
   kal_bool	eDRXcfgStatus;  // Note that this is config status from RRC viewpoint, not real operating status from UL1 viewpoint

} em_rrce_fach_state_configuration_status_ind_struct ;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

	/* security related */
   kal_uint8	uCipheringAlgorithm;  // F9 Alg : 0x0:Init(no cipher), 0x1:UEA0, 0x2:UEA1, 0x4:UEA2
	kal_uint8	uIntegrityAlgorithm;  // F8 Alg : 0x0:Init(no integrity), 0x1:UIA1, 0x2:UIA2
} em_rrce_3g_security_configuration_status_ind_struct ;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_bool	cs_over_hspa_status;  // R8 feature CS over HSPA on/off status

} em_rrce_cs_over_hspa_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_bool	FDcfgStatus;  // NW support FD status

} em_rrce_fd_configuration_status_ind_struct;



typedef enum
{
    EM_RRCE_CALL_TYPE_MO    = 0,
    EM_RRCE_CALL_TYPE_MT,
    EM_RRCE_CALL_TYPE_EMERGENCY,
    EM_RRCE_CALL_TYPE_INVALID
} em_rrce_call_type_enum;


typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   kal_uint16 uarfcn_DL;   /* DL UARFCN */
	em_rrce_call_type_enum te_call_type;	/* mo/mt call */
} em_rrce_rlf_ind_struct; /* __ALPS02506878_SUPPORT__ */



typedef enum
{
   EM_RRCE_KPI_IRAT_3G2_HO,
   EM_RRCE_KPI_IRAT_3G2_IDLE_CR,
   EM_RRCE_KPI_IRAT_3G2_CONNECTED_CR,
   EM_RRCE_KPI_IRAT_3G2_CCO,
   EM_RRCE_KPI_IRAT_3G2_IDLE_REDIR,
   EM_RRCE_KPI_IRAT_3G2_CONNECTED_REDIR,
   EM_RRCE_KPI_PROC_NUM
} em_rrce_kpi_proc_enum;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   em_rrce_kpi_proc_enum proc_id;
   em_kpi_status_enum status;
   kal_uint32  attempt;
   kal_uint32  success;
} em_rrce_kpi_status_ind_struct;

typedef enum
{
   AMR_4_75 = 0,
   AMR_5_15,
   AMR_5_90,
   AMR_6_70,
   AMR_7_40,
   AMR_7_95,
   AMR_10_20,
   AMR_12_20,
   AMR_SID,
   GSM_EFR_SID,
   TDMA_EFR_SID,
   PDC_EFR_SID,
   RESERVE_1,
   RESERVE_2,
   RESERVE_3,
   AMR_NODATA,
   AMRWB_6_60,
   AMRWB_8_85,
   AMRWB_12_65,
   AMRWB_14_25,
   AMRWB_15_85,
   AMRWB_18_25,
   AMRWB_19_85,
   AMRWB_23_05,
   AMRWB_23_85,
   AMRWB_SID
} em_csr_SpeechCodecType;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum            em_info;
    em_csr_SpeechCodecType   ULAMRType;
    em_csr_SpeechCodecType   DLAMRType;
} em_csr_status_ind_struct;

#endif /* __UMTS_RAT__ */

typedef enum
{
   TX_ANTENNA_0,
   TX_ANTENNA_1,
   TX_ANTENNA_NUM,
   TX_ANTENNA_INVALID = 0xFF
} force_tx_ant_idx_enum;

typedef enum _force_tx_ant_cmd_type_e
{
   SET_FORCE_TX_ANT  = 0,
   READ_FORCE_TX_ANT = 1
} force_tx_ant_cmd_type_e;

typedef struct _l4cul1_force_tx_ant_req_struct
{
   LOCAL_PARA_HDR   
   force_tx_ant_cmd_type_e cmd_type;
   kal_bool enable_force_tx_ant;
   force_tx_ant_idx_enum force_tx_ant_idx;

} l4cl1_force_tx_ant_req_struct,
  l4cul1_force_tx_ant_req_struct,
  l4ctl1_force_tx_ant_req_struct,
  l4cel1_force_tx_ant_req_struct;

typedef struct _l4cul1_force_tx_ant_cnf_struct
{
   LOCAL_PARA_HDR
   force_tx_ant_cmd_type_e cmd_type;
   kal_bool result;
   kal_bool enable_force_tx_ant;
   force_tx_ant_idx_enum force_tx_ant_idx;
   
} l4cl1_force_tx_ant_cnf_struct,
  l4cul1_force_tx_ant_cnf_struct,
  l4ctl1_force_tx_ant_cnf_struct,
  l4cel1_force_tx_ant_cnf_struct;

typedef struct _l4cmmrf_ap_rfidx_update_req_struct
{
   LOCAL_PARA_HDR
   kal_uint8 src_id;
   kal_uint16 feature_idx;      /* feature index:  valid from 0 */
   kal_int16 scen_idx;          /* scenario index: valid from 0, -1 means disable feature_idx */
} l4cmmrf_ap_rfidx_update_req_struct,
  l4cul1_ap_rfidx_update_req_struct,
  l4cel1_ap_rfidx_update_req_struct;

typedef struct _l4cmmrf_ap_rfidx_update_cnf_struct
{
   LOCAL_PARA_HDR
   kal_uint8 src_id;
   kal_bool success;   /* KAL_TRUE: SUCCESS, KAL_FALSE: FAIL */
} l4cmmrf_ap_rfidx_update_cnf_struct,
  l4cul1_ap_rfidx_update_cnf_struct,
  l4cel1_ap_rfidx_update_cnf_struct;

typedef struct _l4cl1_txrx_active_time_req_struct
{
   LOCAL_PARA_HDR   
   kal_uint8 src_id;
   
} l4cl1_txrx_active_time_req_struct,
  l4cul1_txrx_active_time_req_struct,
  l4ctl1_txrx_active_time_req_struct,
  l4cel1_txrx_active_time_req_struct;

typedef struct _l4cl1_txrx_active_time_cnf_struct
{
   LOCAL_PARA_HDR
   kal_uint8     src_id;        // just piggyback the src_id sent by l4cel1_txrx_active_time_req_struct from L4C.
   kal_uint32    tx_mode_time_ms[NUM_TX_POWER_LEVELS];
   kal_uint32    rx_mode_time_ms;
   kal_uint32    txrx_mode_union_time_ms;
   
} l4cl1_txrx_active_time_cnf_struct,
  l4cul1_txrx_active_time_cnf_struct,
  l4ctl1_txrx_active_time_cnf_struct,
  l4cel1_txrx_active_time_cnf_struct;

/**************************************************************************
  * Video Telephony (3G324M) - Engineer Mode
  *
  * Notes: Following structures are maintained by VT task
  * Meggie: 2007/10/05:  Add VT EM related structures
  **************************************************************************/
/***************************** VT EM Config  ********************************/
typedef enum{
    VT_EM_DATA_TYPE_INVALID = -1,
    VT_EM_DATA_TYPE_AUDIO = 0,
    VT_EM_DATA_TYPE_VIDEO
}vt_em_channel_data_type;

typedef struct{
    LOCAL_PARA_HDR
    vt_em_config_struct em_config;
}l4c_vt_em_set_config_req_struct;   /* MSG: MSG_ID_L4C_VT_EM_SET_CONFIG_REQ */

typedef struct{
    LOCAL_PARA_HDR
    vt_em_config_struct em_config;
}l4c_vt_em_get_config_cnf_struct;   /* MSG: MSG_ID_L4C_VT_EM_GET_CONFIG_CNF */


/****************************  VT EM Display  ********************************/
/* Radvision strucuture dependent */
typedef enum{
    VT_EM_CALL_STATE_INIT = -1,
    VT_EM_CALL_STATE_SYNCHRONIZED = 0,
    VT_EM_CALL_STATE_CONNECTED,
    VT_EM_CALL_STATE_CONNECTEDCHANNELS,
    VT_EM_CALL_STATE_IDLE,
    VT_EM_CALL_STATE_RESETTING,
    VT_EM_CALL_STATE_LOSTSYNC
}vt_em_call_state_choice; /* Refer to Rv3G324mCallState type */

typedef enum
{
    VT_EM_CODEC_TYPE_Unknown = -1,
    VT_EM_CODEC_TYPE_Amr,
    VT_EM_CODEC_TYPE_Mpeg4,
    VT_EM_CODEC_TYPE_H264,
    VT_EM_CODEC_TYPE_H239Control,
    VT_EM_CODEC_TYPE_H239ExtendedVideo,
    VT_EM_CODEC_TYPE_G7221,
    VT_EM_CODEC_TYPE_G726,
    VT_EM_CODEC_TYPE_H324AnnexI,
    VT_EM_CODEC_TYPE_SessionReset,
    VT_EM_CODEC_TYPE_G7222,
    VT_EM_CODEC_TYPE_G7231,
    VT_EM_CODEC_TYPE_H263,
    VT_EM_CODEC_TYPE_G711,
    VT_EM_CODEC_TYPE_G722,
    VT_EM_CODEC_TYPE_G729,
    VT_EM_CODEC_TYPE_H249NavigationKey,
    VT_EM_CODEC_TYPE_H249SoftKeys,
    VT_EM_CODEC_TYPE_H249PointingDevice,
    VT_EM_CODEC_TYPE_H249ModalInterface,
    VT_EM_CODEC_TYPE_Last
} vt_em_codec_type;

/* Radvision strucuture independent */
typedef enum{
    VT_EM_MASTER_SLAVE_STATUS_INVALID = -1,
    VT_EM_SLAVE = 0,
    VT_EM_MASTER
}vt_em_master_slave_status_choice;

typedef enum{
    VT_EM_RETRANSMISSION_PROTOCOL_INVALID = -1,
    VT_EM_RETRANSMISSION_PROTOCOL_SRP = 0,
    VT_EM_RETRANSMISSION_PROTOCOL_NSRP,
    VT_EM_RETRANSMISSION_PROTOCOL_WNSRP
}vt_em_retransmission_protocol_choice;

typedef enum{
    VT_EM_RESOLUTION_INVALID = -1,
    VT_EM_RESOLUTION_SQCIF = 0,
    VT_EM_RESOLUTION_QCIF,
    VT_EM_RESOLUTION_CIF
}vt_em_video_resolution_choice;

typedef enum{
    VT_EM_H223_AL_TYPE_UNKNOWN = -1,
    VT_EM_H223_AL_TYPE_1 = 0,
    VT_EM_H223_AL_TYPE_2,
    VT_EM_H223_AL_TYPE_3
}vt_em_al_type;

typedef struct{
    kal_uint16 lcn;
    kal_uint8   is_chan_duplex;
    vt_em_codec_type   codec_type;
    vt_em_video_resolution_choice  resolution_choice;
    vt_em_al_type forward_al;
    kal_int32   max_sdu_size;
}vt_em_video_channel_info_struct;

typedef struct{
    kal_uint16 lcn;
    kal_uint8   is_chan_duplex;
    vt_em_codec_type   codec_type;
    vt_em_al_type forward_al;
    kal_int32   max_sdu_size;
}vt_em_audio_channel_info_struct;

typedef enum{
    VT_EM_RP_UNKNOWN = -1,
    VT_EM_RP_COMMAND = 0,
    VT_EM_RP_RESPONSE
}vt_em_xSRP_data_type;

typedef struct{
    kal_uint8 sq;
    vt_em_xSRP_data_type type;
}vt_em_outgoing_xSRP;

typedef struct{
    kal_uint8 sq;
    vt_em_xSRP_data_type type;
}vt_em_incoming_xSRP;

typedef struct{
        kal_uint32 vt_csr_DL_Q_frame_num;
        kal_uint32 vt_csr_UL_Q_frame_num;
        kal_uint32 vt_MED_DL_Q_frame_num;
        kal_uint32 vt_MED_DL_Q_state;

        kal_uint32 vt_DL_video_frame_num;
        kal_uint32 vt_DL_video_frame_size;
        kal_uint32 vt_DL_video_I_frame_num;
        kal_uint32 vt_DL_video_P_frame_num;

        kal_uint32 vt_DL_audio_frame_num;
        kal_uint32 vt_DL_audio_frame_size;

        kal_uint32 vt_UL_video_frame_num;
        kal_uint32 vt_UL_video_frame_size;
        kal_uint32 vt_UL_video_drop_frame_num;
        kal_uint32 vt_UL_video_drop_frame_size;

        kal_uint32 vt_UL_audio_frame_num;
        kal_uint32 vt_UL_audio_frame_size;
        kal_uint32 vt_UL_audio_drop_frame_num;
        kal_uint32 vt_UL_audio_drop_frame_size;

        kal_uint32 vt_UL_csr_size;
        kal_uint32 vt_UL_csr_num;
        kal_uint32 vt_DL_csr_size;
        kal_uint32 vt_DL_csr_num;

        kal_uint32 vt_downlink_mc_tbl[16];  /* # pkts using this mc entry */
        kal_uint32 vt_uplink_mc_tbl[16];

        kal_uint32 vt_ra_add_failures;
        kal_uint32 vt_incoming_audio_crc_errors;
        kal_uint32 vt_incoming_video_crc_errors;
        kal_uint32 vt_incoming_control_crc_errors;
        kal_uint32 vt_incoming_control_total_packets;
}vt_em_statistic_info_struct;

typedef struct{
    LOCAL_PARA_HDR
    em_info_enum em_info;
}l4cvt_em_display_ind_struct;   /* MSG: VT to L4C */
/************************** VT EM Definition End  *****************************/

/* __UL2_EM_MODE__ */
#if defined(__UMTS_RAT__)
typedef struct
{
    kal_uint16                      max_usage_kbytes;          /*Maximum used size of the pool, <= 999*/
    kal_uint16                      avg_usage_kbytes;           /*Average used size of the pool, <= 999*/
} adm_pool_info_struct;

typedef struct
{
    /*UMAC new EM Arch*/
    adm_pool_info_struct      dl_adm_pool_info; /*dl_adm_pool_info represent the info of  DL ADM POOl 1*/
    adm_pool_info_struct      ul_adm_pool_info[4];/* ul_adm_pool_info[0] ~ ul_adm_pool_info[2]
                                              represent the info of  UL ADM POOl 1 ~ 3 and
                                              ul_adm_pool_info[3] represent the info TOTAL UL ADM POOL*/
} ul2_em_adm_pool_status_ind_struct;

typedef struct
{
	kal_uint8				num_trch;
	trch_bler_struct  		TrCHBler[8];
}ul2_em_3g_bler_ind_struct;


typedef enum
{
    Invalid,                                        /*show blank */
    No_Modify,                                   /*show "=" */
    Add_Queue,                                  /*show "V" */
    Delete_Queue,                                /*show "X" */
    Reconfigure_T1,                              /*show "T1" */
    Reconfigure_WindowSize,                   /*show "WS" */
    Reconfigure_T1_WindowSize,               /*show "T1_WS" */
    Reconfigure_C_T,                          /*show "C_T"*/
} reconfigure_operation_E;

typedef struct
{
    reconfigure_operation_E               reconfig_info[8];         /* reconfiguration operation of the Queue 0 ~ 7 */
} ul2_em_hsdsch_reconfig_status_ind_struct;
typedef struct
{
    kal_uint16           rx_mac_data_rate; 		/* kbps, <=2800*/
   	kal_uint16           rx_pdcp_data_rate;  	/* kbps, <= 2800*/
    kal_uint16           tx_mac_data_rate;  	/*kbps, <=400*/
    kal_uint16       	 tx_pdcp_data_rate;      /*kbps, <=400*/
} ul2_em_ps_data_rate_status_ind_struct;

typedef enum
{
    URLC_ESTABLISH,               //display "EST"
    URLC_REESTABLISH,           //display "REEST"
    URLC_RECONFIG,                //display "RECFG"
    URLC_RELEASE,                   //display "REL"
    URLC_SUSPEND,                  //display "SUSPD"
    URLC_RESUME,                    //display "RES"
    URLC_RESET,                        //display "RST"
    URLC_DISCARD                   //display "DISCD"
} RLC_ACTION_INFO;

typedef struct
{
    kal_bool                  is_srb;         // if TRUE, display "S", else display "U"
    kal_uint8                 cn_domain;  // for 0, display "CS"; for 1, display "PS"; for 2, display "ALL"
} ul2_em_rb_info_struct;

typedef struct
{
    kal_uint8                  rlc_mode;   //for 1, display "TM"; for 2, display "UM"; for 3, display "AM", other "Error"
    kal_uint8                  direction;    //for 1, display "UL"; for 2, display "DL"; for 3, display "Both", other "Error"
} ul2_em_rlc_info_struct;

typedef struct
{
    kal_uint16              pdu_Size;    //display the value
    kal_uint16              tx_window_size;  //display the value, range [1, 2048]
    kal_uint16              rx_window_size;   //display the value, range[1, 2048]
    kal_uint8               discard_mode;    //value is 0/1/2/3, display the value
    kal_uint16              discard_value;    //display the value, range [0, 9999]
} ul2_em_rlc_parameter_struct;

typedef struct
{
    kal_int8                        rb_id;        // display the value, range [-5, 32]
    RLC_ACTION_INFO                 rlc_action;
    ul2_em_rb_info_struct           rb_info;
    ul2_em_rlc_info_struct          rlc_info;
    ul2_em_rlc_parameter_struct     rlc_parameter;
    kal_bool                        flush_data_indicator;    //if TRUE, display "Flush", else show blank
    kal_uint8                       reset_cause;                //value is 0/1/2, display the value
} ul2_em_urlc_event_status_ind_struct;

/*UMAC new EM Arch*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_adm_pool_status_ind_struct ul2_em_adm_pool_status_ind_struct_info;
} em_ul2_adm_pool_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_ps_data_rate_status_ind_struct ul2_em_ps_data_rate_status_ind_struct_info;
} em_ul2_ps_data_rate_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_hsdsch_reconfig_status_ind_struct ul2_em_hsdsch_reconfig_status_ind_struct_info;
} em_ul2_hsdsch_reconfig_status_ind_struct;

typedef struct
{
    kal_uint16 dummy;
    kal_bool bPCHBadCRC; /* KAL_FALSE means UE get Bad CRC TB from PCH at CELL_PCH state */
    kal_uint8 cfn;       /* the cfn receiving Bad CRC TB from PCH at CELL_PCH state */
} fdd_em_umac_info_pch_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    fdd_em_umac_info_pch_struct     pch_info;
} fdd_em_umac_info_pch_ind_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_urlc_event_status_ind_struct ul2_em_urlc_event_status_ind_struct_info;
} em_ul2_urlc_event_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_3g_bler_ind_struct ul2_em_periodic_bler_report_ind_info;
} em_ul2_3g_bler_ind_struct;

/***HSUPA SI***/
typedef struct
{
   kal_uint32                       time;
   kal_uint8                        SNPL;
   kal_uint8                        UPH;
   kal_uint8                        TEBS;
   kal_uint8                        HLBS;
   kal_uint8                        HLID;
   kal_bool                         isERUCCH;
}ul2_em_hsupa_si_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_hsupa_si_ind_struct ul2_em_hsupa_si_ind_info;
}em_ul2_hsupa_si_ind_struct;
/***HSUPA SI***/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
}tdd_em_ul2_pch_crc_ind_struct;

typedef struct
{
    kal_bool        valid; /* indicate if this struct info is valid; SHALL be 0 or 1 */
    kal_uint8       dummy1; /* 4 byte alignment for memcpy */
    kal_uint16      dummy2; /* 4 byte alignment for memcpy */

    /* Happy bit indicator; for EM View:
            happy_rate = 100 * happy_count / tx_count
            dtx_rate = 100 * dtx_count / (tx_count + dtx_count)
     */
    kal_uint32      happy_count;
    kal_uint32      tx_count;
    kal_uint32      dtx_count;

    /* MAC-E layer throughput; for EM View:
            retx_1st_rate = 100 * retx_1st_count / total_tx_count
            retx_2nd_rate = 100 * retx_2nd_count / total_tx_count
            retx_3rd_rate = 100 * retx_3rd_count / total_tx_count
     */
    kal_uint32      bit_rate;   /* total transmit SDU bits */
    kal_uint32      block_rate; /* total transmit PDU bits */
    kal_uint32      retx_1st_count;
    kal_uint32      retx_2nd_count;
    kal_uint32      retx_3rd_count;
    kal_uint32      total_tx_count;

    /* Serving Grant; for EM View:
            sg_utilization = 100 * block_rate / sg_bit_rate;
     */
    kal_uint16      serving_grant[32];   /* count AG value when UE received AG command */
    kal_uint32      sg_bit_rate; /* total grant bits*/
    kal_uint32      sg_distribution; /* ??? */

    kal_uint32      AckBlkCnt;   /* total Ack block count*/
    kal_uint32      NackBlkCnt;  /* total Nack block count*/

    kal_uint32      ETFCISampleCnt;  /* number of ucETFCI */
                                     /* range: 0 ~ 500    */
    kal_uint8       ucETFCI[500];   /* worst case: recording on 2ms TTI and transmitting data on each TTI*/
} fdd_em_umac_info_cell_edch_struct;

typedef struct
{
    kal_uint32 dl_rb_rate; // DL Radio Bearer Rate
    kal_uint32 ul_rb_rate; // DL Radio Bearer Rate
    kal_uint16 rx_num_error_pdu; //Tot Num of PDU¡¦d received in error
    kal_uint16 rx_num_data_pdu_rxd; //Total Number of Data PDU¡¦s received
    kal_uint16 num_pdu_nak_by_nw; // Total Number of PDU¡¦s NAK¡¦d by n/w
    kal_uint16 pad;
    kal_uint32 rx_num_pdu_bytes; // Total number of bytes Rx¡¦d (Control + Data)
    kal_uint16 num_rlc_resets; //Number of RLC resets
    kal_uint16 num_pdu_tx; //Tot number of PDU¡¦s Tx
    kal_uint16 num_pdu_retx; // Tot number of PDU¡¦s Re- Tx
    kal_uint16 tot_num_pdu_nak_to_nw; // Total Number of PDU¡¦s NAK¡¦d to n/w
    kal_uint32 tx_num_pdu_bytes; // Total number of bytes Sent (Control + Data)
} FDD_em_urlc_status_struct;

typedef struct
{
    kal_uint32 ul_rlc_rate;
    kal_uint32 dl_rlc_rate;
    kal_uint32 ul_rlc_retx_rate;
    kal_uint32 ul_rb_tpt[8];
    kal_uint32 dl_rb_tpt[8];
    kal_uint32 ul_rb_retx_rate[8];
 } FDD_em_urlc_layer_tput_struct;


typedef enum iq_rlc_mode_Tag
{
    IQ_RLC_MODE_UNKNOWN,        /* Mode could not be determined */
    IQ_RLC_MODE_UNACKNOWLEDGED, /* Unacknowledged mode */
    IQ_RLC_MODE_ACKNOWLEDGED,   /* Acknowledged mode */
    IQ_RLC_MODE_TRANSPARENT,    /* Transparent mode */
} iq_rlc_mode_t;

typedef struct
{
    kal_uint8 ucUserRBId;       /* The ID of the user radio bearer to which this structure pertains (The deprecated name of this field was ucTrChId) */
    iq_rlc_mode_t urRlcMode;    /* The RLC mode of operation for this radio bearer */
    kal_uint16 wPad;            /* Padding for alignment, shall be set to 65535.*/
    kal_uint32 dwRlcByteCnt;    /* Number of new RLC data (payload) bytes received (UL) or transmitted (DL) on this radio bearer */
    kal_uint32 dwRlcBlkCnt;     /* Number of new RLC PDUs received or transmitted on this radio bearer */
    kal_uint32 dwRlcReTrBlkCnt; /* Number retransmitted PDUs (UL) or number of PDUs requested for retransmission (DL) on this radio bearer */
 } iq_rb_rlc_stats_t;

typedef struct
{
    kal_uint32 dwRlcUlDuration; /* RLC uplink measurement period to which this metric pertains in milliseconds*/
    kal_uint32 dwRlcDlDuration; /* RLC downlink measurement period to which this metric pertains in milliseconds*/
    kal_uint8  ucNumUlUserRB;   /* Number of uplink user radio bearers to which this metric pertains (The deprecated name of this field was ucNumUlTrCh) */
    kal_uint8  ucNumDlUserRB;   /* Number of user radio bearers to which this metric pertains (The deprecated name of this field was ucNumDlTrCh)*/
    kal_uint16 wPad;   /* Padding for alignment, shall be set to 65535.*/
    iq_rb_rlc_stats_t tRlcUlStats[8];   /* An array of structure type iq_rb_rlc_stats_t whose length is ucNumUlUserRB (The deprecated name of this field was iq_trch_rlc_stats_t) */
    iq_rb_rlc_stats_t tRlcDlStats[8];   /* An array of structure type iq_rb_rlc_stats_t whose length is ucNumDlUserRB (The deprecated name of this field was iq_trch_rlc_stats_t) */
 } FDD_em_urlc_att_rlc_statistics_struct;

typedef struct
{
    kal_uint8  ucRadioBearerId;   /* The identity of the AM-RLC radio bearer to which the RESET pertains */
    kal_uint8  ucDirection;       /* 0: The PDU was received by the UE, 1: The PDU was transmitted by the UE , All other values are reserved */
    kal_uint8  ucPduType;         /* The type of PDU to which this metric pertains: 1: RESET PDU, 2: RESET ACK PDU, All other values are reserved NOTE: This field corresponds to PDU Type as defined in 3GPP TS 25.322/9.2.2.2 */
    kal_uint8  ucResetSeqNum;     /* The sequence number of the reset transaction to which this metric pertains. Shall be set to 255 if the Reset Sequence Number is not available NOTE: This field corresponds to Reset Sequence Number as defined in 3GPP TS 25.322/9.2.2.13 */
    kal_uint8  ucMaxRst;          /* 0: MaxRST has not yet been reached for this AM-RLC entity, 1: MaxRST has been reached (i.e., transmission of this PDU is prohibited) All other values are reserved. */
 } FDD_em_urlc_att_rlc_reset_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    fdd_em_umac_info_cell_edch_struct       edch_info[2]; /* [0] is Primary Cell; [1] is Secondary Cell */
} fdd_em_umac_info_edch_ind_struct; /* for periodic (1s) edch reporting */

typedef struct
{
    kal_bool        valid; /* indicate if this struct info is valid; SHALL be 0 or 1 */
    kal_uint8       dummy1; /* 4 byte alignment for memcpy */
    kal_uint16      dummy2; /* 4 byte alignment for memcpy */

    /* MAC layer HSDPA throughput; for EM View:
            retx_1st_rate = 100 * retx_1st_count / total_tx_count
            retx_2nd_rate = 100 * retx_2nd_count / total_tx_count
            retx_3rd_rate = 100 * retx_3rd_count / total_tx_count
            redundant_rate = 100 * redundant_TSN_count / total_TSN_count
     */
    kal_uint32      bit_rate;   /* total transmit SDU bits */
    kal_uint32      block_rate; /* total transmit PDU bits */
                                /* For MAC-hs, both bit_rate & block_rate include the MAC-hs header
                                 * For MAC-ehs, only block_rate includes the MAC-ehs header */
    kal_uint32      retx_1st_count;
    kal_uint32      retx_2nd_count;
    kal_uint32      retx_3rd_count;
    kal_uint32      total_tx_count;         /* Count of MAC-hs PDU or "MAC-ehs PDU" */
    kal_uint32      redundant_TSN_count;    /* Count of duplicated MAC-hs PDU or "MAC-ehs RO PDU" */
    kal_uint32      total_TSN_count;        /* Count of MAC-hs PDU or "MAC-ehs RO PDU" */
} fdd_em_umac_info_cell_hsdsch_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    fdd_em_umac_info_cell_hsdsch_struct     hsdsch_info[3]; /* [0] is Primary Cell; [1] is Secondary Cell */
} fdd_em_umac_info_hsdsch_ind_struct; /* for periodic (1s) hsdsch reporting */

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    FDD_em_urlc_status_struct FDD_em_urlc_status_struct_info;
} fdd_em_urlc_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    FDD_em_urlc_layer_tput_struct FDD_em_urlc_layer_tput_struct_info;
} fdd_em_urlc_layer_tput_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    FDD_em_urlc_att_rlc_statistics_struct FDD_em_urlc_att_rlc_statistics_struct_info;
} fdd_em_urlc_att_rlc_statistics_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    FDD_em_urlc_att_rlc_reset_struct FDD_em_urlc_att_rlc_reset_struct_info;
} fdd_em_urlc_att_rlc_reset_ind_struct;

#endif /* __UMTS_RAT__ */

/**************************************************************************
  * Here is the ERRC related EM definition
  *
  * Notes: ERRC structures is defined here
  * Michael: 2013/05/10:  Add ERRC EM related structures
  **************************************************************************/
/********************* begin of ERRC definition ****************************/
typedef struct
{
    EARFCN earfcn;
    kal_uint16 pci;
    kal_uint32 csg_id;
}em_errc_csg_info_struct;

#define EM_ERRC_MAX_AUTOS_CSG_CELL_NUM 10

typedef struct
{
    kal_uint8               num_cells;
    em_errc_csg_info_struct detected_csg_cell[EM_ERRC_MAX_AUTOS_CSG_CELL_NUM];
}em_errc_autos_info_struct;

typedef enum
{
    EM_ERRC_CARRS_TRIG_TYPE_NAS,
    EM_ERRC_CARRS_TRIG_TYPE_AS,
    EM_ERRC_CARRS_TRIG_TYPE_IRAT
}em_errc_carrs_trigger_type_enum;

typedef enum
{
    EM_ERRC_CARRS_TYPE_PLMN_LIST,
    EM_ERRC_CARRS_TYPE_CSG_LIST,
    EM_ERRC_CARRS_TYPE_FINGER_PRINT,
    EM_ERRC_CARRS_TYPE_MCC_LEARNING,
    EM_ERRC_CARRS_TYPE_BACKGROUND_SEARCH,
    EM_ERRC_CARRS_TYPE_AUTO_SEARCH,
    EM_ERRC_CARRS_TYPE_OOS
}em_errc_carrs_type_enum;

typedef struct
{
    em_errc_carrs_trigger_type_enum trigger_type;
    em_errc_carrs_type_enum         carrs_type;
}em_errc_carrs_event_struct;

typedef enum
{
    EM_ERRC_SIB_EVENT_3H_TIMEOUT,
    EM_ERRC_SIB_EVENT_SIB_MODIFY,
    EM_ERRC_SIB_EVENT_PWS
}em_errc_sib_event_enum;

typedef enum
{
    EM_ERRC_MOB_TYPE_CR,
    EM_ERRC_MOB_TYPE_REDT,
    EM_ERRC_MOB_TYPE_CCO,
    EM_ERRC_MOB_TYPE_HO,
    EM_ERRC_MOB_TYPE_REEST,
    EM_ERRC_MOB_TYPE_INTER_BAND_HO_CA2CA,
    EM_ERRC_MOB_TYPE_INTER_FREQ_HO_CA2CA,
    EM_ERRC_MOB_TYPE_INTRA_FREQ_HO_CA2CA
}em_errc_mob_type_enum;

typedef enum
{
    EM_ERRC_MOB_DIR_INTRA_LTE,
    EM_ERRC_MOB_DIR_TO_LTE,
    EM_ERRC_MOB_DIR_FROM_LTE
}em_errc_mob_dir_enum;

typedef struct
{
    em_errc_mob_type_enum           mob_type;
    em_errc_mob_dir_enum            mob_dir;
}em_errc_mob_event_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

}em_errc_mob_meas_info_ind_struct;

typedef enum
{
    EM_ERRC_RCM_SIM_STS_REMOVED,
    EM_ERRC_RCM_SIM_STS_INVALID_BY_NAS,
    EM_ERRC_RCM_SIM_STS_VALID
}em_errc_rcm_sim_sts_enum;

typedef enum
{
    EM_ERRC_SYS_SIB_RX_STS_IDLE,
    EM_ERRC_SYS_SIB_RX_STS_WAIT,
    EM_ERRC_SYS_SIB_RX_STS_CMPL,
    EM_ERRC_SYS_SIB_RX_STS_STORED
}em_errc_sys_sib_rx_sts_enum;

typedef struct
{
    kal_bool                    is_rxing;
    EARFCN                      earfcn;
    kal_uint16                  pci;
    em_errc_sys_sib_rx_sts_enum mib_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib1_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib2_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib3_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib4_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib5_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib6_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib7_rx_sts;
// #ifdef __CDMA2000_RAT__
    em_errc_sys_sib_rx_sts_enum sib8_rx_sts;
// #endif /* __CDMA2000_RAT__ */
    em_errc_sys_sib_rx_sts_enum sib9_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib10_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib11_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib12_rx_sts;
// #ifdef __LTE_R11__
    em_errc_sys_sib_rx_sts_enum sib13_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib14_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib15_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib16_rx_sts;
// #endif /* __LTE_R11__ */
}em_errc_sib_rx_info_struct;


/* VZW KPI: mibSibReadEvent */
typedef enum {
    EM_ANTENNAPORTSCOUNT_NUM_1       = 0,
    EM_ANTENNAPORTSCOUNT_NUM_2       = 1,
    EM_ANTENNAPORTSCOUNT_NUM_4       = 2,
    EM_ANTENNAPORTSCOUNT_NUM_8       = 3,
    EM_ANTENNAPORTSCOUNT_NUM_INVALID   = 0xFF
} em_el1_antn_port_num_enum;


typedef enum {
    EM_BW_6_RB        = 0,
    EM_BW_15_RB       = 1,
    EM_BW_25_RB       = 2,
    EM_BW_50_RB       = 3,
    EM_BW_75_RB       = 4,
    EM_BW_100_RB      = 5,
    EM_BW_INVALID     = 0xFF
} em_el1_bandwidth_enum;


typedef enum {
    EM_SYS_READ_STS_SUS  = 1,
    EM_SYS_READ_STS_FAIL = 2
} em_errc_sys_mibSibRead_sts_enum;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;   
    
    /* --- MIB 2.8.0 ---    
    MibSibReadEvent ::= CHOICE {
        readSuccess         MibSibContent,     -- read MIB or SIB messages successfully, either entirely or partialy
        readFail            NULL               -- fail to read MIB or SIB messages entirely
    }   
    */
    em_errc_sys_mibSibRead_sts_enum     read_sts_ind;
    
    /* --- MIB 2.8.0 ---    
    MibSibContent ::= CHOICE {
        mibContent              MibContent,             -- MIB content
        sibInfo                 SibInfo                 -- SIB Information
    }
    */
    kal_bool                            mib_Content_update_ind;
    
    kal_uint16                          pci;
    EARFCN                              earfcn;   
    em_el1_antn_port_num_enum           antenna_port_num; 
    em_el1_bandwidth_enum               dl_bandwith;

    /* --- MIB 2.8.0 ---
    * 
    SibInfo ::= SEQUENCE {
      systemInfoMsgNum          INTEGER (1..10),      -- Total number of different SIBs received by UE all together, count multiple SIBs when more than one SIBs with the same type is read 
      systemInfoMask            SEQUENCE OF SibType   -- List of SIB types mapped to systeminformation message, refer to "SIB-MappingInfo" in 3GPP TS 36.331. 
                                                        Only applicable to SIB1 message, for all other SIB messages, report a SEQUENCE with no element 
    * SibType ::= INTEGER {
        sib2 (2),
        sib3 (3),
        sib4 (4),
        sib5 (5),
        sib6 (6),
        sib7 (7),
        sib8 (8),
        sib9 (9),
        sib10 (10),
        sib11 (11),
        sib12 (12),
        sib13 (13),
        sib14 (14),
        sib15 (15),
        sib16 (16),
        sib17 (17),
        sib18 (18),
        sib19 (19)
    }
    */
    kal_uint8                          systemInfoMsgNum;
    kal_uint32                         systemInfoMask;

    /* --- MIB 2.6.2  ---
    * Bit mask for one or more SIB numbers which were successfully read (Bit 0 for SIB 1, Bit 1 for SIB 2, ...). 
    * For example, if sibMask=11, the binary format is 1011, which means SIB1, SIB2, SIB4 were read.
    */
    kal_uint32                          sibContent_mask;
}em_errc_sys_mib_sib_readevent_info_ind_struct;


/*MSG_ID_EM_ERRC_AUTOS_CSG_INFO_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_autos_info_struct autos_info;
}em_errc_autos_csg_info_ind_struct;

/*MSG_ID_EM_ERRC_CARRS_EVENT_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_carrs_event_struct carrs_evt;
}em_errc_carrs_event_ind_struct;


/*MSG_ID_EM_ERRC_SIB_EVENT_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_sib_event_enum sib_evt;
}em_errc_sib_event_ind_struct;


/*MSG_ID_EM_ERRC_MOB_EVENT_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_mob_event_struct mob_evt;
}em_errc_mob_event_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_bool                     key_chg_ind;
    //kal_uint32                   ul_nas_cnt;
    kal_uint8                    ncc;
    kal_uint8                      int_algo;
    kal_uint8                      enc_algo;
    //kal_uint8                    smc_maci[4];
    //kal_uint8                    gen_maci[4];
    //kal_uint8                    short_maci[2];
    //kal_uint8                    kasme[32];
    //kal_uint8                    kenb[32];
}em_errc_sec_param_ind_struct;

typedef enum
{
    EM_HO_FROM_LTE_TYPE_PS_HO,
    EM_HO_FROM_LTE_TYPE_SRVCC_HO,     //4G to 2.3G
    EM_HO_FROM_LTE_TYPE_PS_SRVCC_HO,  //4G to 3G
    EM_HO_FROM_LTE_TYPE_CCO,         //CCO to 2G
    EM_HO_FROM_LTE_TYPE_INVLID
}em_ho_from_lte_type_enum;

typedef enum
{
    EM_MFROM_UMTS_CELL,
    EM_MFROM_GSM_CELL,
    EM_MFROM_LTE_CELL
}em_mform_rat_type_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_mform_rat_type_enum target_rat;
    em_ho_from_lte_type_enum ir_ho_type;
}em_errc_mfrom_info_ind_struct;

typedef enum
{
    EM_ERRC_CONN_RLF_CFG_FAILURE,
    EM_ERRC_CONN_RLF_HO_FAILURE,
    EM_ERRC_CONN_RLF_RACH_PROBLEM,
    EM_ERRC_CONN_RLF_MAX_RETRANSMISSION,
    EM_ERRC_CONN_RLF_IP_CHECK_FAILURE,
    EM_ERRC_CONN_RLF_SIB_READING_FAILURE,
    EM_ERRC_CONN_RLF_MIB_CHANGE,
    EM_ERRC_CONN_RLF_OTHER
}em_errc_rlf_event_enum;

typedef enum
{
    //KPI tool will print trace for rlf_causeother,so only add enum
    EM_ERRC_CONN_RLF_OTHER_NONE = 0,         // report rlf counter when rrc release
    EM_ERRC_CONN_RLF_OTHER_RLF = 1,          // EL1 timer timeout
    EM_ERRC_CONN_RLF_OTHER_MFROM = 2
}em_errc_rlf_other_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    kal_uint8 rlf_counter;
    em_errc_rlf_event_enum rlf_cause;
    em_errc_rlf_other_enum rlf_causeother;
}em_errc_rlf_event_ind_struct;

typedef enum
{
    EM_ERRC_HO_OTHER,
    EM_ERRC_HO_INVALIDCFG,
    EM_ERRC_HO_CPHY,
    EM_ERRC_HO_RACH,
    EM_ERRC_HO_RACHMEAS,
    EM_ERRC_HO_SUCCESS,
    EM_ERRC_HO_FAILURE
}em_errc_ho_type_enum;

typedef struct
{
    kal_uint16 pci;
    kal_uint32 earfcn;
    kal_int32  rsrp;
}em_errc_ho_target_cell_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_ho_target_cell_info_struct targetcell;
    em_errc_ho_type_enum ho_result;
}em_errc_ho_event_ind_struct;

typedef enum
{
    ERRC_REEST_CAUSE_LTE_HO_FAIL,
    ERRC_REEST_CAUSE_LTE_MFROM_FAIL,
    ERRC_REEST_RLC_ACK_TIMEOUT,
    ERRC_REEST_SIB_UPDT_FAIL,
    ERRC_REEST_CAUSE_L1_RLF,
    ERRC_REEST_CAUSE_MAC_RLF,
    ERRC_REEST_CAUSE_RLC_UL_MAX_RLF,
    ERRC_REEST_CAUSE_RLC_DL_MAX_RLF,
    ERRC_REEST_CAUSE_RLC_UL_DL_MAX_RLF,
    ERRC_REEST_CAUSE_INTECHK_FAIL,
    ERRC_REEST_CAUSE_RECONF_FAIL,
    ERRC_REEST_CAUSE_PDCP_RLF,
    ERRC_REEST_CAUSE_DISABLE_B39,
    ERRC_REEST_CAUSE_GENERAL,
    ERRC_REEST_CAUSE_VIRTUAL_CONNECTED_LEAVE_FAIL
}em_errc_reest_info_cause_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_reest_info_cause_enum cause;
}em_errc_reest_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_bool is_ca_configured;
}em_errc_ca_info_ind_struct;

typedef enum
{
    ERRC_NORMAL_RECONF,
    ERRC_INTRA_CEL_HO,
    ERRC_INTER_CEL_HO,
    ERRC_INTER_RAT_HO
}em_errc_reconf_info_type_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_reconf_info_type_enum reconf_type;
    kal_bool                      is_cell_info_valid;
    EARFCN                        earfcn;
    kal_uint16                    pci;
    kal_uint16                    crnti;
    kal_uint32                    t311;
    kal_uint32                    t301;
    kal_uint32                    t304;
}em_errc_reconf_info_ind_struct;
typedef enum
{
    //This enum must be consistent with errc_procedure_id_enum
    EM_ERRC_PROC_EST,
    EM_ERRC_PROC_RECONF_RR_MEAS_CONFIG,
    EM_ERRC_PROC_RECONF_INTRALTEMOBILITY,
    EM_ERRC_PROC_REEST,
    EM_ERRC_PROC_INITIAL_SEC,
    EM_ERRC_UE_CAPABILITY,
    EM_ERRC_COUNTER_CHECK,
    EM_ERRC_UE_INFORMATION,
    EM_ERRC_PROC_IRAT_HO_FROM_LTE_TO_UMTS,
    EM_ERRC_PROC_IRAT_HO_FROM_LTE_TO_GSM,
    EM_ERRC_PROC_IRAT_CCO_FROM_LTE,
    EM_ERRC_PROC_IRAT_CR_FROM_LTE_TO_UMTS,
    EM_ERRC_PROC_IRAT_CR_FROM_LTE_TO_GSM,
    EM_ERRC_PROC_IRAT_REDIR_FROM_LTE_TO_UMTS,
    EM_ERRC_PROC_IRAT_REDIR_FROM_LTE_TO_GSM,
    EM_ERRC_PROC_IRAT_HO_TO_LTE,
    EM_ERRC_PROC_IRAT_CCO_TO_LTE,
    EM_ERRC_PROC_IRAT_CR_TO_LTE,
    EM_ERRC_PROC_IRAT_REDIR_TO_LTE,
    EM_ERRC_PROC_INTRA_REDIR
}em_errc_delay_proc_enum;

typedef struct
{
		LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_delay_proc_enum delay_proc_id;
    kal_uint32              delay_time;
}em_errc_over_proc_delay_warning_ind_struct;

typedef enum
{
    EM_RAT_NONE,
    EM_RAT_LTE,
    EM_RAT_UMTS,
    EM_RAT_GSM
}em_rat_enum;

typedef struct
{
    EARFCN      earfcn;
    kal_uint16  pci;
}em_lte_cell_info_struct;

typedef struct
{
    em_rat_enum rat_type;
    union
    {
        em_lte_cell_info_struct lte_cell;
    } cell_inf;
}em_general_cell_info_struct;

typedef enum
{
    EM_ERRC_NEW_CELL_CAUSE_INVALID = 0x0,
    EM_ERRC_NEW_CELL_CAUSE_CELLSELECTION,
    EM_ERRC_NEW_CELL_CAUSE_CELLRESELECTION,
    EM_ERRC_NEW_CELL_CAUSE_HANDOVER,
    EM_ERRC_NEW_CELL_CAUSE_REDIRECTION
}em_errc_new_cell_cause_enum;

typedef enum
{
    EM_ERRC_NEW_CELL_STATUS_INVALID = 0x0,
    EM_ERRC_NEW_CELL_STATUS_SUITABLE,
    EM_ERRC_NEW_CELL_STATUS_ACCEPTABLE
}em_errc_new_cell_status_enum;

typedef enum
{
    EM_ERRC_SUCCESS_RATE_KPI_INTRA_LTE_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G3_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G2_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_3G4_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_2G4_CR,

    EM_ERRC_SUCCESS_RATE_KPI_INTRA_CELL_HO,
    EM_ERRC_SUCCESS_RATE_KPI_INTER_CELL_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G3_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G2_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_3G4_HO,

    EM_ERRC_SUCCESS_RATE_KPI_LTE_FDD_TDD_CELL_HO,
    EM_ERRC_SUCCESS_RATE_KPI_LTE_TDD_FDD_CELL_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4GTDD_3G_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4GFDD_3G_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4GTDD_2G_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4GFDD_2G_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_3G_4GFDD_HO,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_3G_4GTDD_HO,

    EM_ERRC_SUCCESS_RATE_KPI_INTRA_LTE_FDDTDD_CR,
    EM_ERRC_SUCCESS_RATE_KPI_INTRA_LTE_TDDFDD_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD4G3_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD4G3_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD4G2_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD4G2_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD3G4_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD3G4_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD2G4_CR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD2G4_CR,

    EM_ERRC_SUCCESS_RATE_KPI_INTRA_LTE_FDDTDD_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_INTRA_LTE_TDDFDD_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD4G3_R8_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD4G3_R9_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD4G3_R10_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD4G3_R8_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD4G3_R9_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD4G3_R10_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD4G2_R8_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD4G2_R9_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD4G2_R10_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD4G2_R8_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD4G2_R9_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD4G2_R10_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD3G4_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD3G4_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD2G4_REDIRECT,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD2G4_REDIRECT,

    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD3G4_AFR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD3G4_AFR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD2G4_AFR,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD2G4_AFR,
    
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD3G4_BG_SRCH,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD3G4_BG_SRCH,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_FDD2G4_BG_SRCH,
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_TDD2G4_BG_SRCH,
    
    EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G2_CCO,
    EM_ERRC_SUCCESS_RATE_KPI_INTRA_LTE_CELLSELECTION,
    EM_ERRC_SUCCESS_RATE_KPI_INTRA_LTE_REDIRECT

}em_errc_success_rate_kpi_proc_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_success_rate_kpi_proc_enum proc_id;
    em_kpi_status_enum  status;
    kal_uint32  attempt;
    kal_uint32  success;
    em_kpi_failure_type_enum failure_type;
    em_errc_new_cell_cause_enum new_cell_cause;
    em_errc_new_cell_status_enum new_cell_status;

    kal_uint16 valid_bitmask;
#define EM_SUCC_RATE_KPI_FAILURE_TYPE_VALID  0x01
#define EM_SUCC_RATE_KPI_TARGET_CELL_VALID   0x02

    em_general_cell_info_struct target_cell;
}em_errc_success_rate_kpi_ind_struct;

typedef enum
{
    EM_ERRC_ON_DUARTION_PS1,
    EM_ERRC_ON_DUARTION_PS2,
    EM_ERRC_ON_DUARTION_PS3,
    EM_ERRC_ON_DUARTION_PS4,
    EM_ERRC_ON_DUARTION_PS5,
    EM_ERRC_ON_DUARTION_PS6,
    EM_ERRC_ON_DUARTION_PS8,
    EM_ERRC_ON_DUARTION_PS10,
    EM_ERRC_ON_DUARTION_PS20,
    EM_ERRC_ON_DUARTION_PS30,
    EM_ERRC_ON_DUARTION_PS40,
    EM_ERRC_ON_DUARTION_PS50,
    EM_ERRC_ON_DUARTION_PS60,
    EM_ERRC_ON_DUARTION_PS80,
    EM_ERRC_ON_DUARTION_PS100,
    EM_ERRC_ON_DUARTION_PS200,

    EM_ERRC_ON_DUARTION_INVALID = 0xFFFFFFFF,
}em_errc_on_duration_timer_enum;

typedef enum
{
    EM_ERRC_DRX_INACTIVITY_PS1,
    EM_ERRC_DRX_INACTIVITY_PS2,
    EM_ERRC_DRX_INACTIVITY_PS3,
    EM_ERRC_DRX_INACTIVITY_PS4,
    EM_ERRC_DRX_INACTIVITY_PS5,
    EM_ERRC_DRX_INACTIVITY_PS6,
    EM_ERRC_DRX_INACTIVITY_PS8,
    EM_ERRC_DRX_INACTIVITY_PS10,
    EM_ERRC_DRX_INACTIVITY_PS20,
    EM_ERRC_DRX_INACTIVITY_PS30,
    EM_ERRC_DRX_INACTIVITY_PS40,
    EM_ERRC_DRX_INACTIVITY_PS50,
    EM_ERRC_DRX_INACTIVITY_PS60,
    EM_ERRC_DRX_INACTIVITY_PS80,
    EM_ERRC_DRX_INACTIVITY_PS100,
    EM_ERRC_DRX_INACTIVITY_PS200,
    EM_ERRC_DRX_INACTIVITY_PS300,
    EM_ERRC_DRX_INACTIVITY_PS500,
    EM_ERRC_DRX_INACTIVITY_PS750,
    EM_ERRC_DRX_INACTIVITY_PS1280,
    EM_ERRC_DRX_INACTIVITY_PS1920,
    EM_ERRC_DRX_INACTIVITY_PS2560,
    EM_ERRC_DRX_INACTIVITY_PS0,

    EM_ERRC_DRX_INACTIVITY_INVALID = 0xFFFFFFFF,
}em_errc_drx_inactivity_timer_enum;

typedef enum
{
    EM_ERRC_DRX_RETX_TIMER_PS1,
    EM_ERRC_DRX_RETX_TIMER_PS2,
    EM_ERRC_DRX_RETX_TIMER_PS4,
    EM_ERRC_DRX_RETX_TIMER_PS6,
    EM_ERRC_DRX_RETX_TIMER_PS8,
    EM_ERRC_DRX_RETX_TIMER_PS16,
    EM_ERRC_DRX_RETX_TIMER_PS24,
    EM_ERRC_DRX_RETX_TIMER_PS33,
    EM_ERRC_DRX_RETX_TIMER_PS0,

    EM_ERRC_DRX_RETX_TIMER_INVALID = 0xFFFFFFFF,
}em_errc_drx_retx_timer_enum;

typedef enum
{
    EM_ERRC_LONG_DRX_CYCLE_10,
    EM_ERRC_LONG_DRX_CYCLE_20,
    EM_ERRC_LONG_DRX_CYCLE_32,
    EM_ERRC_LONG_DRX_CYCLE_40,
    EM_ERRC_LONG_DRX_CYCLE_64,
    EM_ERRC_LONG_DRX_CYCLE_80,
    EM_ERRC_LONG_DRX_CYCLE_128,
    EM_ERRC_LONG_DRX_CYCLE_160,
    EM_ERRC_LONG_DRX_CYCLE_256,
    EM_ERRC_LONG_DRX_CYCLE_320,
    EM_ERRC_LONG_DRX_CYCLE_512,
    EM_ERRC_LONG_DRX_CYCLE_640,
    EM_ERRC_LONG_DRX_CYCLE_1024,
    EM_ERRC_LONG_DRX_CYCLE_1280,
    EM_ERRC_LONG_DRX_CYCLE_2048,
    EM_ERRC_LONG_DRX_CYCLE_2560,
    EM_ERRC_LONG_DRX_CYCLE_60,
    EM_ERRC_LONG_DRX_CYCLE_70,

    EM_ERRC_LONG_DRX_CYCLE_INVALID = 0xFFFFFFFF,
}em_errc_long_drx_cycle_enum;

typedef enum
{
    EM_ERRC_SHORT_DRX_CYCLE_2,
    EM_ERRC_SHORT_DRX_CYCLE_5,
    EM_ERRC_SHORT_DRX_CYCLE_8,
    EM_ERRC_SHORT_DRX_CYCLE_10,
    EM_ERRC_SHORT_DRX_CYCLE_16,
    EM_ERRC_SHORT_DRX_CYCLE_20,
    EM_ERRC_SHORT_DRX_CYCLE_32,
    EM_ERRC_SHORT_DRX_CYCLE_40,
    EM_ERRC_SHORT_DRX_CYCLE_64,
    EM_ERRC_SHORT_DRX_CYCLE_80,
    EM_ERRC_SHORT_DRX_CYCLE_128,
    EM_ERRC_SHORT_DRX_CYCLE_160,
    EM_ERRC_SHORT_DRX_CYCLE_256,
    EM_ERRC_SHORT_DRX_CYCLE_320,
    EM_ERRC_SHORT_DRX_CYCLE_512,
    EM_ERRC_SHORT_DRX_CYCLE_640,
    EM_ERRC_SHORT_DRX_CYCLE_4,

    EM_ERRC_SHORT_DRX_CYCLE_INVALID = 0xFFFFFFFF,
}em_errc_short_drx_cycle_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_on_duration_timer_enum on_duration_timer_index;
    em_errc_drx_inactivity_timer_enum drx_inactivity_timer_index;
    em_errc_drx_retx_timer_enum drx_retx_timer_index;
    em_errc_long_drx_cycle_enum long_drx_cycle_index;
    em_errc_short_drx_cycle_enum short_drx_cycle_index;
    kal_uint8 drx_short_cycle_timer; /* 1-16; invalid: 0xFF */
    kal_uint16 drx_start_offset; /* 0 - 2559; Invalid: 0xFFFF */
}em_errc_config_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

   em_errc_rcm_sim_sts_enum   sim_sts;
}em_errc_rcm_sim_sts_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

   em_errc_sib_rx_info_struct   sib_rx_info[4]; /*Serving BCCH, Neighbor BCCH1, Neighbor BCCH2, SCell BCCH*/
}em_errc_sys_sib_rx_sts_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_state_enum errc_sts;
}em_errc_state_ind_struct;


/* MSG_ID_EM_LTE_SUPPORTED_BAND_INFO_IND */
#ifdef __BAND_EXTENSION_SUPPORT__
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16   num_supported_band;
    kal_uint16   supported_band[256];
}em_lte_supported_band_info_ind_struct;
#else
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8    num_supported_band;
    kal_uint8    supported_band[64];
}em_lte_supported_band_info_ind_struct;
#endif


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_bool with_3g_neighbor;
    kal_bool with_2g_neighbor;
}em_errc_serv_ir_neighbor_info_ind_struct;

typedef enum
{
    EM_ERRC_EVENT_REDIR_FROM_LTE_TO_GSM_R8,
    EM_ERRC_EVENT_REDIR_FROM_LTE_TO_UMTS_R8,
    EM_ERRC_EVENT_REDIR_FROM_LTE_TO_GSM_R9_LATER,
    EM_ERRC_EVENT_REDIR_FROM_LTE_TO_UMTS_R9_LATER
}em_errc_ir_redir_event_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_ir_redir_event_enum redir_event;
    kal_bool is_csfb_ongoing;
}em_errc_ir_redir_event_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_bool utran_meas_cfg;
    kal_bool geran_meas_cfg;
    kal_bool c2k_meas_cfg;
}em_errc_irat_meas_cfg_ind_struct;

/*MSG_ID_EM_ERRC_SERVING_INFO_IND*/

typedef enum
{
    EM_ERRC_DEFAULT_PAGING_CYCLE_32,
    EM_ERRC_DEFAULT_PAGING_CYCLE_64,
    EM_ERRC_DEFAULT_PAGING_CYCLE_128,
    EM_ERRC_DEFAULT_PAGING_CYCLE_256,
    EM_ERRC_DEFAULT_PAGING_CYCLE_INVALID = 0xFF
}em_errc_default_paging_cycle_enum;

typedef struct
{
    kal_uint32    dl_earfcn;
    kal_uint32    ul_earfcn;
    kal_uint16    pci;
    kal_uint32    cell_id;/*28 bits*/
    kal_uint16    ta_code;
    kal_uint16    dl_bandwidth; /*unit:100kHz*/
    kal_uint16    ul_bandwidth; /*unit:100kHz*/
    kal_bool      ims_emergency_supported;
    kal_bool      csg_ind;
    kal_uint32    csg_id;/* 27 bits, 0xFFFFFFFF means invalid*/
    kal_bool      high_speed_flg;
    em_errc_default_paging_cycle_enum  def_paging_cycle;  
}em_errc_serv_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_bool                  is_serving_inf_valid;
    em_errc_serv_info_struct  serv_inf;    
}em_errc_serving_info_ind_struct;

typedef enum
{
    EM_ERRC_TIMER_T300,
    EM_ERRC_TIMER_T301,
    EM_ERRC_TIMER_T302,
    EM_ERRC_TIMER_T303,
    EM_ERRC_TIMER_T304,
    EM_ERRC_TIMER_T305,
    EM_ERRC_TIMER_T311,
    EM_ERRC_TIMER_T320,
    EM_ERRC_TIMER_T321,
    EM_ERRC_TIMER_OTHER
}em_errc_timer_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_timer_enum  tmr_type;    
}em_errc_timer_expiry_event_ind_struct;

typedef enum
{
    EM_ERRC_PAGING_FAIL_CAUSE_PDSCH_CRCNG
}em_errc_paging_fail_cause_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_paging_fail_cause_enum cause;
}em_errc_paging_fail_ind_struct;

//#ifdef __LTE_R11__
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32 pcell_earfcn;
    kal_uint16 pcell_band;
    kal_uint16 pcell_pci;
    kal_uint8  pcell_bw;
    kal_uint8  unused[3];

    kal_bool   is_scell_configured[4];
    kal_uint32 scell_earfcn[4];
    kal_uint16 scell_band[4];
    kal_uint16 scell_pci[4];
    kal_uint8  scell_bw[4];
}em_errc_conn_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_lte_rrc_state_enum errc_state;
    em_lte_rrc_cause_enum errc_cause;

} em_lte_rrc_state_ind_struct;
//#endif

#define MOB_EM_UPDATE_MAX_INTRA_CELL_QUAN 16
#define MOB_EM_UPDATE_MAX_INTER_FREQ_QUAN 4
#define MOB_EM_UPDATE_MAX_INTER_FREQ_CELLS_QUAN 6
#define MOB_EM_UPDATE_MAX_IR_UTRAN_FREQ_QUAN 16
#define MOB_EM_UPDATE_MAX_IR_GERAN_CELL_QUAN 6
#define MOB_EM_UPDATE_MAX_IR_UTRAN_CELL_QUAN 6
#define MOB_EM_UPDATE_MAX_SCELL_QUAN 7
#define MOB_EM_UPDATE_MAX_S_INTRA_INFO_QUAN 2

#define MOB_EM_UPDATE_MAX_IR_C2K_BAND_QUAN 5 /* C2K support band, our chip allow customer to select at most 5 band 
                                              * from the following 7 band {BC0, BC1, BC4, BC6, BC10, BC14, BC15}
                                              * So LTE need to support 5 C2K band measurement at same time */
#define MOB_EM_UPDATE_MAX_IR_C2K_FREQ_QUAN 8 /* Align max freq number in MOB MRM/MIM table */
#define MOB_EM_UPDATE_MAX_IR_C2K_CELL_QUAN 40

typedef enum _errc_mob_em_spj_state_enum{
    MOB_EM_HIGH_MOBILITY,
    MOB_EM_MEDIUM_MOBILITY,
    MOB_EM_NORMAL_MOBILITY
}errc_mob_em_spj_state_enum;

typedef enum {
    MOB_EM_MEAS_BANDWIDTH_6_RB,
    MOB_EM_MEAS_BANDWIDTH_15_RB,
    MOB_EM_MEAS_BANDWIDTH_25_RB,
    MOB_EM_MEAS_BANDWIDTH_50_RB,
    MOB_EM_MEAS_BANDWIDTH_75_RB,
    MOB_EM_MEAS_BANDWIDTH_100_RB,
    MOB_EM_MEAS_BANDWIDTH_INVALID=0xFF
}errc_mob_em_bandwidth_enum;

typedef enum {
    MOB_EM_FDD,
    MOB_EM_TDD
}errc_mob_em_duplex_type_enum;

typedef struct _errc_mob_em_scell_info_struct{
    kal_uint32 earfcn;
    kal_uint16 pci;
    kal_int32 rsrp;
    kal_int32 rsrq;
    kal_int32 rs_snr_in_qdb;
    kal_uint16 serv_lte_band;
}errc_mob_em_scell_info_struct;

typedef struct _errc_mob_em_scell_info_list_struct{
    kal_uint8 num_scell;
    errc_mob_em_scell_info_struct scell_info[MOB_EM_UPDATE_MAX_SCELL_QUAN];
}errc_mob_em_scell_info_list_struct;

typedef struct _errc_mob_em_serving_info_struct{
    kal_uint32 earfcn;
    kal_uint16 pci;
    kal_int32 rsrp;
    kal_int32 rsrq;
    kal_int32 rs_snr_in_qdb;
    kal_uint16 serv_lte_band;
    errc_mob_em_spj_state_enum mobility_state;
    kal_uint8 S_intra_search_p;
    kal_uint8 S_intra_search_q;
    kal_uint8 S_nonintra_search_p;
    kal_uint8 S_nonintra_search_q;
    kal_uint8 thresh_serving_low_p;
    kal_uint8 thresh_serving_low_q;
    kal_uint8 tresel;
    errc_mob_em_bandwidth_enum DlBandwidth;
    errc_mob_em_bandwidth_enum UlBandwidth;
}errc_mob_em_serving_info_struct;

typedef struct _errc_mob_em_intrarat_intra_info_ecell_struct{
    kal_bool valid;
    kal_uint16 pci;
    kal_int32 rsrp;
    kal_int32 rsrq;
    kal_bool is_detected_cell;
    kal_bool is_barred_cell;
    kal_int16 rsrp0;
    kal_int16 rsrp1;
    kal_int16 rsrq0;
    kal_int16 rsrq1;
    kal_int16 rssi;
    kal_int16 rssi0;
    kal_int16 rssi1;
}errc_mob_em_intrarat_intra_info_ecell_struct;

typedef struct _errc_mob_em_intrarat_intra_info_struct{
    kal_int8 priority;
    errc_mob_em_bandwidth_enum bandwidth;
    kal_bool is_blacklist_present;
    kal_uint16 pcomp;
    errc_mob_em_duplex_type_enum duplex_type;
    kal_uint8 subframe_nb;
    kal_uint16 frame_nb;
    kal_uint8 cell_num;
    errc_mob_em_intrarat_intra_info_ecell_struct intra_cell[MOB_EM_UPDATE_MAX_INTRA_CELL_QUAN];
}errc_mob_em_intrarat_intra_info_struct;

typedef struct _errc_mob_em_intrarat_inter_info_ecell_struct{
    kal_bool valid;
    kal_uint16 pci;
    kal_int32 rsrp;
    kal_int32 rsrq;
    kal_bool is_detected_cell;
    kal_bool is_barred_cell;
    kal_int16 rsrp0;
    kal_int16 rsrp1;
    kal_int16 rsrq0;
    kal_int16 rsrq1;
    kal_int16 rssi;
    kal_int16 rssi0;
    kal_int16 rssi1;
}errc_mob_em_intrarat_inter_info_ecell_struct;

typedef struct _errc_mob_em_intrarat_inter_info_inter_freq_struct{
    kal_bool valid;
    kal_uint32 earfcn;
    kal_uint16 pcomp;
    kal_int8 priority;
    errc_mob_em_bandwidth_enum bandwidth;
    kal_bool is_blacklist_present;
    kal_uint8 treselection;
    kal_uint8 thresh_x_high_p;
    kal_uint8 thresh_x_high_q;
    kal_uint8 thresh_x_low_p;
    kal_uint8 thresh_x_low_q;
    errc_mob_em_duplex_type_enum duplex_type;
    kal_uint8 subframe_nb;
    kal_uint16 frame_nb;
    kal_uint8 cell_num;
    errc_mob_em_intrarat_inter_info_ecell_struct inter_cell[MOB_EM_UPDATE_MAX_INTER_FREQ_CELLS_QUAN];
}errc_mob_em_intrarat_inter_info_inter_freq_struct;

typedef struct _errc_mob_em_intrarat_inter_info_struct{
    kal_uint8 freq_num;
    errc_mob_em_intrarat_inter_info_inter_freq_struct inter_freq[MOB_EM_UPDATE_MAX_INTER_FREQ_QUAN];
}errc_mob_em_intrarat_inter_info_struct;


typedef struct _errc_mob_em_intrarat_s_intra_info_s_intra_freq_struct{
    kal_bool valid;
    kal_uint32 earfcn;
    kal_int8 priority;
	errc_mob_em_bandwidth_enum bandwidth;
    kal_bool is_blacklist_present;
    kal_uint16 pcomp;
    errc_mob_em_duplex_type_enum duplex_type;
    kal_uint8 subframe_nb;
    kal_uint16 frame_nb;
    kal_uint8 cell_num;
    errc_mob_em_intrarat_intra_info_ecell_struct s_intra_cell[MOB_EM_UPDATE_MAX_INTRA_CELL_QUAN];
}errc_mob_em_intrarat_s_intra_info_s_intra_freq_struct;

typedef struct _errc_mob_em_intrarat_s_intra_info_struct{
    kal_uint8 num_scell;
    errc_mob_em_intrarat_s_intra_info_s_intra_freq_struct s_intra_freq[MOB_EM_UPDATE_MAX_S_INTRA_INFO_QUAN];
}errc_mob_em_intrarat_s_intra_info_struct;


typedef struct _em_errc_mob_meas_intrarat_info_ind_struct{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    errc_mob_em_serving_info_struct serving_info;
    errc_mob_em_intrarat_intra_info_struct intra_info;
    errc_mob_em_intrarat_inter_info_struct inter_info;
    errc_mob_em_scell_info_list_struct scell_info_list;
    errc_mob_em_intrarat_s_intra_info_struct s_intra_info_list;
}em_errc_mob_meas_intrarat_info_ind_struct;

typedef struct _em_errc_srvcc_bsic_info_ind_struct{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16 arfcn;
    kal_uint8 bsic;
}em_errc_srvcc_bsic_info_ind_struct;

typedef struct _errc_mob_em_ir_geran_gcell_struct{
    kal_bool valid; /*only used in sorting the em result*/
    kal_int8 priority;
    kal_bool band_ind;
    kal_uint16 arfcn;
    kal_uint8 bsic;
    kal_int32 rssi;
    kal_uint8 thresh_x_high;
    kal_uint8 thresh_x_low;
}errc_mob_em_ir_geran_gcell_struct;

typedef struct _errc_mob_em_ir_utran_ucell_struct{
    kal_bool valid;
    kal_uint16 psc;
    kal_int32 rscp;
    kal_int32 ec_n0;
}errc_mob_em_ir_utran_ucell_struct;

typedef struct _errc_mob_em_ir_utran_freq_struct{
    kal_bool valid;
    kal_uint16 uarfcn;
    kal_int8 priority;
    kal_uint8 threshx_high_p;
    kal_uint8 threshx_high_q;
    kal_uint8 threshx_low_p;
    kal_uint8 threshx_low_q;
    kal_uint8 ucell_num;
    errc_mob_em_ir_utran_ucell_struct ucell[MOB_EM_UPDATE_MAX_IR_UTRAN_CELL_QUAN];
}errc_mob_em_ir_utran_freq_struct;

typedef struct
{
    kal_uint16 pn;
    kal_int16 phase;
    kal_uint8 strength;
}errc_mob_em_ir_c2k_cell_struct;

typedef struct 
{
   kal_bool valid;
   kal_uint16 channel;
   kal_bool is_search_win_size_valid;
   kal_uint8 search_win_size;
   kal_uint8 num_pn;
   errc_mob_em_ir_c2k_cell_struct pn_list[MOB_EM_UPDATE_MAX_IR_C2K_CELL_QUAN];
}errc_mob_em_ir_c2k_freq_struct;

typedef struct 
{
    kal_bool valid;
    kal_uint8 band;
    kal_int8 prio;
    kal_uint8 threshx_high;
    kal_uint8 threshx_low;
    kal_uint8 freq_num;
    errc_mob_em_ir_c2k_freq_struct freq[MOB_EM_UPDATE_MAX_IR_C2K_FREQ_QUAN];
}errc_mob_em_ir_c2k_band_struct;

typedef struct _em_errc_mob_meas_interrat_geran_info_ind_struct{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 total_gcell_num;
    errc_mob_em_ir_geran_gcell_struct gcell[MOB_EM_UPDATE_MAX_IR_GERAN_CELL_QUAN];
}em_errc_mob_meas_interrat_geran_info_ind_struct;

typedef struct _em_errc_mob_meas_interrat_utran_info_ind_struct{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 freq_num;
    errc_mob_em_ir_utran_freq_struct inter_freq[MOB_EM_UPDATE_MAX_IR_UTRAN_FREQ_QUAN];
}em_errc_mob_meas_interrat_utran_info_ind_struct;

typedef struct _em_errc_mob_meas_interrat_c2k_info_ind_struct{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 band_num;
    errc_mob_em_ir_c2k_band_struct band_list[MOB_EM_UPDATE_MAX_IR_C2K_BAND_QUAN];
}em_errc_mob_meas_interrat_c2k_info_ind_struct;

typedef enum
{
    EM_ERRC_MOB_EVENT_TYPE_B_INVALID,
    EM_ERRC_MOB_EVENT_TYPE_B_1,
    EM_ERRC_MOB_EVENT_TYPE_B_2
} MobEmInfoEventTypeB;

typedef enum
{
    EM_ERRC_MOB_MEAS_QTY_INVALID,
    EM_ERRC_MOB_MEAS_QTY_RSRP,
    EM_ERRC_MOB_MEAS_QTY_RSRQ
} MobEmMeasQty;

typedef enum
{
    EM_ERRC_MOB_MEAS_QTY_FOR_OTHER_RAT_INVALID,
    EM_ERRC_MOB_MEAS_QTY_GSM_RSSI,
    EM_ERRC_MOB_MEAS_QTY_UTRA_RSCP,
    EM_ERRC_MOB_MEAS_QTY_UTRA_ECN0
} MobEmMeasQtyForOtherRAT;

typedef struct {
    kal_uint8   MeasId;
    MobEmInfoEventTypeB   EventType;
    MobEmMeasQty MeasQty;
    MobEmMeasQtyForOtherRAT MeasQtyOtherRAT;
    kal_uint8   fc_OtherSys;
    kal_uint8   fc_OwnSys;
    kal_int16   ThresholdOwnSystem;
    kal_int16   ThresholdOtherSystem;
    kal_uint8   Hystersis;
    kal_uint16  TimeToTrigger;
} event_B_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_B_struct em_event_info[2];
} em_errc_mob_meas_config_info_ind_struct;


typedef struct {
    kal_uint8   MeasId;
    MobEmInfoEventTypeB   EventType;
} em_errc_mob_report_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_mob_report_struct em_report_info;
}em_errc_mob_meas_report_info_ind_struct;


typedef enum
{
    ERRC_FEAT_MFBI_PRIORITIZATION,
    ERRC_FEAT_AC_BAR_SKIP_MMTEL_VOICE,
    ERRC_FEAT_AC_BAR_SKIP_MMTEL_VIDEO,
    ERRC_FEAT_AC_BAR_SKIP_SMS,
    ERRC_FEAT_PLMN_SPECIFIC_AC_BAR,
    ERRC_FEAT_PLMN_SPECIFIC_SSAC,
    ERRC_FEAT_RRC_CONN_TEMP_FAIL_OFFSET,
    ERRC_FEAT_INCMON_EUTRA,
    ERRC_FEAT_INCMON_UTRA,
    ERRC_FEAT_CELL_SPECIFIC_TTT,
    ERRC_FEAT_FAST_RLF_REC_WITH_T312,
    ERRC_FEAT_RSRQ_LOWER_VALUE_RANGE_EXT,
    ERRC_FEAT_ENH_HARQ_TTI_BUND_FOR_FDD,
    ERRC_FEAT_LOG_CH_SR_PROHIBIT_TIMER,
    ERRC_FEAT_MOB_HIST_REPORTING,
    ERRC_FEAT_SHORTER_MCH_SCHED_PERIOD,
    ERRC_FEAT_IDC_ENH_FOR_UL_CA,
    ERRC_FEAT_LOGGED_MDT,
    ERRC_FEAT_IMMED_MDT,
    ERRC_FEAT_EICIC_SF_PATTERN,
    ERRC_FEAT_EICIC_DEDICATED_SIB1,
    ERRC_FEAT_MBSFN_AREA_DETECTED,
    ERRC_FEAT_UL_64QAM_DETECTED, 
    ERRC_FEAT_EAB_DETECTED 
}em_errc_feat_enum;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_feat_enum detected_feature;
}em_errc_feature_detection_ind_struct;

typedef enum
{
    EM_ERRC_LTE_RRC_MSG_CLASS_BCCH_BCH,
    EM_ERRC_LTE_RRC_MSG_CLASS_BCCH_DL_SCH,
    EM_ERRC_LTE_RRC_MSG_CLASS_MCCH,
    EM_ERRC_LTE_RRC_MSG_CLASS_PCCH,
    EM_ERRC_LTE_RRC_MSG_CLASS_DL_CCCH,
    EM_ERRC_LTE_RRC_MSG_CLASS_DL_DCCH,
    EM_ERRC_LTE_RRC_MSG_CLASS_UL_CCCH,
    EM_ERRC_LTE_RRC_MSG_CLASS_UL_DCCH,
    EM_ERRC_LTE_RRC_MSG_CLASS_END = 0x7fffffff //end tag force this enum 4 bytes, for alignment purpose. Don't remove
} em_errc_msg_class_enum;

typedef enum
{
    /* BCCH-BCH-Message */
    EM_ERRC_LTE_RRC_BCCH_BCH_MSG_MASTER_INFO_BLK,
    /* BCCH-DL-SCH-Message */
    EM_ERRC_LTE_RRC_BCCH_DL_SCH_MSG_SYS_INFO,
    EM_ERRC_LTE_RRC_BCCH_DL_SCH_MSG_SYS_INFO_BLK_TYPE1,
    /* MCCH-Message */
    EM_ERRC_LTE_RRC_MCCH_MSG_MBSFN_AREA_CFG,
    EM_ERRC_LTE_RRC_MCCH_MSG_MBMS_COUNTING_REQ,
    /* PCCH-Message */
    EM_ERRC_LTE_RRC_PCCH_MSG_PAGING,
    /* DL-CCCH-Message */
    EM_ERRC_LTE_RRC_DL_CCCH_MSG_RRC_CONN_REEST,
    EM_ERRC_LTE_RRC_DL_CCCH_MSG_RRC_CONN_REEST_REJ,
    EM_ERRC_LTE_RRC_DL_CCCH_MSG_RRC_CONN_REJ,
    EM_ERRC_LTE_RRC_DL_CCCH_MSG_RRC_CONN_SETUP,
    /* DL-DCCH-Message */
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_CSFB_PARAM_RESP,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_DL_INFO_TRANSFER,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_HO_FROM_EUTRA_REQ,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_MOB_FROM_EUTRA_CMD,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_RRC_CONN_RECFG,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_RRC_CONN_REL,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_SECURE_MODE_CMD,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_UE_CAP_ENQ,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_CNTR_CHECK,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_UEINFO_REQ,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_LOGGED_MEAS_CFG,
    EM_ERRC_LTE_RRC_DL_DCCH_MSG_RN_RECFG,
    /* UL-CCCH-Message */
    EM_ERRC_LTE_RRC_UL_CCCH_MSG_RRC_CONN_REEST_REQ,
    EM_ERRC_LTE_RRC_UL_CCCH_MSG_RRC_CONN_REQ,
    /* UL-DCCH-Message */
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_CSFB_PARAM_REQ,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_MEAS_REPORT,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_RRC_CONN_RECFG_CMP,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_RRC_CONN_REEST_CMP,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_RRC_CONN_SETUP_CMP,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_SECURE_MODE_CMP,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_SECURE_MODE_FAIL,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_UE_CAP_INFO,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_HO_PREP_TXR,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_INFO_TXR,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_CNTR_CHK_RESP,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_UEINFO_RESP,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_PROX_IND,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_RN_RECFG_CMP,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_MBMS_COUNTING_RESP,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_INTER_FREQ_RSTD_MEAS_IND,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_UEA_INFO,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_IDC_IND,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_MII,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_SCG_FAIL_INFO,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_SL_UEINFO,
    EM_ERRC_LTE_RRC_UL_DCCH_MSG_WLAN_CONN_STS_REPORT,
    EM_ERRC_LTE_RRC_MSG_TYPE_END = 0x7fffffff //end tag force this enum 4 bytes, for alignment purpose. Don't remove
} em_errc_msg_type_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_msg_class_enum msg_class;
    em_errc_msg_type_enum msg_type;
    kal_uint32 raw_data_len;
    kal_uint8 raw_data[ERRC_MAX_EUTRA_RRC_MESSAGE_S_DATA_LEN];
}em_errc_eutra_rrc_message_s_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_msg_class_enum msg_class;
    em_errc_msg_type_enum msg_type;
    kal_uint32 raw_data_len;
    kal_uint8 raw_data[ERRC_MAX_EUTRA_RRC_MESSAGE_M_DATA_LEN];
}em_errc_eutra_rrc_message_m_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    em_errc_msg_class_enum msg_class;
    em_errc_msg_type_enum msg_type;
    kal_uint32 raw_data_len;
    kal_uint8 raw_data[ERRC_MAX_EUTRA_RRC_MESSAGE_L_DATA_LEN];
}em_errc_eutra_rrc_message_l_ind_struct;

typedef struct
{
	kal_uint32    earfcn;
	kal_uint16    pci;
	kal_int32     rsrp;
	kal_int32     rsrq;
}em_errc_srvcc_cell_info_pcell_struct;

typedef enum
{
	EM_ERRC_NOT_IN_SRVCC_DURATION                = 0,
	EM_ERRC_SRVCC_FAIL_THRESHOLD_NOT_PASS        = 1,
	EM_ERRC_SRVCC_BSIC_DECODE_FAIL               = 2,
	EM_ERRC_SRVCC_FAIL_TTT_NOT_PASS              = 3,
	EM_ERRC_SRVCC_FAIL_TTT_RECOUNT               = 4,
	EM_ERRC_SRVCC_FAIL_MEAS_RPT_SEND_FAIL        = 5,
	EM_ERRC_SRVCC_FAIL_MEAS_RPTE_NO_RESPONSE     = 6
}em_errc_srvcc_fail_type_enum;

typedef struct
{
	kal_uint16    psc;
	kal_int32     rsrp;
	kal_int32     ec_no;
}em_errc_srvcc_cell_info_ucell_struct; 

typedef struct
{
	kal_uint8                                meas_id;
	em_errc_srvcc_fail_type_enum             cause;
	kal_uint32                               uarfcn;
	kal_uint8                                utran_cell_num;
	em_errc_srvcc_cell_info_ucell_struct     utran_cell_list[8];
}em_errc_srvcc_rpt_utran_struct;

typedef struct
{
	kal_uint16    arfcn;
    kal_bool      band_ind;
	kal_uint8     bsic;
	kal_int32     rssi;
}em_errc_srvcc_cell_info_gcell_struct;

typedef struct
{
	kal_uint8                               meas_id;
	em_errc_srvcc_fail_type_enum            cause;
	kal_uint8                               geran_cell_num;
	em_errc_srvcc_cell_info_gcell_struct    geran_cell_list[8];
}em_errc_srvcc_rpt_geran_struct;


typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum em_info;
	
	em_errc_srvcc_cell_info_pcell_struct    serving_info;
	kal_uint8                               utran_rpt_num;
	em_errc_srvcc_rpt_utran_struct          utran_rpt_list[2];
	kal_uint8                               geran_rpt_num;
	em_errc_srvcc_rpt_geran_struct          geran_rpt_list[2];
}em_errc_srvcc_cell_info_ind_struct;

typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum em_info;
	
	kal_bool      gcell_exist;
	kal_uint16    gcell_arfcn;
	kal_bool      ucell_exist;
	kal_uint32    ucell_uarfcn;
	kal_uint16    ucell_psc;
}em_errc_srvcc_ho_fail_event_ind_struct;
/********************* end of ERRC definition ****************************/


/********************* begin of EMM definition ****************************/

typedef enum
{
    EM_EMM_EU1_UPDATE = 0,
    EM_EMM_EU2_NOT_UPDATE,
    EM_EMM_EU3_ROAMING_NOT_ALLOWED
} em_emm_update_status_enum;

typedef enum
{
    EM_EMM_SIM_REMOVE,
    EM_EMM_SIM_INVALID,
    EM_EMM_SIM_VALID,
} em_emm_sim_status_enum;

typedef enum
{
    EM_EMM_TIN_DELETED    = 0,
    EM_EMM_TIN_PTMSI,
    EM_EMM_TIN_RAT_RELATED_TMSI,
    EM_EMM_TIN_GUTI
} em_emm_tin_enum;

typedef struct
{
    plmn_struct  plmn_id;
    kal_uint8   mme_gid[2];
    kal_uint8   mme_code;
    kal_uint8   mtmsi[4];
} em_emm_guti_struct;

typedef enum
{
    EM_ECM_IDLE=0,
    EM_ECM_CONNECTED
}em_emm_ecm_status_enum;

typedef enum
{
    EM_NORMAL_CELL    = 0,
    EM_CSG_CELL,
    EM_HYBRID_CELL
} em_csg_access_mode_enum;

typedef enum
{
    EM_DUPLEX_TYPE_FDD    = 0,
    EM_DUPLEX_TYPE_TDD,
    EM_DUPLEX_TYPE_UNKNOWN
} em_lte_duplex_type_enum;

typedef enum
{
    EM_TYPE_NONE                    = 0,
    EM_TYPE_SERVICE_REQ,
    EM_TYPE_EXTENDED_SERVICE_REQ,
    EM_TYPE_MAX
} em_sr_type_enum;

typedef enum
{
    EM_CAUSE_MO_SIGNAL              = 0,
    EM_CAUSE_MO_DATA,
    EM_CAUSE_MT,
    EM_CAUSE_EMERGENCY,
    EM_CAUSE_INVALID
} em_sr_cause_enum;

typedef enum
{
    EM_MO_CSFB_TYPE_INVALID         = 0,
    EM_MO_CSFB_TYPE_NORMAL_CALL,
    EM_MO_CSFB_TYPE_EMERGENCY_CALL,
    EM_MO_CSFB_TYPE_SS,
    EM_MO_CSFB_TYPE_LCS,
    EM_MO_CSFB_TYPE_RESERVED
} em_mo_csfb_cause_enum;

typedef enum
{
    EM_MT_CSFB_PAGING_ID_INVALID    = 0,
    EM_MT_CSFB_PAGING_ID_IMSI,
    EM_MT_CSFB_PAGING_ID_TMSI
} em_mt_csfb_paging_id_enum;

typedef enum
{
    EM_EMM_CAUSE_CAUSE_NONE = 0x00,
    EM_EMM_CAUSE_IMSI_UNKNOWN_IN_HSS    = 0x02,
    EM_EMM_CAUSE_ILLEGAL_UE    = 0x03,
    EM_EMM_CAUSE_IMEI_NOT_ACCEPTED    = 0x05,
    EM_EMM_CAUSE_ILLEGAL_ME    = 0x06,
    EM_EMM_CAUSE_EPS_NOT_ALLOWED    = 0x07,
    EM_EMM_CAUSE_EPS_NON_EPS_NOT_ALLOWED    = 0x08,
    EM_EMM_CAUSE_UE_ID_NOT_DERIVED_BY_NW    = 0x09,
    EM_EMM_CAUSE_IMPLICIT_DETACH    = 0x0a,
    EM_EMM_CAUSE_PLMN_NOT_ALLOWED    = 0x0b,
    EM_EMM_CAUSE_TA_NOT_ALLOWED    = 0x0c,
    EM_EMM_CAUSE_ROAMING_NOT_ALLOWED_IN_TA    = 0x0d,
    EM_EMM_CAUSE_EPS_NOT_ALLOWED_IN_PLMN    = 0x0e,
    EM_EMM_CAUSE_NO_SUITABLE_CELL_IN_TA    = 0x0f,
    EM_EMM_CAUSE_MSC_NOT_REACHABLE    = 0x10,
    EM_EMM_CAUSE_NW_FAILURE    = 0x11,
    EM_EMM_CAUSE_CS_NOT_AVAILABLE    = 0x12,
    EM_EMM_CAUSE_ESM_FAILURE    = 0x13,
    EM_EMM_CAUSE_MAC_FAILURE    = 0x14,
    EM_EMM_CAUSE_SYNCH_FAILURE    = 0x15,
    EM_EMM_CAUSE_CONGESTION    = 0x16,
    EM_EMM_CAUSE_UE_SEC_CAPA_MISMATCH    = 0x17,
    EM_EMM_CAUSE_SEC_MODE_REJ_UNSPECIFIED    = 0x18,
    EM_EMM_CAUSE_NOT_AUTH_FOR_CSG    = 0x19,
    EM_EMM_CAUSE_NON_EPS_AUTH_UNACCEPTABLE    = 0x1a,
    EM_EMM_CAUSE_CS_TEMP_NOT_AVAILABLE    = 0x27,
    EM_EMM_CAUSE_NO_EPS_CTXT_ACT    = 0x28,
    EM_EMM_CAUSE_SEMANTIC_INCORRECT    = 0x5f,
    EM_EMM_CAUSE_INVALID_MANDATORY_INFO    = 0x60,
    EM_EMM_CAUSE_MSG_TYPE_NOT_EXIST    = 0x61,
    EM_EMM_CAUSE_MSG_TYPE_NOT_COMPATIBLE    = 0x62,
    EM_EMM_CAUSE_IE_NOT_EXIST    = 0x63,
    EM_EMM_CAUSE_CONDITIONAL_IE_ERROR    = 0x64,
    EM_EMM_CAUSE_MESSAGE_NOT_COMPATIBLE    = 0x65,
    EM_EMM_CAUSE_PROTOCOL_ERROR    = 0x6f,

    EM_EMM_CAUSE_FORBIDDEN_PLMN, /* 0x70 */
    EM_EMM_CAUSE_NO_COVERAGE                       = 0x72,
    EM_EMM_CAUSE_SIM_REMOVED                       = 0x76,
    EM_EMM_CAUSE_SIM_INVALID_FOR_PS                = 0x78,
    EM_EMM_CAUSE_SIM_INVALID_FOR_CS,
    EM_EMM_CAUSE_SIM_INVALID_FOR_CS_AND_PS
} em_emm_cause_enum;


typedef enum
{
    EM_EMM_ATTACH_TYPE_INVALID = 0,
    EM_EMM_ATTACH_TYPE_EPS_ATTACH    = 1,
    EM_EMM_ATTACH_TYPE_COMBINED_ATTACH    = 2,
    EM_EMM_ATTACH_TYPE_EMERGENCY_ATTACH    = 6
} em_emm_attach_type_enum;

typedef enum
{
    EM_EMM_ATTACH_RESULT_EPS_ONLY_ATTACHED    = 1,
    EM_EMM_ATTACH_RESULT_COMBINED_ATTACHED
} em_emm_attach_result_enum;

typedef enum
{
    EM_EMM_TYPE_NO_ADDITIONAL_INFO = 1,
    EM_EMM_TYPE_SMS_ONLY
}em_emm_additional_update_type_enum;

typedef enum
{
    EM_EMM_RESULT_NO_ADDITIONAL_INFO = 0,
    EM_EMM_RESULT_CSFB_NOT_PREFERRED = 1,
    EM_EMM_RESULT_SMS_ONLY           = 2
}em_emm_additional_update_result_enum;

typedef enum
{
    EM_EMM_UPDATE_TYPE_TAU    = 0,
    EM_EMM_UPDATE_TYPE_COMBINED_TAU,
    EM_EMM_UPDATE_TYPE_COMBINED_TAU_IMSI_ATTACH,
    EM_EMM_UPDATE_TYPE_PERIODIC_TAU,
    EM_EMM_UPDATE_TYPE_INVALID
} em_emm_update_type_enum;

typedef enum
{
    EM_EMM_UPDATE_RESULT_TA_UPDATED = 0,
    EM_EMM_UPDATE_RESULT_COMBINED_UPDATED = 1,
    EM_EMM_UPDATE_RESULT_TA_UPDATED_ISR_ACTIVATED = 4,
    EM_EMM_UPDATE_RESULT_COMBINED_UPDATED_ISR_ACTIVATED = 5,
    EM_EMM_UPDATE_RESULT_INVALID
} em_emm_update_result_enum;

typedef enum
{
    EM_EMM_USER_DETACH_EPS_DETACH  = 1,
    EM_EMM_USER_DETACH_IMSI_DETACH ,
    EM_EMM_USER_DETACH_COMBINED_EPS_IMSI_DETACH
}em_emm_user_detach_type_enum;

typedef enum
{
    EM_EMM_NW_DETACH_TYPE_RE_ATTACH_REQUIRED = 1,
    EM_EMM_NW_DETACH_TYPE_RE_ATTACH_NOT_REQUIRED,
    EM_EMM_NW_DETACH_TYPE_IMSI_DETACH
}em_emm_nw_detach_type_enum;

typedef enum
{
    EM_EMM_IMS_VOICE_OVER_PS_SESSION_IN_S1_MODE_NOT_SUPPORT = 0,
    EM_EMM_IMS_VOICE_OVER_PS_SESSION_IN_S1_MODE_SUPPORT
}em_emm_ims_service_ind_enum;

typedef enum
{
    EM_EMM_EMERGENCY_BEARER_SERVICE_IN_S1_MODE_NOT_SUPPORT = 0,
    EM_EMM_EMERGENCY_BEARER_SERVICE_IN_S1_MODE_SUPPORT
}em_emm_emergency_service_ind_enum;

typedef enum
{
    EM_EMM_ATTACH_NEEDED = 0,
    EM_EMM_ATTACH_REQUEST,
    EM_EMM_ATTACH_COMPLETE,
    EM_EMM_ATTACH_SUCCESS,
    EM_EMM_23G_ATTACH_SUCCESS
}em_emm_attach_status;

typedef enum
{
    EM_EMM_TAU_ONGOING_BEFORE_TAU_REQ = 0,
    EM_EMM_TAU_REQUEST,
    EM_EMM_TAU_COMPLETE,
    EM_EMM_TAU_SUCCESS,
    EM_EMM_TAU_FAIL,
    EM_EMM_TAU_NO_TAU_EVER
}em_emm_tau_status;

typedef struct
{
    plmn_struct plmn_id;
    kal_uint8 lac[2];
}em_emm_lai_struct;

typedef struct
{
    em_sr_type_enum              service_request_type;
    em_sr_cause_enum             service_request_cause;
    em_mo_csfb_cause_enum        mo_csfb_cause;
    em_mt_csfb_paging_id_enum    mt_csfb_paging_id;
	em_emm_cause_enum            ext_service_reject_cause;

}l4c_em_emm_call_para_struct;

typedef struct
{
    em_emm_ecm_status_enum ecm_status;

}l4c_em_emm_conn_para_struct;


typedef struct
{
    em_emm_attach_type_enum                 eps_attach_type;
    em_emm_additional_update_type_enum      attach_additional_update_type;
    em_emm_attach_result_enum               eps_attach_result;
    em_emm_additional_update_result_enum    attach_additional_update_result;
    em_emm_cause_enum                       attach_emm_cause;
    kal_uint32                              attach_attempt_count;
    em_emm_attach_status                    attach_status;

    em_emm_update_type_enum                 tau_req_update_type;
    em_emm_additional_update_type_enum      tau_additional_update_type;
    em_emm_update_result_enum               tau_update_result;
    em_emm_additional_update_result_enum    tau_additional_update_result;
    em_emm_cause_enum                       tau_emm_cause;
    kal_uint32                              tau_attempt_count;
    em_emm_tau_status                       tau_status;

    em_emm_user_detach_type_enum            user_detach_type;
    em_emm_nw_detach_type_enum              nw_detach_type;
    em_emm_cause_enum                       nw_detach_emm_cause;
    kal_uint32                              detach_attempt_count;

    em_emm_ims_service_ind_enum             ims_service_ind;
    em_emm_emergency_service_ind_enum       emergency_service_ind;

    em_emm_lai_struct                       lai;
}l4c_em_emm_reg_para_struct;

typedef struct
{
    plmn_struct selected_plmn;
    kal_uint16        tac;
    em_csg_access_mode_enum  csg_access_mode;
    kal_uint32        csg_id;
    em_lte_duplex_type_enum  duplex_type;
    kal_uint32        cell_id;
}l4c_em_emm_plmnsel_para_struct;

typedef struct
{
    em_emm_update_status_enum update_status;
    em_emm_sim_status_enum cs_sim_status;
    em_emm_sim_status_enum ps_sim_status;
    em_emm_guti_struct guti;

}l4c_em_emm_usimsrv_para_struct;

typedef struct
{
    em_emm_tin_enum tin;
}l4c_em_emm_nvmsrv_para_struct;

typedef struct
{
    kal_uint16  t3402_remaining_time;   //in second
}l4c_em_emm_timersrv_para_struct;

typedef struct
{
    kal_uint8  integrity_alg;
    kal_uint8  ciphering_alg;
    kal_bool   is_last_auth_rej;
} l4c_em_emm_sec_para_struct;

typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum 							em_info;
    l4c_em_emm_call_para_struct             emm_call_para;
    l4c_em_emm_conn_para_struct             emm_conn_para;
    l4c_em_emm_reg_para_struct              emm_reg_para;
    l4c_em_emm_plmnsel_para_struct          emm_plmnsel_para;
    l4c_em_emm_usimsrv_para_struct          emm_usimsrv_para;
    l4c_em_emm_nvmsrv_para_struct           emm_nvmsrv_para;
    l4c_em_emm_timersrv_para_struct         emm_timersrv_para;
    l4c_em_emm_sec_para_struct              emm_sec_para;      
} em_emm_l4c_emm_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum    em_info;
}em_emm_l4c_lai_change_info_ind_struct;

/********************* end of EMM definition ****************************/


/********************* begin of ESM definition ****************************/

typedef enum
{
	EM_ESM_SYSTEM_STATE_ATTACH_NONE,
	EM_ESM_SYSTEM_STATE_ATTACH_INIT,
	EM_ESM_SYSTEM_STATE_ATTACH_ING,
	EM_ESM_SYSTEM_STATE_ATTACH_NORMAL,
	EM_ESM_SYSTEM_STATE_ATTACH_NORMAL_TO_EMC,
	EM_ESM_SYSTEM_STATE_ATTACH_EMERGENCY,
	EM_ESM_SYSTEM_STATE_RAT_CHANGE,
	EM_ESM_SYSTEM_STATE_RAT_2G3G,
    EM_ESM_SYSTEM_MMDC_PS_SWITCH,
    EM_ESM_SYSTEM_RAT_C2K
} l4c_em_esm_system_state_enum;

typedef enum
{
	EM_ESM_RAT_STATE_INACTIVE,
	EM_ESM_RAT_STATE_4G,
	EM_ESM_RAT_STATE_4G23_PENDING,
	EM_ESM_RAT_STATE_4G23_CONTEXT_MAP,
	EM_ESM_RAT_STATE_23G,
	EM_ESM_RAT_STATE_23G4_PENDING,
	EM_ESM_RAT_STATE_23G4_CONTEXT_MAP,
#ifdef __SGLTE__
	EM_ESM_RAT_STATE_MMDC4G2_PENDING,
	EM_ESM_RAT_STATE_MMDC4G2_CONTEXT_MAP,
	EM_ESM_RAT_STATE_MMDC2G4_PENDING,
	EM_ESM_RAT_STATE_MMDC2G4_CONTEXT_MAP,
#endif
    EM_ESM_RAT_STATE_4GC2K_PENDING,
    EM_ESM_RAT_STATE_C2K4G_PENDING,
    EM_ESM_RAT_STATE_C2K4G_ATTACHING,
    EM_ESM_RAT_STATE_C2K
} l4c_em_esm_rat_state_enum;

typedef struct
{
    l4c_em_esm_system_state_enum    em_esm_sys_state;
    l4c_em_esm_rat_state_enum       em_esm_rat_state;

    kal_uint8                       em_esm_active_pt_num;
    kal_uint8                       em_esm_active_epsb_num;
    kal_uint8                       em_esm_active_drb_num;
} l4c_em_esm_status_struct;

typedef enum
{
    EM_ESM_PT_REQ_REASON_NULL,
    EM_ESM_PT_REQ_REASON_REGISTER,
    EM_ESM_PT_REQ_REASON_ADD_PDN_CONN,
    EM_ESM_PT_REQ_REASON_ALLOC_BEARER_RSC,
    EM_ESM_PT_REQ_REASON_MOD_BEARER_RSC,
    EM_ESM_PT_REQ_REASON_DEACT_DED_BEARER,
    EM_ESM_PT_REQ_REASON_RMV_PDN_CONN
} l4c_em_esm_pt_req_reason_enum;

typedef enum
{
    EM_ESM_PT_STATE_TERM,
    EM_ESM_PT_STATE_INACTIVE,
    EM_ESM_PT_STATE_WAIT_MM_RES,
    EM_ESM_PT_STATE_PENDING,
    EM_ESM_PT_STATE_WAIT_RESEND,
    EM_ESM_PT_STATE_COMPLETE,
    EM_ESM_PT_STATE_RESERVED,
    EM_ESM_PT_STATE_WAIT_TERM
} l4c_em_esm_pt_state_enum;

typedef struct
{
    kal_bool                        is_active;
    kal_uint8                       pti;

    l4c_em_esm_pt_req_reason_enum   pt_req_reason;
    l4c_em_esm_pt_state_enum        pt_state;

    kal_uint8                       cid;
    kal_uint8                       ebi;
} l4c_em_esm_pt_struct;

typedef enum
{
    EM_ESM_EPSBC_TYPE_INVALID,
    EM_ESM_EPSBC_TYPE_DEFAULT_EPSB,
    EM_ESM_EPSBC_TYPE_DEDICATED_EPSB
} l4c_em_esm_epsbc_bearer_type_enum;

#define EM_MAX_APN_LEN  100

typedef struct
{
    kal_uint8   length;
    kal_uint8   data[EM_MAX_APN_LEN];
} em_apn_struct;

typedef struct
{
    kal_bool                            is_active;
    kal_uint8                           ebi;
    l4c_em_esm_epsbc_bearer_type_enum   bearer_type;
    kal_bool                            is_emergency_bearer;
    nas_priority_config_enum            nas_priority_config;   // __MTC_SUPPORT__
    eab_override_config_enum            eab_override_config;   // __MTC_SUPPORT__

    kal_uint8                           linked_ebi;
    kal_uint8                           qci;

    ip_addr_struct                      ip_addr;
    em_apn_struct                       apn;
} l4c_em_esm_epsbc_struct;

#define EM_L4C_ESM_MAX_PT_NUM           10
#define EM_L4C_ESM_MAX_EPSB_NUM         11

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                        em_info;

    l4c_em_esm_status_struct            esm_status;
    l4c_em_esm_pt_struct                esm_pt[EM_L4C_ESM_MAX_PT_NUM];
    l4c_em_esm_epsbc_struct             esm_epsbc[EM_L4C_ESM_MAX_EPSB_NUM];
} em_esm_l4c_esm_info_ind_struct;

/********************* end of ESM definition ****************************/


/********************* begin of IMC definition ****************************/

typedef struct
{
    kal_uint8        src_ip[64];
    kal_uint8        dst_ip[64];
    kal_uint8        src_port[16];
    kal_uint8        dst_port[16];
    kal_uint8        spi[32];
    kal_uint8        dir;          //0:in 1:out
    kal_uint8        padding[3];
} l4c_em_imc_ipsec_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
} em_imc_ipsec_info_flush_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    l4c_em_imc_ipsec_info_struct   ipsec_info[4];
    kal_uint8                      index;
    kal_uint8                      transport;          //0:udp 1:tcp
    kal_uint8                      mode;               //0:Transport 1:Tunnel
    kal_uint8                      protocol;           //0:AH 1:ESP
    kal_uint8                      encry_algo;         /* VoLTE_Stack_IPSec_Encry_Algo_e */
    kal_uint8                      integrity_algo;     /* enum VoLTE_Stack_IPSec_Integrity_Algo_e */
    kal_uint8                      padding[2];
    kal_uint8                      ck[256];
    kal_uint8                      ik[256];
} em_imc_ipsec_info_add_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8                      index;
    kal_uint8                      padding[3];
} em_imc_ipsec_info_delete_ind_struct;


/********************* end of IMC definition ****************************/

typedef struct
{
    kal_uint8 group_id;                  /* Group ID */
    unsigned char group_name[MAX_LEN_OF_NW_GROUP_NAME];

    module_type  mod_id;                 /* Mod ID */

    kal_uint32 event_id;                 /* Evnet ID */
    unsigned char event_name[MAX_LEN_OF_NW_EVENT_NAME];

    kal_uint16 ring_tone_id;             /* Ring Tone ID */
} em_network_event_struct;

extern em_network_event_struct em_network_event_tbl[];

extern kal_uint32 em_get_total_mod(void);

extern kal_uint32 em_get_total_info_req(void);

extern kal_uint32 em_nw_get_total_event(void);

typedef enum
{
	RAC_EM_NO_SERVICE,
	RAC_EM_LIMITED_SERVICE,
	RAC_EM_GSM,
	RAC_EM_UMTS_FDD,
	RAC_EM_UMTS_TDD,
	RAC_EM_LTE_FDD,
	RAC_EM_LTE_TDD
}rac_em_active_rat_info_enum;

typedef enum
{
    RAC_EM_MDMI_NO_SERVICE,
    RAC_EM_MDMI_GSM,
    RAC_EM_MDMI_UMTS,
    RAC_EM_MDMI_LTE,
    RAC_EM_MDMI_CDMA,
    RAC_EM_MDMI_WIFI,
    RAC_EM_MDMI_DEFAULT = 0xff
} rac_em_mdmi_rat_info_enum;

typedef enum
{
    L4_EM_EVENT_RAT_CHANGE = 0x01,    //bitmask
    L4_EM_EVENT_MDMI_RAT_INFO = 0x02
} l4c_em_event_enum;

typedef enum
{
    RAC_EM_HOME,
    RAC_EM_HOME_EQUIV,
    RAC_EM_ROAMING
} rac_em_plmn_state_enum;

typedef enum
{
    RAC_EM_ATT_NO_SERVICE,
    RAC_EM_ATT_EMERGENCY,
    RAC_EM_ATT_SEARCHING,
    RAC_EM_ATT_GSM,
    RAC_EM_ATT_UMTS,
    RAC_EM_ATT_LTE,
    RAC_EM_ATT_HOME,
    RAC_EM_ATT_EQHOME,
    RAC_EM_ATT_ROAMING,
    RAC_EM_ATT_OFF,
    RAC_EM_ATT_NONE,
    RAC_EM_ATT_UNKNOWN = 0xff
} rac_em_att_service_state_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                        em_info;
    ue_mode_enum                        ue_mode;
    kal_bool                            is_sms_over_ip;
    ue_usage_setting_enum               ue_usage_setting;
    l4_voice_domain_preference_enum     eutran_vdp;
    rac_em_active_rat_info_enum         active_rat_info;
    rac_em_att_service_state_enum       att_radio_service_state;
    rac_em_att_service_state_enum       att_nw_service_state;
} em_rac_info_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum            em_info;

   kal_uint8               source_rat;    /* 0/1/2 -2G/3G/4G */
   kal_uint8               target_rat;
} em_ratcm_23g_rat_change_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum            em_info;

   kal_uint8               irat_type;   /* 0x05: autonomous cell reselection procedure */
                                        /* 0x06: used by NAS to trigger search procedure */
   kal_uint8               source_rat;  /* 0/1/2 -2G/3G/4G/TBD */
   kal_uint8               target_rat;  /* 0/1/2 -2G/3G/4G/TBD */
} em_l4c_rat_change_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR	
   em_info_enum em_info;
}em_errc_abnormal_event_logging_test_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum            em_info;
} em_rac_abnormal_event_no_service_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8    gsm_antenna;
    kal_int16    gsm_current_antenna_rxLevel;
    kal_int16    gsm_other_antenna_rxLevel;
    kal_int32    gsm_current_average_snr;
    kal_int32    gsm_other_average_snr;
}em_gsm_tas_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_bool     is_abnormal; 
    kal_uint16   usid[10];
    kal_uint16   pid[10];
    kal_uint16   mid[10];
}em_mmrf_mipi_hw_info_ind_struct;

/********************* begin of TDD L1 definition ****************************/

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum  em_info;
    kal_uint16    force_tx_en;
    kal_uint16    force_ant_idx;
    kal_uint16    cur_ant_idx;
    kal_int16     ant0_rscp;
    kal_int16     ant0_rssi;
    kal_int16     ant0_sinr;
    kal_int16     ant1_rscp;
    kal_int16     ant1_rssi;    
    kal_int16     ant1_sinr;
    kal_int16     tx_pwr;    
} em_tdd_l1_tas_info_ind_struct;

/********************* end of TDD L1 definition ****************************/

/***************************************************************************** 
   Below enum is used as a tag for ELT tool to recognize EM view version.
   Version 2 means the load is for MT6291 or after, and ELT may use different 
   binding logic for some EM views 
   Only EM contact window and tool team can modify this enum 
******************************************************************************/
typedef enum
{
    EM_Views_Version = 2 // 2 for the new EM views from MT6291
} EM_Version_Info;

typedef enum {
    BACKGROUND_ATUO_LIST = 0,
    BACKGROUND_MANUAL_LIST = 1
} background_list_type;

typedef struct
{
    kal_uint8 plmn_id[3];
    kal_uint8 rat;
}nwsel_em_pplmn_rat_struct;

typedef struct
{
    kal_uint8 plmn_id[3];
    kal_uint8 plmn_details;  /* b8, Signal Quality: 0-Signal HIGH, 1-Signal LOW 
                                b5-b4, RAT: 00-GSM, 01-UMTS.
                                b3-b1, PLMN Category: 000-HPLMN, 001-PREFERRED PLMN, 010-USER Preferred PLMN, 
                                                      011-OPERATOR Preferred PLMN, 100-OTHER PLMN */
    kal_uint8 signal_strength;
}nwsel_em_detail_plmn_info_struct;

typedef struct
{
    kal_uint32       time_scan_start;
    kal_uint32       time_scan_end;
    kal_uint16       band_ind;
    kal_uint16       dl_arfcn;   //For GSM, dl_arfcn should be 0xFFFF.
    kal_uint16       ul_arfcn;   //For GSM, ul_arfcn should be 0xFFFF.
    kal_uint16       gsm_bsic;   //For UMTS/LTE, gsm_bsic should be 0xFFFF.
    kal_uint16       gsm_arfcn;  //For UMTS/LTE, gsm_arfcn should be 0xFFFF.
}nwsel_em_detail_plmn_freq_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 network_selection_mode; /* 0-Auto,1-Manual,2-Limited */
    kal_uint8 rat;
    background_list_type service_search;
    kal_uint16 num_pplmns;
    nwsel_em_pplmn_rat_struct pplmns[MMRR_MAX_NUM_PRIORITY_PLMNS];  /* Amazon Software Reqirements Specification request 20 pplmn/rat combinations */
} em_nwsel_plmn_list_req_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 network_selection_mode;
    kal_bool  search_complete;
    background_list_type service_search;
    kal_uint8 num_available_plmns;
    nwsel_em_detail_plmn_info_struct info[MMRR_MAX_NUM_AVAILABLE_PLMNS];
    nwsel_em_detail_plmn_freq_struct info_freq[MMRR_MAX_NUM_AVAILABLE_PLMNS];
} em_nwsel_plmn_list_cnf_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 network_selection_mode;
    nwsel_em_pplmn_rat_struct requested_plmn;
} em_nwsel_plmn_search_req_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_bool result;
    kal_uint8 num_available_plmns;
    nwsel_em_detail_plmn_info_struct info[MMRR_MAX_NUM_AVAILABLE_PLMNS];
} em_nwsel_plmn_search_cnf_info_type2_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16 num_of_plmn;
    nwsel_em_pplmn_rat_struct plmn_rat_info[MMRR_MAX_NUM_HPLMN_RAT_DATA];
} em_nwsel_hplmn_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16 num_of_plmn;
    nwsel_em_pplmn_rat_struct plmn_rat_info[MMRR_MAX_NUM_OPLMN_RAT_DATA];
} em_nwsel_oplmn_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16 num_of_plmn;
    nwsel_em_pplmn_rat_struct plmn_rat_info[MMRR_MAX_NUM_STATIC_APPLMN_RAT_DATA];
} em_nwsel_static_applmn_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16 num_of_plmn;
    nwsel_em_pplmn_rat_struct plmn_rat_info[MMRR_MAX_NUM_DYNAMIC_APPLMM_RAT_DATA];
} em_nwsel_dynamic_applmn_info_ind_struct;

#define EM_CC_ECPI_NUM_LEN  (81) //MAX_CC_ECPI_NUM_LEN
#define EM_CC_MAX_ASSERTED_URI        (512) //IMC_MAX_ASSERTED_URI

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   
   kal_uint8 call_id;
   kal_bool is_ibt;
   kal_bool is_tch;
   kal_bool is_emergency;
   kal_uint8 call_dir;  //ims_call_dir_enum
   kal_uint8 call_mode;   //ims_call_mode_enum
   kal_uint8 msg_type; 
   kal_uint8 call_type; //ims_call_type_enum
   kal_uint32 disc_cause; //ims_disc_cause_enum
   kal_uint8 number[EM_CC_ECPI_NUM_LEN];
   kal_uint8 p_assert_uri[EM_CC_MAX_ASSERTED_URI];
} em_call_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 mdmi_rat_info;
} em_l4c_mdmi_rat_info_ind_struct;

//--------------------------------------------------

typedef enum
{

	SPH_CODEC_FR = 0, 
	SPH_CODEC_HR,
	SPH_CODEC_EFR,
	SPH_CODEC_AMR_12_20,
	SPH_CODEC_AMR_10_20,
	SPH_CODEC_AMR_7_95,
	SPH_CODEC_AMR_7_40,
	SPH_CODEC_AMR_6_70,
	SPH_CODEC_AMR_5_90,
	SPH_CODEC_AMR_5_15,
	SPH_CODEC_AMR_4_75,
	SPH_CODEC_AMR_SID,
	SPH_CODEC_AMR_NODATA,	
	
	SPH_CODEC_AMRWB_6_60 = 0x20,
	SPH_CODEC_AMRWB_8_85,
	SPH_CODEC_AMRWB_12_65,
	SPH_CODEC_AMRWB_14_25,
	SPH_CODEC_AMRWB_15_85,
	SPH_CODEC_AMRWB_18_25,
	SPH_CODEC_AMRWB_19_85,
	SPH_CODEC_AMRWB_23_05,
	SPH_CODEC_AMRWB_23_85,
	SPH_CODEC_AMRWB_SID,  
	SPH_CODEC_LOST_FRAME,

	SPH_CODEC_C2K_SO1=0x30, // c2k 
	SPH_CODEC_C2K_SO3,
	SPH_CODEC_C2K_SO17,
	SPH_CODEC_C2K_SO68,
	SPH_CODEC_C2K_SO73,
	SPH_CODEC_C2K_SO73WB,

	
	SPH_CODEC_G711=0x60,
	SPH_CODEC_G722,   
	SPH_CODEC_G723_1,
	SPH_CODEC_G726,
	SPH_CODEC_G729,
  
	SPH_CODEC_EVS_08K_005_9	   =0x80,
	SPH_CODEC_EVS_08K_002_8	   =0x80,
	SPH_CODEC_EVS_08K_007_2	   =0x81,
	SPH_CODEC_EVS_08K_008_0	   =0x82,
	SPH_CODEC_EVS_08K_009_6	   =0x83,
	SPH_CODEC_EVS_08K_013_2	   =0x84,
	SPH_CODEC_EVS_08K_016_4	   =0x85,
	SPH_CODEC_EVS_08K_024_4	   =0x86,
	SPH_CODEC_EVS_08K_032_0	   =0x87,
	SPH_CODEC_EVS_08K_048_0	   =0x88,
	SPH_CODEC_EVS_08K_064_0	   =0x89,
	SPH_CODEC_EVS_08K_096_0	   =0x8A,
	SPH_CODEC_EVS_08K_128_0	   =0x8B,
	SPH_CODEC_EVS_08K_002_4_SID   =0x8C,
	SPH_CODEC_EVS_08K_000_0_REV   =0x8D,
	SPH_CODEC_EVS_08K_000_0_LOST  =0x8E,
	SPH_CODEC_EVS_08K_000_0_NODATA=0x8F,
  
	SPH_CODEC_EVS_16K_005_9	   =0x90,
	SPH_CODEC_EVS_16K_002_8	   =0x90,
	SPH_CODEC_EVS_16K_007_2	   =0x91,
	SPH_CODEC_EVS_16K_008_0	   =0x92,
	SPH_CODEC_EVS_16K_009_6	   =0x93,
	SPH_CODEC_EVS_16K_013_2	   =0x94,
	SPH_CODEC_EVS_16K_016_4	   =0x95,
	SPH_CODEC_EVS_16K_024_4	   =0x96,
	SPH_CODEC_EVS_16K_032_0	   =0x97,
	SPH_CODEC_EVS_16K_048_0	   =0x98,
	SPH_CODEC_EVS_16K_064_0	   =0x99,
	SPH_CODEC_EVS_16K_096_0	   =0x9A,
	SPH_CODEC_EVS_16K_128_0	   =0x9B,
	SPH_CODEC_EVS_16K_002_4_SID   =0x9C,
	SPH_CODEC_EVS_16K_000_0_REV   =0x9D,
	SPH_CODEC_EVS_16K_000_0_LOST  =0x9E,
	SPH_CODEC_EVS_16K_000_0_NODATA=0x9F,
  
	SPH_CODEC_EVS_32K_005_9	   =0xA0,
	SPH_CODEC_EVS_32K_002_8	   =0xA0,
	SPH_CODEC_EVS_32K_007_2	   =0xA1,
	SPH_CODEC_EVS_32K_008_0	   =0xA2,
	SPH_CODEC_EVS_32K_009_6	   =0xA3,
	SPH_CODEC_EVS_32K_013_2	   =0xA4,
	SPH_CODEC_EVS_32K_016_4	   =0xA5,
	SPH_CODEC_EVS_32K_024_4	   =0xA6,
	SPH_CODEC_EVS_32K_032_0	   =0xA7,
	SPH_CODEC_EVS_32K_048_0	   =0xA8,
	SPH_CODEC_EVS_32K_064_0	   =0xA9,
	SPH_CODEC_EVS_32K_096_0	   =0xAA,
	SPH_CODEC_EVS_32K_128_0	   =0xAB,
	SPH_CODEC_EVS_32K_002_4_SID   =0xAC,
	SPH_CODEC_EVS_32K_000_0_REV   =0xAD,
	SPH_CODEC_EVS_32K_000_0_LOST  =0xAE,
	SPH_CODEC_EVS_32K_000_0_NODATA=0xAF,
  
	SPH_CODEC_EVS_48K_005_9	   =0xB0,
	SPH_CODEC_EVS_48K_002_8	   =0xB0,
	SPH_CODEC_EVS_48K_007_2	   =0xB1,
	SPH_CODEC_EVS_48K_008_0	   =0xB2,
	SPH_CODEC_EVS_48K_009_6	   =0xB3,
	SPH_CODEC_EVS_48K_013_2	   =0xB4,
	SPH_CODEC_EVS_48K_016_4	   =0xB5,
	SPH_CODEC_EVS_48K_024_4	   =0xB6,
	SPH_CODEC_EVS_48K_032_0	   =0xB7,
	SPH_CODEC_EVS_48K_048_0	   =0xB8,
	SPH_CODEC_EVS_48K_064_0	   =0xB9,
	SPH_CODEC_EVS_48K_096_0	   =0xBA,
	SPH_CODEC_EVS_48K_128_0	   =0xBB,
	SPH_CODEC_EVS_48K_002_4_SID   =0xBC,
	SPH_CODEC_EVS_48K_000_0_REV   =0xBD,
	SPH_CODEC_EVS_48K_000_0_LOST  =0xBE,
	SPH_CODEC_EVS_48K_000_0_NODATA=0xBF,
  
	SPH_CODEC_EVS_AWB_06_60	   =0xD0,
	SPH_CODEC_EVS_AWB_08_85	   =0xD1,
	SPH_CODEC_EVS_AWB_12_65	   =0xD2,
	SPH_CODEC_EVS_AWB_14_25	   =0xD3,
	SPH_CODEC_EVS_AWB_15_85	   =0xD4,
	SPH_CODEC_EVS_AWB_18_25	   =0xD5,
	SPH_CODEC_EVS_AWB_19_85	   =0xD6,
	SPH_CODEC_EVS_AWB_23_05	   =0xD7,
	SPH_CODEC_EVS_AWB_23_85	   =0xD8,
	SPH_CODEC_EVS_AWB_02_00_SID   =0xD9,
	SPH_CODEC_EVS_AWB_00_00_REV0  =0xDA,
	SPH_CODEC_EVS_AWB_00_00_REV1  =0xDB,
	SPH_CODEC_EVS_AWB_00_00_REV2  =0xDC,
	SPH_CODEC_EVS_AWB_00_00_REV3  =0xDD,
	SPH_CODEC_EVS_AWB_00_00_LOST  =0xDE,
	SPH_CODEC_EVS_AWB_00_00_NODATA=0xDF,
  
	SPH_CODEC_CODEC_NONE				 =0xFF,
}em_speech_info_SpeechCodecType;


typedef enum {
   SPH_NETWORK_IDLE = 0, 
   SPH_NETWORK_2G_SPEECH_ON,
   SPH_NETWORK_3G_SPEECH_ON,
   SPH_NETWORK_3G324M_SPEECH_ON,
   SPH_NETWORK_3G_SPEECH_CLOSING,    
   SPH_NETWORK_4G_SPEECH_ON,
   SPH_NETWORK_4G_SPEECH_CLOSING,    
}em_speech_info_SpeechNetworkType; 


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum             em_info;
    em_speech_info_SpeechCodecType   ulSphCodec;
    em_speech_info_SpeechCodecType   dlSphCodec;
	em_speech_info_SpeechNetworkType sphNetwork;
} em_speech_info_sph_codec_ind_struct;


/********************* begin of LTECSR definition ****************************/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32 ssrc;
    kal_uint8 codec_type;
    kal_uint8 codec_rate;

}em_ltecsr_rtp_codec_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32 ssrc;
    kal_uint16 pkt_loss_count;

}em_ltecsr_rtp_packet_loss_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32 ssrc;
    kal_uint16 delay;

}em_ltecsr_rtp_one_way_delay_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32 ssrc;
    kal_uint16 jitter;

}em_ltecsr_rtp_jitter_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32 ssrc;
    kal_uint16 rtp_sn;
    kal_uint16 jitter_buffer_delay;

}em_ltecsr_rtp_jitter_buffer_delay_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8 dir;
    kal_uint16 payload_len;      // it is the [IP|UDP|RTP] header len
    kal_uint16 total_len;

    /* Move payload to peer buff for size flexibility */
    //kal_uint8 payload[124];    // 40(IPv6) + 8(UDP) + 76(RTP)

}em_ltecsr_rtp_ota_msg_ind_struct;


/* ATT CIQ part */
#define EM_LTECSR_MAX_MEDIA_STAT_NUM 8

typedef struct
{
    kal_uint16  wPort;
    kal_uint8   ucMediaType;
    kal_uint8   ucFormat;
    kal_uint32  dwDuration;
    kal_uint32  dwPacketsRcvd;
    kal_uint32  dwPacketsDrop;
    kal_uint32  dwPacketsLate;
}iq_rtp_stats_t;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint16      wNumMediaTracks;
    iq_rtp_stats_t  tMediaStats[EM_LTECSR_MAX_MEDIA_STAT_NUM]; // MAX media num in a session
}em_ltecsr_session_stat_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint16  wByteCount;
    kal_uint16  wDstPort;
    kal_uint8   ucFlags;
    kal_uint8   ucPayloadType;
    kal_uint16  wSequenceNum;
    kal_uint32  dwTimestamp;
    kal_uint32  dwSourceId;
}em_ltecsr_xmit_pkt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint16  wByteCount;
    kal_uint16  wDstPort;
    kal_uint8   ucPktStatus;
    kal_uint8   ucFlags;
    kal_uint8   ucPayloadType;
    kal_uint16  wSequenceNum;
    kal_uint32  dwTimestamp;
    kal_uint32  dwSourceId;
}em_ltecsr_recv_pkt_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32  dwSsrc;
    kal_uint32  dwDuration;
    kal_uint32  dwPktCount;
    kal_uint32  dwByteCount;
    kal_uint16  wDstPort;
    kal_uint16  wMeanJitter;
    kal_uint8   ucMediaType;
    kal_uint8   ucIpVersion;
    kal_uint8   strIpDstAddr[16];   // IPv6
}em_ltecsr_xmit_stat_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint32  dwSsrc;
    kal_uint32  dwDuration;
    kal_uint32  dwPktCount;
    kal_uint32  dwPktLoss;
    kal_uint32  dwByteCount;
    kal_uint16  wDstPort;
    kal_uint16  wMeanJitter;
    kal_uint16  wMaxJitter;
    kal_uint16  wMaxDelta;
    kal_uint16  wCumAvgPktSize;
    kal_uint8   ucMediaType;
    kal_uint8   ucIpVersion;
    kal_uint8   strIpSrcAddr[16];   // IPv6
}em_ltecsr_recv_stat_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint64  sys_time;
    kal_uint8   dir;
    kal_uint8   rat;
    kal_uint8   ip_ver;
    kal_uint8   src_ip[16];
    kal_uint8   dst_ip[16];
    kal_uint16  src_port;
    kal_uint16  dst_port;
    kal_uint8   audio_codec;
    kal_uint16  jitter;
    kal_uint8   cmr;
    kal_uint8   frame_num;

    /* peer buff here to store UDP packet raw data */

}em_ltecsr_rtp_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint64  sys_time;
    kal_uint8   dir;
    kal_uint8   rat;
    kal_uint8   ip_ver;
    kal_uint8   src_ip[16];
    kal_uint8   dst_ip[16];
    kal_uint16  src_port;
    kal_uint16  dst_port;

    /* peer buff here to store UDP packet raw data */

}em_ltecsr_rtcp_info_ind_struct;
/********************* end of LTECSR definition ****************************/


#endif /* ~_EM_STRUCT_H */

